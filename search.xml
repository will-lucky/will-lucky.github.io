<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>nginx配置SSL证书</title>
    <url>/2022/05/26/nginx%E9%85%8D%E7%BD%AESSL%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>使用openssl生成SSL证书，并配置nginx</p>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p><strong>SSL</strong></p>
<p>Secure Socket Layer，为<a href="https://baike.baidu.com/item/Netscape">Netscape</a>所研发，用以保障在Internet上数据传输的安全，利用<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86">数据加密</a>(Encryption)技术，可确保数据在网络上的传输过程中不会被截取及窃听。一般通用的规格为40 bit的安全标准，<a href="https://baike.baidu.com/item/%E7%BE%8E%E5%9B%BD">美国</a>则已推出128 bit的更高安全标准。只要3.0版本以上的I.E.或Netscape<a href="https://baike.baidu.com/item/%E6%B5%8F%E8%A7%88%E5%99%A8">浏览器</a>即可支持SSL。</p>
<p>当前版本为3.0。它已被广泛地用于<a href="https://baike.baidu.com/item/Web%E6%B5%8F%E8%A7%88%E5%99%A8">Web浏览器</a>与服务器之间的<a href="https://baike.baidu.com/item/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81">身份认证</a>和加密数据传输。</p>
<p>SSL协议位于<a href="https://baike.baidu.com/item/TCP%2FIP%E5%8D%8F%E8%AE%AE">TCP&#x2F;IP协议</a>与各种<a href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/3668945">应用层协议</a>之间，为<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E9%80%9A%E8%AE%AF">数据通讯</a>提供安全支持。<a href="https://baike.baidu.com/item/SSL%E5%8D%8F%E8%AE%AE/4602579">SSL协议</a>可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的<a href="https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">传输协议</a>（如TCP）之上，为高层协议提供<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85">数据封装</a>、压缩、加密等基本功能的支持。 SSL<a href="https://baike.baidu.com/item/%E6%8F%A1%E6%89%8B%E5%8D%8F%E8%AE%AE">握手协议</a>（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行<a href="https://baike.baidu.com/item/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81">身份认证</a>、协商<a href="https://baike.baidu.com/item/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95">加密算法</a>、交换加密<a href="https://baike.baidu.com/item/%E5%AF%86%E9%92%A5">密钥</a>等。</p>
<p><strong>https</strong></p>
<p>HTTPS（<strong>Hypertext Transfer Protocol Secure</strong>）<a href="https://baike.baidu.com/item/%E5%AE%89%E5%85%A8%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">安全超文本传输协议</a></p>
<p>它是由Netscape开发并内置于其<a href="https://baike.baidu.com/item/%E6%B5%8F%E8%A7%88%E5%99%A8">浏览器</a>中，用于对数据进行压缩和解压操作，并返回网络上传送回的结果。HTTPS实际上应用了Netscape的安全<a href="https://baike.baidu.com/item/%E5%A5%97%E6%8E%A5%E5%AD%97">套接字</a>层（SSL）作为HTTP<a href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E5%B1%82">应用层</a>的子层。（HTTPS使用端口443，而不是像HTTP那样使用端口80来和TCP&#x2F;IP进行通信。）SSL使用40 位关键字作为RC4流<a href="https://baike.baidu.com/item/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95">加密算法</a>，这对于商业信息的加密是合适的。HTTPS和SSL支持使用X.509<a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E8%AE%A4%E8%AF%81">数字认证</a>，如果需要的话用户可以确认发送者是谁。</p>
<p><strong>CA机构颁发SSL证书</strong></p>
<p>一般说来，在网上进行电子商务交易时，交易双方需要使用数字签名来表明自己的身份，并使用<a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D">数字签名</a>来进行有关的交易操作。随着电子商务的盛行，数字签章的颁发机构 CA中心将为电子商务的发展提供可靠的安全保障。</p>
<p>一个有效、可信的 SSL 数字证书包括一个公共密钥和一个私用密钥。公共密钥用于加密信息，私用密钥用于解译加密的信息。因此，浏览器指向一个安全域时，SSL 将同步确认服务器和客户端，并创建一种加密方式和一个唯一的会话密钥。一般而言，由 CA 业界发出的数字证书，有别于国内浏览器业者比对域名信息等方式，采取更为严格的企业及所有权验证，为电商环境树立更为可信的运作环境。</p>
<p><strong>自签名SSL证书</strong></p>
<p>自己生成的SSL证书，不是CA机构颁发的SSL证书，就是自签名证书。自签名SSL证书不会被浏览器信任，数据被泄漏级劫持安全漏洞安全风险较高。可以在PC上安装自签名SSL证书对应的公钥证书，使浏览器信任认可。</p>
<p><strong>cer证书和pfx证书</strong></p>
<p>项目的入口网关需要一张pfx证书，pfx证书同时包含了公钥信息和私钥信息。cer证书只包含公钥信息，提供给客户端使用。</p>
<h3 id="openssl生成自签名证书"><a href="#openssl生成自签名证书" class="headerlink" title="openssl生成自签名证书"></a>openssl生成自签名证书</h3><blockquote>
<p>Linux系统自带openssl，可以登录任意Linux系统的机器操作。</p>
</blockquote>
<h4 id="1、生成RSA私钥"><a href="#1、生成RSA私钥" class="headerlink" title="1、生成RSA私钥"></a>1、生成RSA私钥</h4><p><code>openssl genrsa -des3 -out private-rsa.key 1024</code></p>
<ul>
<li>-des3:生成的密钥使用des3方式进行加密。</li>
<li>-out private-rsa.key:将生成的私钥保存至private-rsa.key文件。</li>
<li>1024为要生成的私钥的长度。</li>
</ul>
<p><img data-src="/2022/05/26/nginx%E9%85%8D%E7%BD%AESSL%E8%AF%81%E4%B9%A6/image-20220526183555835.png"></p>
<h4 id="2、生成cer证书"><a href="#2、生成cer证书" class="headerlink" title="2、生成cer证书"></a>2、生成cer证书</h4><p><code>openssl req -new -x509 -key private-rsa.key -days 3650 -out public-rsa.cer</code></p>
<ul>
<li><p>-new  :说明生成证书请求文件</p>
</li>
<li><p>-x509  :说明生成自签名证书</p>
</li>
<li><p>-key  :指定已有的秘钥文件生成秘钥请求，只与生成证书请求选项-new配合。</p>
</li>
<li><p>-days:证书有效天数</p>
</li>
<li><p>-out:指定生成的证书请求或者自签名证书名称</p>
</li>
</ul>
<p><img data-src="/2022/05/26/nginx%E9%85%8D%E7%BD%AESSL%E8%AF%81%E4%B9%A6/image-20220526184357774.png"></p>
<h4 id="3、生成pfx证书"><a href="#3、生成pfx证书" class="headerlink" title="3、生成pfx证书"></a>3、生成pfx证书</h4><p><code>openssl pkcs12 -export -name test-alias -in public-rsa.cer -inkey private-rsa.key -out user-rsa.pfx</code></p>
<ul>
<li>-export：指定了一个PKCS#12文件将会被创建。</li>
<li>-name：指定证书的名称。</li>
<li>-in：指定公钥和证书读取的文件。</li>
<li>-inkey：指定私钥文件的位置。</li>
<li>-out：指定输出的pkcs12文件</li>
</ul>
<p>执行命令后，需要输入第一步保护私钥文件的密码以及导出密码。</p>
<p><img data-src="/2022/05/26/nginx%E9%85%8D%E7%BD%AESSL%E8%AF%81%E4%B9%A6/image-20220526184538597.png"></p>
<h4 id="4、使用证书"><a href="#4、使用证书" class="headerlink" title="4、使用证书"></a>4、使用证书</h4><p>至此，就会在当前目录下生成了三个证书文件，pfx证书上传到需要使用证书的服务器上使用，公钥证书交给客户端使用</p>
<p><img data-src="/2022/05/26/nginx%E9%85%8D%E7%BD%AESSL%E8%AF%81%E4%B9%A6/image-20220526184606768.png" alt="image-20220526184606768"></p>
<h4 id="5、nginxSSL证书配置"><a href="#5、nginxSSL证书配置" class="headerlink" title="5、nginxSSL证书配置"></a>5、nginxSSL证书配置</h4><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl; // 这里是新的写法</span><br><span class="line">    <span class="attribute">server_name</span> your-domain.com; // 你的域名</span><br><span class="line">    <span class="comment"># ssl on; // 这种已经不使用了，这么写会报警告，可以直接去掉采用第一行的写法</span></span><br><span class="line">    <span class="attribute">root</span> /xxx/xxx/html; // 前台文件存放文件夹，一般使用 <span class="attribute">Nginx</span> 初始化的文件夹，当然也可以自己修改</span><br><span class="line">    index index.html;// 上面配置的文件夹里面的index.<span class="attribute">html</span></span><br><span class="line">    ssl_certificate  /xxx/cert/<span class="number">214292799730473</span>.pem;// 改成你的证书的名字</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /xxx/cert/<span class="number">214292799730473</span>.key;// 你的证书的名字</span><br><span class="line">    <span class="attribute">ssl_session_timeout</span> <span class="number">5m</span>;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> your-domain.com;// 你的域名</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span> https://<span class="variable">$host</span>:443<span class="variable">$1</span> <span class="literal">permanent</span>;// 把http的域名请求转成https且转发到443端口</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>nginx</category>
        <category>ssl</category>
      </categories>
      <tags>
        <tag>ssl</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>大华DPSDK对接</title>
    <url>/2022/05/28/%E5%A4%A7%E5%8D%8EDPSDK%E5%AF%B9%E6%8E%A5/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>浙江大华平台SDK（以下简称平台SDK）是大华DSS平台的配套产品，包含平台主要相关业务二次开发接口。本文档详细描述了开发包中各业务涉及的接口说明以及流程介绍。适用于以下平台产品的业务开发：</p>
<p>DSS-7016 系列</p>
<p>DSS3.0-平安城市版本系列</p>
<p>DSS3.0-金融版本系列</p>
<p>业务中需要对接到大华的DPSDK，对接8900平台版本为:8900 v3.1.4 bugfix版本(20200426)，在此过程中遇到一些问题，特此记录。</p>
<h3 id="dpsdk版本"><a href="#dpsdk版本" class="headerlink" title="dpsdk版本"></a>dpsdk版本</h3><p>本次对接的是Java版本的DPSDK，分为Windows版和Linux版，两个版本需要的动态库不一样，Windows加载的是.dll， Linux加载的是.so，IDpsdkCore为加载动态库的类。</p>
<p><img data-src="/2022/05/28/%E5%A4%A7%E5%8D%8EDPSDK%E5%AF%B9%E6%8E%A5/image-20220528140409033.png" alt="image-20220528140409033"></p>
<p><img data-src="/2022/05/28/%E5%A4%A7%E5%8D%8EDPSDK%E5%AF%B9%E6%8E%A5/image-20220528140506955.png" alt="image-20220528140506955"></p>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>将sdk的动态库文件放在磁盘的某一文件夹，记录文件夹地址，一般放在工程下的resources目录下，修改IDpsdkCore加载的动态库为Windows，并修改JVM的参数，这里修改的是spring boot启动类的参数，在vm options中添加：</p>
<p><code>-Djava.library.path=D:\IdeaProjects\dahua-dpsdk\src\main\resources\DPSDK</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IDpsdkCore</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;<span class="comment">//windows环境加载</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.loadLibrary(<span class="string">&quot;dslalien&quot;</span>);</span><br><span class="line">            System.loadLibrary(<span class="string">&quot;libdsl&quot;</span>);</span><br><span class="line">            System.loadLibrary(<span class="string">&quot;PicSDK&quot;</span>);</span><br><span class="line">            System.loadLibrary(<span class="string">&quot;Infra&quot;</span>);</span><br><span class="line">            System.loadLibrary(<span class="string">&quot;StreamParser&quot;</span>);</span><br><span class="line">            System.loadLibrary(<span class="string">&quot;StreamPackage&quot;</span>);</span><br><span class="line">            System.loadLibrary(<span class="string">&quot;StreamConvertor&quot;</span>);</span><br><span class="line">            System.loadLibrary(<span class="string">&quot;PlatformSDK&quot;</span>);</span><br><span class="line">            System.loadLibrary(<span class="string">&quot;DPSDK_Core&quot;</span>);</span><br><span class="line">            System.loadLibrary(<span class="string">&quot;DPSDK_Java&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsatisfiedLinkError ulink) &#123;</span><br><span class="line">            ulink.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    static &#123;//linux环境加载加载</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//            System.loadLibrary(&quot;DPSDK_Java&quot;);</span></span><br><span class="line"><span class="comment">//        &#125; catch (UnsatisfiedLinkError var1) &#123;</span></span><br><span class="line"><span class="comment">//            var1.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="/2022/05/28/%E5%A4%A7%E5%8D%8EDPSDK%E5%AF%B9%E6%8E%A5/image-20220528142232856.png" alt="image-20220528142232856"></p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>将sdk的动态库文件放在磁盘的某一文件夹，记录文件夹地址，本次介绍的是jar包的运行方式。</p>
<ol>
<li><p>在打jar包之前修改IDpsdkCore加载的动态库为Linux环境的</p>
</li>
<li><p>设置环境变量：</p>
<p><code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:(libDPSDK_Java.so所在目录绝对路径):(linuxjava中的lib目录绝对路径)</code>   </p>
<p>例如：</p>
<p><code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/root/linuxjava/:/root/linuxjava/lib</code>，</p>
<p>直接命令行执行。</p>
</li>
<li><p>启动jar包java -jar xxx.jar</p>
</li>
</ol>
]]></content>
      <categories>
        <category>issue</category>
      </categories>
      <tags>
        <tag>DPSDK</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql备份命令</title>
    <url>/2022/09/02/Mysql%E5%A4%87%E4%BB%BD%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<blockquote>
<h1 id="Mysql备份命令Mysqldump导入、导出以及压缩成zip、gz格式"><a href="#Mysql备份命令Mysqldump导入、导出以及压缩成zip、gz格式" class="headerlink" title="Mysql备份命令Mysqldump导入、导出以及压缩成zip、gz格式"></a>Mysql备份命令Mysqldump导入、导出以及压缩成zip、gz格式</h1></blockquote>
<p>可以创建一个只有本地备份权限的用户:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;backuser&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;********&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, RELOAD, PROCESS, <span class="keyword">SHOW</span> DATABASES, LOCK TABLES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;backuser&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="1、导出"><a href="#1、导出" class="headerlink" title="1、导出"></a>1、导出</h2><p>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump -u用户名 -p数据库密码 数据库名 &gt; 文件名</span><br></pre></td></tr></table></figure>

<p>如果用户名需要密码，则需要在此命令执行后输入一次密码核对；如果数据库用户名不需要密码，则不要加“-p”参数，导入的时候相同。注意输入的用户名需要拥有对应数据库的操作权限，否则无法导出数据。由于是作系统维护和全部数据库的导出，一般我们使用root等超级用户权限。</p>
<p>比如要将abc这个数据库导出为一个文件名为db_abc.sql的数据库文件到当前目录下，则输入下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -ppassword abc &gt;db_abc.sql</span><br></pre></td></tr></table></figure>

<p>如果要直接导出sql.zip或者gzip格式文件命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -ppassword abc | gzip &gt; db_abc.sql.tar.gz</span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是：-u和-p后面直接跟用户名和密码，不要有空格。</strong></p>
<h2 id="2、导入"><a href="#2、导入" class="headerlink" title="2、导入"></a>2、导入</h2><p>命令：mysql -u用户名 -p数据库密码 数据库名 &lt; 文件名</p>
<p>同mysqldump命令一样的用法，各参数的意义同mysqldump。</p>
<p>比如我们要将&#x2F;root&#x2F;backup&#x2F;db_abc.sql这个文件的数据导入到abc数据库中，则使用下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -uroot -ppassword abc &lt; /root/backup/db_abc.sql</span><br></pre></td></tr></table></figure>

<p>如果是zip或gzip格式则使用下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gunzip &lt; /root/backup/abc.sql.tar.gz | mysql -uroot -ppassword abc</span><br></pre></td></tr></table></figure>



<h2 id="3、其他命令参考"><a href="#3、其他命令参考" class="headerlink" title="3、其他命令参考"></a>3、其他命令参考</h2><p>备份远程MySQL数据库的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump -hhostname -uusername -ppassword databasename &gt; backupfile.sql</span><br></pre></td></tr></table></figure>

<p>备份MySQL数据库为带删除表的格式备份MySQL数据库为带删除表的格式，能够让该备份覆盖已有数据库而不需要手动删除原有数据库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump ---add-drop-table -uusername -ppassword databasename &gt; backupfile.sql</span><br></pre></td></tr></table></figure>

<p>直接将MySQL数据库压缩备份</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump -hhostname -uusername -ppassword databasename | gzip &gt; backupfile.sql.gz</span><br></pre></td></tr></table></figure>

<p>备份MySQL数据库某个(些)表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump -hhostname -uusername -ppassword databasename specific_table1 specific_table2 &gt; backupfile.sql</span><br></pre></td></tr></table></figure>

<p>同时备份多个MySQL数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump -hhostname -uusername -ppassword --databases databasename1 databasename2 databasename3 &gt; multibackupfile.sql</span><br></pre></td></tr></table></figure>

<p>仅仅备份数据库结构</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump --no-data --databases databasename1 databasename2 databasename3 &gt; structurebackupfile.sql</span><br></pre></td></tr></table></figure>

<p>备份服务器上所有数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump --all-databases allbackupfile.sql</span><br></pre></td></tr></table></figure>

<p>还原MySQL数据库的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -hhostname -uusername -ppassword databasename &lt; backupfile.sql</span><br></pre></td></tr></table></figure>

<p>还原压缩的MySQL数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gunzip &lt; backupfile.sql.gz | mysql -uusername -ppassword databasename</span><br></pre></td></tr></table></figure>

<p>将数据库转移到新服务器</p>
<p>1、首先在新的服务器上创建数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database newdatabase;</span><br></pre></td></tr></table></figure>

<p>2、备份</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump -uusername -ppassword olddatabasename | mysql -hhostname -uuserbname –ppassword newdatabasename</span><br></pre></td></tr></table></figure>



<h2 id="4、总结一下压缩备份"><a href="#4、总结一下压缩备份" class="headerlink" title="4、总结一下压缩备份"></a>4、总结一下压缩备份</h2><p>备份并用gzip压缩：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump &lt; mysqldump options&gt; | gzip &gt; outputfile.sql.gz</span><br></pre></td></tr></table></figure>

<p>从gzip备份恢复：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gunzip &lt; outputfile.sql.gz | mysql &lt; mysql options&gt;</span><br></pre></td></tr></table></figure>

<p>备份并用bzip压缩：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump &lt; mysqldump options&gt; | bzip2 &gt; outputfile.sql.bz2</span><br></pre></td></tr></table></figure>

<p>从bzip2备份恢复:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bunzip2 &lt; outputfile.sql.bz2 | mysql &lt; mysql options&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>备份</tag>
      </tags>
  </entry>
  <entry>
    <title>API接口token、timestamp、sign具体实现</title>
    <url>/2022/05/30/API%E6%8E%A5%E5%8F%A3token%E3%80%81timestamp%E3%80%81sign%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="一：token-简介"><a href="#一：token-简介" class="headerlink" title="一：token 简介"></a>一：token 简介</h1><p>Token：访问令牌access token, 用于接口中, 用于标识接口调用者的身份、凭证，减少用户名和密码的传输次数。一般情况下客户端(接口调用方)需要先向服务器端申请一个接口调用的账号，服务器会给出一个appId和一个key, key用于参数签名使用，注意key保存到客户端，需要做一些安全处理，防止泄露。</p>
<p>Token的值一般是UUID，服务端生成Token后需要将token做为key，将一些和token关联的信息作为value保存到缓存服务器中(redis)，当一个请求过来后，服务器就去缓存服务器中查询这个Token是否存在，存在则调用接口，不存在返回接口错误，一般通过拦截器或者过滤器来实现，Token分为两种：</p>
<ul>
<li>API Token(接口令牌): 用于访问不需要用户登录的接口，如登录、注册、一些基本数据的获取等。 获取接口令牌需要拿appId、timestamp和sign来换，sign&#x3D;加密(timestamp+key)</li>
<li>USER Token(用户令牌): 用于访问需要用户登录之后的接口，如：获取我的基本信息、保存、修改、删除等操作。获取用户令牌需要拿用户名和密码来换</li>
</ul>
<p>关于Token的时效性：token可以是一次性的、也可以在一段时间范围内是有效的，具体使用哪种看业务需要。</p>
<p>一般情况下接口最好使用https协议，如果使用http协议，Token机制只是一种减少被黑的可能性，其实只能防君子不能防小人。</p>
<p>一般token、timestamp和sign 三个参数会在接口中会同时作为参数传递，每个参数都有各自的用途。</p>
<hr>
<h1 id="二：timestamp-简介"><a href="#二：timestamp-简介" class="headerlink" title="二：timestamp 简介"></a>二：timestamp 简介</h1><p>timestamp: 时间戳，是客户端调用接口时对应的当前时间戳，时间戳用于防止DoS攻击。当黑客劫持了请求的url去DoS攻击，每次调用接口时接口都会判断服务器当前系统时间和接口中传的的timestamp的差值，如果这个差值超过某个设置的时间(假如5分钟)，那么这个请求将被拦截掉，如果在设置的超时时间范围内，是不能阻止DoS攻击的。 timestamp机制只能减轻DoS攻击的时间，缩短攻击时间。如果黑客修改了时间戳的值可通过sign签名机制来处理。</p>
<h1 id="DoS"><a href="#DoS" class="headerlink" title="DoS"></a>DoS</h1><p>DoS是Denial of Service的简称，即拒绝服务，造成DoS的攻击行为被称为DoS攻击，其目的是使计算机或网络无法提供正常的服务。最常见的DoS攻击有计算机网络带宽攻击和连通性攻击。</p>
<p>DoS攻击是指故意的攻击网络协议实现的缺陷或直接通过野蛮手段残忍地耗尽被攻击对象的资源，目的是让目标计算机或网络无法提供正常的服务或资源访问，使目标系统服务系统停止响应甚至崩溃，而在此攻击中并不包括侵入目标服务器或目标网络设备。这些服务资源包括网络带宽，文件系统空间容量，开放的进程或者允许的连接。这种攻击会导致资源的匮乏，无论计算机的处理速度多快、内存容量多大、网络带宽的速度多快都无法避免这种攻击带来的后果。</p>
<ul>
<li>Pingflood: 该攻击在短时间内向目的主机发送大量ping包，造成网络堵塞或主机资源耗尽。</li>
<li>Synflood: 该攻击以多个随机的源主机地址向目的主机发送SYN包，而在收到目的主机的SYN ACK后并不回应，这样，目的主机就为这些源主机建立了大量的连接队列，而且由于没有收到ACK一直维护着这</li>
</ul>
<p>些队列，造成了资源的大量消耗而不能向正常请求提供服务。</p>
<ul>
<li>Smurf：该攻击向一个子网的广播地址发一个带有特定请求（如ICMP回应请求）的包，并且将源地址伪装成想要攻击的主机地址。子网上所有主机都回应广播包请求而向被攻击主机发包，使该主机受到攻击。</li>
<li>Land-based：攻击者将一个包的源地址和目的地址都设置为目标主机的地址，然后将该包通过IP欺骗的方式发送给被攻击主机，这种包可以造成被攻击主机因试图与自己建立连接而陷入死循环，从而很大程度地降低了系统性能。</li>
<li>Ping of Death：根据TCP&#x2F;IP的规范，一个包的长度最大为65536字节。尽管一个包的长度不能超过65536字节，但是一个包分成的多个片段的叠加却能做到。当一个主机收到了长度大于65536字节的包时，就是受到了Ping of Death攻击，该攻击会造成主机的宕机。</li>
<li>Teardrop：IP数据包在网络传递时，数据包可以分成更小的片段。攻击者可以通过发送两段（或者更多）数据包来实现TearDrop攻击。第一个包的偏移量为0，长度为N，第二个包的偏移量小于N。为了合并这些数据段，TCP&#x2F;IP堆栈会分配超乎寻常的巨大资源，从而造成系统资源的缺乏甚至机器的重新启动。</li>
<li>PingSweep：使用ICMP Echo轮询多个主机。</li>
</ul>
<h1 id="三：sign-简介"><a href="#三：sign-简介" class="headerlink" title="三：sign 简介"></a>三：sign 简介</h1><p>nonce：随机值，是客户端随机生成的值，作为参数传递过来，随机值的目的是增加sign签名的多变性。随机值一般是数字和字母的组合，6位长度，随机值的组成和长度没有固定规则。</p>
<p>sign: 一般用于参数签名，防止参数被非法篡改，最常见的是修改金额等重要敏感参数， sign的值一般是将所有非空参数按照升续排序然后+token+key+timestamp+nonce(随机数)拼接在一起，然后使用某种加密算法进行加密，作为接口中的一个参数sign来传递，也可以将sign放到请求头中。接口在网络传输过程中如果被黑客挟持，并修改其中的参数值，然后再继续调用接口，虽然参数的值被修改了，但是因为黑客不知道sign是如何计算出来的，不知道sign都有哪些值构成，不知道以怎样的顺序拼接在一起的，最重要的是不知道签名字符串中的key是什么，所以黑客可以篡改参数的值，但没法修改sign的值，当服务器调用接口前会按照sign的规则重新计算出sign的值然后和接口传递的sign参数的值做比较，如果相等表示参数值没有被篡改，如果不等，表示参数被非法篡改了，就不执行接口了。</p>
<h1 id="四：防止重复提交"><a href="#四：防止重复提交" class="headerlink" title="四：防止重复提交"></a>四：防止重复提交</h1><p>对于一些重要的操作需要防止客户端重复提交的(如非幂等性重要操作)，具体办法是当请求第一次提交时将sign作为key保存到redis，并设置超时时间，超时时间和Timestamp中设置的差值相同。当同一个请求第二次访问时会先检测redis是否存在该sign，如果存在则证明重复提交了，接口就不再继续调用了。如果sign在缓存服务器中因过期时间到了，而被删除了，此时当这个url再次请求服务器时，因token的过期时间和sign的过期时间一直，sign过期也意味着token过期，那样同样的url再访问服务器会因token错误会被拦截掉，这就是为什么sign和token的过期时间要保持一致的原因。拒绝重复调用机制确保URL被别人截获了也无法使用（如抓取数据）。</p>
<p>对于哪些接口需要防止重复提交可以自定义个注解来标记。</p>
<h1 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h1><p>所有的安全措施都用上的话有时候难免太过复杂，在实际项目中需要根据自身情况作出裁剪，比如可以只使用签名机制就可以保证信息不会被篡改，或者定向提供服务的时候只用Token机制就可以了。如何裁剪，全看项目实际情况和对接口安全性的要求。</p>
<h1 id="五：使用流程"><a href="#五：使用流程" class="headerlink" title="五：使用流程"></a>五：使用流程</h1><ol>
<li>接口调用方(客户端)向接口提供方(服务器)申请接口调用账号，申请成功后，接口提供方会给接口调用方一个appId和一个key参数</li>
<li>客户端携带参数appId、timestamp、sign去调用服务器端的API token，其中sign&#x3D;加密(appId + timestamp + key)</li>
<li>客户端拿着api_token 去访问不需要登录就能访问的接口</li>
<li>当访问用户需要登录的接口时，客户端跳转到登录页面，通过用户名和密码调用登录接口，登录接口会返回一个usertoken, 客户端拿着usertoken 去访问需要登录才能访问的接口</li>
</ol>
<p>sign的作用是防止参数被篡改，客户端调用服务端时需要传递sign参数，服务器响应客户端时也可以返回一个sign用于客户度校验返回的值是否被非法篡改了。客户端传的sign和服务器端响应的sign算法可能会不同。</p>
<h1 id="六：示例代码"><a href="#六：示例代码" class="headerlink" title="六：示例代码"></a>六：示例代码</h1><h1 id="1-dependency"><a href="#1-dependency" class="headerlink" title="1. dependency"></a>1. dependency</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="2-RedisConfiguration"><a href="#2-RedisConfiguration" class="headerlink" title="2. RedisConfiguration"></a>2. RedisConfiguration</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JedisConnectionFactory <span class="title function_">jedisConnectionFactory</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JedisConnectionFactory</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支持存储对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, String&gt; <span class="title function_">redisTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, String&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">StringRedisTemplate</span>();</span><br><span class="line">        redisTemplate.setConnectionFactory(jedisConnectionFactory());</span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line"></span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);</span><br><span class="line">        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        redisTemplate.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-TokenController"><a href="#3-TokenController" class="headerlink" title="3. TokenController"></a>3. TokenController</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/token&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * API Token</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sign</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/api_token&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResponse&lt;AccessToken&gt; <span class="title function_">apiToken</span><span class="params">(String appId, <span class="meta">@RequestHeader(&quot;timestamp&quot;)</span> String timestamp, <span class="meta">@RequestHeader(&quot;sign&quot;)</span> String sign)</span> &#123;</span><br><span class="line">        Assert.isTrue(!StringUtils.isEmpty(appId) &amp;&amp; !StringUtils.isEmpty(timestamp) &amp;&amp; !StringUtils.isEmpty(sign), <span class="string">&quot;参数错误&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">reqeustInterval</span> <span class="operator">=</span> System.currentTimeMillis() - Long.valueOf(timestamp);</span><br><span class="line">        Assert.isTrue(reqeustInterval &lt; <span class="number">5</span> * <span class="number">60</span> * <span class="number">1000</span>, <span class="string">&quot;请求过期，请重新请求&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 根据appId查询数据库获取appSecret</span></span><br><span class="line">        <span class="type">AppInfo</span> <span class="variable">appInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AppInfo</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;12345678954556&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 校验签名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">signString</span> <span class="operator">=</span> timestamp + appId + appInfo.getKey();</span><br><span class="line">        <span class="type">String</span> <span class="variable">signature</span> <span class="operator">=</span> MD5Util.encode(signString);</span><br><span class="line">        log.info(signature);</span><br><span class="line">        Assert.isTrue(signature.equals(sign), <span class="string">&quot;签名错误&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 如果正确生成一个token保存到redis中，如果错误返回错误信息</span></span><br><span class="line">        <span class="type">AccessToken</span> <span class="variable">accessToken</span> <span class="operator">=</span> <span class="built_in">this</span>.saveToken(<span class="number">0</span>, appInfo, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ApiResponse.success(accessToken);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotRepeatSubmit(5000)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;user_token&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResponse&lt;UserInfo&gt; <span class="title function_">userToken</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据用户名查询密码, 并比较密码(密码可以RSA加密一下)</span></span><br><span class="line">        <span class="type">UserInfo</span> <span class="variable">userInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserInfo</span>(username, <span class="string">&quot;81255cb0dca1a5f304328a70ac85dcbd&quot;</span>, <span class="string">&quot;111111&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> password + userInfo.getSalt();</span><br><span class="line">        <span class="type">String</span> <span class="variable">passwordMD5</span> <span class="operator">=</span> MD5Util.encode(pwd);</span><br><span class="line">        Assert.isTrue(passwordMD5.equals(userInfo.getPassword()), <span class="string">&quot;密码错误&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 保存Token</span></span><br><span class="line">        <span class="type">AppInfo</span> <span class="variable">appInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AppInfo</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;12345678954556&quot;</span>);</span><br><span class="line">        <span class="type">AccessToken</span> <span class="variable">accessToken</span> <span class="operator">=</span> <span class="built_in">this</span>.saveToken(<span class="number">1</span>, appInfo, userInfo);</span><br><span class="line">        userInfo.setAccessToken(accessToken);</span><br><span class="line">        <span class="keyword">return</span> ApiResponse.success(userInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AccessToken <span class="title function_">saveToken</span><span class="params">(<span class="type">int</span> tokenType, AppInfo appInfo,  UserInfo userInfo)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// token有效期为2小时</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        calendar.setTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        calendar.add(Calendar.SECOND, <span class="number">7200</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">expireTime</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 保存token</span></span><br><span class="line">        ValueOperations&lt;String, TokenInfo&gt; operations = redisTemplate.opsForValue();</span><br><span class="line">        <span class="type">TokenInfo</span> <span class="variable">tokenInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TokenInfo</span>();</span><br><span class="line">        tokenInfo.setTokenType(tokenType);</span><br><span class="line">        tokenInfo.setAppInfo(appInfo);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tokenType == <span class="number">1</span>) &#123;</span><br><span class="line">            tokenInfo.setUserInfo(userInfo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        operations.set(token, tokenInfo, <span class="number">7200</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="type">AccessToken</span> <span class="variable">accessToken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AccessToken</span>(token, expireTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> accessToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(timestamp);</span><br><span class="line">        <span class="type">String</span> <span class="variable">signString</span> <span class="operator">=</span> timestamp + <span class="string">&quot;1&quot;</span> + <span class="string">&quot;12345678954556&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sign</span> <span class="operator">=</span> MD5Util.encode(signString);</span><br><span class="line">        System.out.println(sign);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line">        signString = <span class="string">&quot;password=123456&amp;username=1&amp;12345678954556&quot;</span> + <span class="string">&quot;ff03e64b-427b-45a7-b78b-47d9e8597d3b1529815393153sdfsdfsfs&quot;</span> + timestamp + <span class="string">&quot;A1scr6&quot;</span>;</span><br><span class="line">        sign = MD5Util.encode(signString);</span><br><span class="line">        System.out.println(sign);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-WebMvcConfiguration"><a href="#4-WebMvcConfiguration" class="headerlink" title="4. WebMvcConfiguration"></a>4. WebMvcConfiguration</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] excludePathPatterns  = &#123;<span class="string">&quot;/api/token/api_token&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TokenInterceptor tokenInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.addInterceptors(registry);</span><br><span class="line">        registry.addInterceptor(tokenInterceptor)</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/api/**&quot;</span>)</span><br><span class="line">                .excludePathPatterns(excludePathPatterns);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-TokenInterceptor"><a href="#5-TokenInterceptor" class="headerlink" title="5. TokenInterceptor"></a>5. TokenInterceptor</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenInterceptor</span> <span class="keyword">extends</span> <span class="title class_">HandlerInterceptorAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 访问的目标方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">timestamp</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;timestamp&quot;</span>);</span><br><span class="line">        <span class="comment">// 随机字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">nonce</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;nonce&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sign</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;sign&quot;</span>);</span><br><span class="line">        Assert.isTrue(!StringUtils.isEmpty(token) &amp;&amp; !StringUtils.isEmpty(timestamp) &amp;&amp; !StringUtils.isEmpty(sign), <span class="string">&quot;参数错误&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取超时时间</span></span><br><span class="line">        <span class="type">NotRepeatSubmit</span> <span class="variable">notRepeatSubmit</span> <span class="operator">=</span> ApiUtil.getNotRepeatSubmit(handler);</span><br><span class="line">        <span class="type">long</span> <span class="variable">expireTime</span> <span class="operator">=</span> notRepeatSubmit == <span class="literal">null</span> ? <span class="number">5</span> * <span class="number">60</span> * <span class="number">1000</span> : notRepeatSubmit.value();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 请求时间间隔</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">reqeustInterval</span> <span class="operator">=</span> System.currentTimeMillis() - Long.valueOf(timestamp);</span><br><span class="line">        Assert.isTrue(reqeustInterval &lt; expireTime, <span class="string">&quot;请求超时，请重新请求&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 校验Token是否存在</span></span><br><span class="line">        ValueOperations&lt;String, TokenInfo&gt; tokenRedis = redisTemplate.opsForValue();</span><br><span class="line">        <span class="type">TokenInfo</span> <span class="variable">tokenInfo</span> <span class="operator">=</span> tokenRedis.get(token);</span><br><span class="line">        Assert.notNull(tokenInfo, <span class="string">&quot;token错误&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 校验签名(将所有的参数加进来，防止别人篡改参数) 所有参数看参数名升续排序拼接成url</span></span><br><span class="line">        <span class="comment">// 请求参数 + token + timestamp + nonce</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">signString</span> <span class="operator">=</span> ApiUtil.concatSignString(request) + tokenInfo.getAppInfo().getKey() + token + timestamp + nonce;</span><br><span class="line">        <span class="type">String</span> <span class="variable">signature</span> <span class="operator">=</span> MD5Util.encode(signString);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> signature.equals(sign);</span><br><span class="line">        Assert.isTrue(flag, <span class="string">&quot;签名错误&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 拒绝重复调用(第一次访问时存储，过期时间和请求超时时间保持一致), 只有标注不允许重复提交注解的才会校验</span></span><br><span class="line">        <span class="keyword">if</span> (notRepeatSubmit != <span class="literal">null</span>) &#123;</span><br><span class="line">            ValueOperations&lt;String, Integer&gt; signRedis = redisTemplate.opsForValue();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> redisTemplate.hasKey(sign);</span><br><span class="line">            Assert.isTrue(!exists, <span class="string">&quot;请勿重复提交&quot;</span>);</span><br><span class="line">            signRedis.set(sign, <span class="number">0</span>, expireTime, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.preHandle(request, response, handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-MD5Util"><a href="#6-MD5Util" class="headerlink" title="6. MD5Util"></a>6. MD5Util</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MD5Util &#123;</span><br><span class="line"></span><br><span class="line">    private static final String hexDigits[] = &#123; &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;,</span><br><span class="line">            &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot; &#125;;</span><br><span class="line"></span><br><span class="line">    private static String byteArrayToHexString(byte b[]) &#123;</span><br><span class="line">        StringBuffer resultSb = new StringBuffer();</span><br><span class="line">        for (int i = 0; i &lt; b.length; i++)</span><br><span class="line">            resultSb.append(byteToHexString(b[i]));</span><br><span class="line"></span><br><span class="line">        return resultSb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static String byteToHexString(byte b) &#123;</span><br><span class="line">        int n = b;</span><br><span class="line">        if (n &lt; 0)</span><br><span class="line">            n += 256;</span><br><span class="line">        int d1 = n / 16;</span><br><span class="line">        int d2 = n % 16;</span><br><span class="line">        return hexDigits[d1] + hexDigits[d2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String encode(String origin) &#123;</span><br><span class="line">        return encode(origin, &quot;UTF-8&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static String encode(String origin, String charsetname) &#123;</span><br><span class="line">        String resultString = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            resultString = new String(origin);</span><br><span class="line">            MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);</span><br><span class="line">            if (charsetname == null || &quot;&quot;.equals(charsetname))</span><br><span class="line">                resultString = byteArrayToHexString(md.digest(resultString</span><br><span class="line">                        .getBytes()));</span><br><span class="line">            else</span><br><span class="line">                resultString = byteArrayToHexString(md.digest(resultString</span><br><span class="line">                        .getBytes(charsetname)));</span><br><span class="line">        &#125; catch (Exception exception) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        return resultString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-NotRepeatSubmit"><a href="#7-NotRepeatSubmit" class="headerlink" title="7. @NotRepeatSubmit"></a>7. @NotRepeatSubmit</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 禁止重复提交</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> NotRepeatSubmit &#123;</span><br><span class="line">    <span class="comment">/** 过期时间，单位毫秒 **/</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">5000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8-AccessToken"><a href="#8-AccessToken" class="headerlink" title="8. AccessToken"></a>8. AccessToken</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccessToken</span> &#123;</span><br><span class="line">    <span class="comment">/** token */</span></span><br><span class="line">    <span class="keyword">private</span> String token;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 失效时间 */</span></span><br><span class="line">    <span class="keyword">private</span> Date expireTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="9-AppInfo"><a href="#9-AppInfo" class="headerlink" title="9. AppInfo"></a>9. AppInfo</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppInfo</span> &#123;</span><br><span class="line">    <span class="comment">/** App id */</span></span><br><span class="line">    <span class="keyword">private</span> String appId;</span><br><span class="line">    <span class="comment">/** API 秘钥 */</span></span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="10-TokenInfo"><a href="#10-TokenInfo" class="headerlink" title="10. TokenInfo"></a>10. TokenInfo</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class TokenInfo &#123;</span><br><span class="line">    /** token类型: api:0 、user:1 */</span><br><span class="line">    private Integer tokenType;</span><br><span class="line"></span><br><span class="line">    /** App 信息 */</span><br><span class="line">    private AppInfo appInfo;</span><br><span class="line"></span><br><span class="line">    /** 用户其他数据 */</span><br><span class="line">    private UserInfo userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="11-UserInfo"><a href="#11-UserInfo" class="headerlink" title="11. UserInfo"></a>11. UserInfo</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class UserInfo &#123;</span><br><span class="line">    /** 用户名 */</span><br><span class="line">    private String username;</span><br><span class="line">    /** 手机号 */</span><br><span class="line">    private String mobile;</span><br><span class="line">    /** 邮箱 */</span><br><span class="line">    private String email;</span><br><span class="line">    /** 密码 */</span><br><span class="line">    private String password;</span><br><span class="line">    /** 盐 */</span><br><span class="line">    private String salt;</span><br><span class="line"></span><br><span class="line">    private AccessToken accessToken;</span><br><span class="line"></span><br><span class="line">    public UserInfo(String username, String password, String salt) &#123;</span><br><span class="line">        this.username = username;</span><br><span class="line">        this.password = password;</span><br><span class="line">        this.salt = salt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="12-ApiCodeEnum"><a href="#12-ApiCodeEnum" class="headerlink" title="12. ApiCodeEnum"></a>12. ApiCodeEnum</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 错误码code可以使用纯数字,使用不同区间标识一类错误，也可以使用纯字符，也可以使用前缀+编号</span><br><span class="line"> *</span><br><span class="line"> * 错误码：ERR + 编号</span><br><span class="line"> *</span><br><span class="line"> * 可以使用日志级别的前缀作为错误类型区分 Info(I) Error(E) Warning(W)</span><br><span class="line"> *</span><br><span class="line"> * 或者以业务模块 + 错误号</span><br><span class="line"> *</span><br><span class="line"> * TODO 错误码设计</span><br><span class="line"> *</span><br><span class="line"> * Alipay 用了两个code，两个msg(https://docs.open.alipay.com/api_1/alipay.trade.pay)</span><br><span class="line"> *</span><br><span class="line"> * @author Mengday Zhang</span><br><span class="line"> * @version 1.0</span><br><span class="line"> * @since 2018/6/22</span><br><span class="line"> */</span><br><span class="line">public enum ApiCodeEnum &#123;</span><br><span class="line">    SUCCESS(&quot;10000&quot;, &quot;success&quot;),</span><br><span class="line">    UNKNOW_ERROR(&quot;ERR0001&quot;,&quot;未知错误&quot;),</span><br><span class="line">    PARAMETER_ERROR(&quot;ERR0002&quot;,&quot;参数错误&quot;),</span><br><span class="line">    TOKEN_EXPIRE(&quot;ERR0003&quot;,&quot;认证过期&quot;),</span><br><span class="line">    REQUEST_TIMEOUT(&quot;ERR0004&quot;,&quot;请求超时&quot;),</span><br><span class="line">    SIGN_ERROR(&quot;ERR0005&quot;,&quot;签名错误&quot;),</span><br><span class="line">    REPEAT_SUBMIT(&quot;ERR0006&quot;,&quot;请不要频繁操作&quot;),</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    /** 代码 */</span><br><span class="line">    private String code;</span><br><span class="line"></span><br><span class="line">    /** 结果 */</span><br><span class="line">    private String msg;</span><br><span class="line"></span><br><span class="line">    ApiCodeEnum(String code, String msg) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">        this.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMsg() &#123;</span><br><span class="line">        return msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="13-ApiResult"><a href="#13-ApiResult" class="headerlink" title="13. ApiResult"></a>13. ApiResult</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">public class ApiResult &#123;</span><br><span class="line"></span><br><span class="line">    /** 代码 */</span><br><span class="line">    private String code;</span><br><span class="line"></span><br><span class="line">    /** 结果 */</span><br><span class="line">    private String msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="14-ApiUtil"><a href="#14-ApiUtil" class="headerlink" title="14. ApiUtil"></a>14. ApiUtil</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ApiUtil &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 按参数名升续拼接参数</span><br><span class="line">     * @param request</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static String concatSignString(HttpServletRequest request) &#123;</span><br><span class="line">        Map&lt;String, String&gt; paramterMap = new HashMap&lt;&gt;();</span><br><span class="line">        request.getParameterMap().forEach((key, value) -&gt; paramterMap.put(key, value[0]));</span><br><span class="line">        // 按照key升续排序，然后拼接参数</span><br><span class="line">        Set&lt;String&gt; keySet = paramterMap.keySet();</span><br><span class="line">        String[] keyArray = keySet.toArray(new String[keySet.size()]);</span><br><span class="line">        Arrays.sort(keyArray);</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        for (String k : keyArray) &#123;</span><br><span class="line">            // 或略掉的字段</span><br><span class="line">            if (k.equals(&quot;sign&quot;)) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (paramterMap.get(k).trim().length() &gt; 0) &#123;</span><br><span class="line">                // 参数值为空，则不参与签名</span><br><span class="line">                sb.append(k).append(&quot;=&quot;).append(paramterMap.get(k).trim()).append(&quot;&amp;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String concatSignString(Map&lt;String, String&gt; map) &#123;</span><br><span class="line">        Map&lt;String, String&gt; paramterMap = new HashMap&lt;&gt;();</span><br><span class="line">        map.forEach((key, value) -&gt; paramterMap.put(key, value));</span><br><span class="line">        // 按照key升续排序，然后拼接参数</span><br><span class="line">        Set&lt;String&gt; keySet = paramterMap.keySet();</span><br><span class="line">        String[] keyArray = keySet.toArray(new String[keySet.size()]);</span><br><span class="line">        Arrays.sort(keyArray);</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        for (String k : keyArray) &#123;</span><br><span class="line">            if (paramterMap.get(k).trim().length() &gt; 0) &#123;</span><br><span class="line">                // 参数值为空，则不参与签名</span><br><span class="line">                sb.append(k).append(&quot;=&quot;).append(paramterMap.get(k).trim()).append(&quot;&amp;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取方法上的@NotRepeatSubmit注解</span><br><span class="line">     * @param handler</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static NotRepeatSubmit getNotRepeatSubmit(Object handler) &#123;</span><br><span class="line">        if (handler instanceof HandlerMethod) &#123;</span><br><span class="line">            HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br><span class="line">            Method method = handlerMethod.getMethod();</span><br><span class="line">            NotRepeatSubmit annotation = method.getAnnotation(NotRepeatSubmit.class);</span><br><span class="line"></span><br><span class="line">            return annotation;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="15-ApiResponse"><a href="#15-ApiResponse" class="headerlink" title="15. ApiResponse"></a>15. ApiResponse</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">@Slf4j</span><br><span class="line">public class ApiResponse&lt;T&gt; &#123;</span><br><span class="line">    /** 结果 */</span><br><span class="line">    private ApiResult result;</span><br><span class="line"></span><br><span class="line">    /** 数据 */</span><br><span class="line">    private T data;</span><br><span class="line"></span><br><span class="line">    /** 签名 */</span><br><span class="line">    private String sign;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; ApiResponse success(T data) &#123;</span><br><span class="line">        return response(ApiCodeEnum.SUCCESS.getCode(), ApiCodeEnum.SUCCESS.getMsg(), data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static ApiResponse error(String code, String msg) &#123;</span><br><span class="line">        return response(code, msg, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; ApiResponse response(String code, String msg, T data) &#123;</span><br><span class="line">        ApiResult result = new ApiResult(code, msg);</span><br><span class="line">        ApiResponse response = new ApiResponse();</span><br><span class="line">        response.setResult(result);</span><br><span class="line">        response.setData(data);</span><br><span class="line"></span><br><span class="line">        String sign = signData(data);</span><br><span class="line">        response.setSign(sign);</span><br><span class="line"></span><br><span class="line">        return response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static &lt;T&gt; String signData(T data) &#123;</span><br><span class="line">        // TODO 查询key</span><br><span class="line">        String key = &quot;12345678954556&quot;;</span><br><span class="line">        Map&lt;String, String&gt; responseMap = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            responseMap = getFields(data);</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        String urlComponent = ApiUtil.concatSignString(responseMap);</span><br><span class="line">        String signature = urlComponent + &quot;key=&quot; + key;</span><br><span class="line">        String sign = MD5Util.encode(signature);</span><br><span class="line"></span><br><span class="line">        return sign;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param data 反射的对象,获取对象的字段名和值</span><br><span class="line">     * @throws IllegalArgumentException</span><br><span class="line">     * @throws IllegalAccessException</span><br><span class="line">     */</span><br><span class="line">    public static Map&lt;String, String&gt; getFields(Object data) throws IllegalAccessException, IllegalArgumentException &#123;</span><br><span class="line">        if (data == null) return null;</span><br><span class="line">        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        Field[] fields = data.getClass().getDeclaredFields();</span><br><span class="line">        for (int i = 0; i &lt; fields.length; i++) &#123;</span><br><span class="line">            Field field = fields[i];</span><br><span class="line">            field.setAccessible(true);</span><br><span class="line"></span><br><span class="line">            String name = field.getName();</span><br><span class="line">            Object value = field.get(data);</span><br><span class="line">            if (field.get(data) != null) &#123;</span><br><span class="line">                map.put(name, value.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="七-ThreadLocal"><a href="#七-ThreadLocal" class="headerlink" title="七: ThreadLocal"></a>七: ThreadLocal</h1><p>ThreadLocal是线程内的全局上下文。就是在单个线程中，方法之间共享的内存，每个方法都可以从该上下文中获取值和修改值。</p>
<h1 id="实际案例："><a href="#实际案例：" class="headerlink" title="实际案例："></a>实际案例：</h1><p>在调用api时都会传一个token参数，通常会写一个拦截器来校验token是否合法，我们可以通过token找到对应的用户信息(User)，如果token合法，然后将用户信息存储到ThreadLocal中，这样无论是在controller、service、dao的哪一层都能访问到该用户的信息。作用类似于Web中的request作用域。</p>
<p>传统方式我们要在方法中访问某个变量，可以通过传参的形式往方法中传参，如果多个方法都要使用那么每个方法都要传参；如果使用ThreadLocal所有方法就不需要传该参数了，每个方法都可以通过ThreadLocal来访问该值。</p>
<ul>
<li>ThreadLocalUtil.set(“key”, value); 保存值</li>
<li>T value &#x3D; ThreadLocalUtil.get(“key”); 获取值</li>
</ul>
<p>ThreadLocalUtil</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ThreadLocalUtil&lt;T&gt; &#123;</span><br><span class="line">    private static final ThreadLocal&lt;Map&lt;String, Object&gt;&gt; threadLocal = new ThreadLocal() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected Map&lt;String, Object&gt; initialValue() &#123;</span><br><span class="line">            return new HashMap&lt;&gt;(4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static Map&lt;String, Object&gt; getThreadLocal()&#123;</span><br><span class="line">        return threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; T get(String key) &#123;</span><br><span class="line">        Map map = (Map)threadLocal.get();</span><br><span class="line">        return (T)map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; T get(String key,T defaultValue) &#123;</span><br><span class="line">        Map map = (Map)threadLocal.get();</span><br><span class="line">        return (T)map.get(key) == null ? defaultValue : (T)map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void set(String key, Object value) &#123;</span><br><span class="line">        Map map = (Map)threadLocal.get();</span><br><span class="line">        map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void set(Map&lt;String, Object&gt; keyValueMap) &#123;</span><br><span class="line">        Map map = (Map)threadLocal.get();</span><br><span class="line">        map.putAll(keyValueMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void remove() &#123;</span><br><span class="line">        threadLocal.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; Map&lt;String,T&gt; fetchVarsByPrefix(String prefix) &#123;</span><br><span class="line">        Map&lt;String,T&gt; vars = new HashMap&lt;&gt;();</span><br><span class="line">        if( prefix == null )&#123;</span><br><span class="line">            return vars;</span><br><span class="line">        &#125;</span><br><span class="line">        Map map = (Map)threadLocal.get();</span><br><span class="line">        Set&lt;Map.Entry&gt; set = map.entrySet();</span><br><span class="line"></span><br><span class="line">        for( Map.Entry entry : set)&#123;</span><br><span class="line">            Object key = entry.getKey();</span><br><span class="line">            if( key instanceof String )&#123;</span><br><span class="line">                if( ((String) key).startsWith(prefix) )&#123;</span><br><span class="line">                    vars.put((String)key,(T)entry.getValue());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return vars;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; T remove(String key) &#123;</span><br><span class="line">        Map map = (Map)threadLocal.get();</span><br><span class="line">        return (T)map.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void clear(String prefix) &#123;</span><br><span class="line">        if( prefix == null )&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Map map = (Map)threadLocal.get();</span><br><span class="line">        Set&lt;Map.Entry&gt; set = map.entrySet();</span><br><span class="line">        List&lt;String&gt; removeKeys = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for( Map.Entry entry : set )&#123;</span><br><span class="line">            Object key = entry.getKey();</span><br><span class="line">            if( key instanceof String )&#123;</span><br><span class="line">                if( ((String) key).startsWith(prefix) )&#123;</span><br><span class="line">                    removeKeys.add((String)key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for( String key : removeKeys )&#123;</span><br><span class="line">            map.remove(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>api</tag>
        <tag>token</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA全部快捷键</title>
    <url>/2022/07/11/IDEA%E5%85%A8%E9%83%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h4 id="Idea常用快捷键"><a href="#Idea常用快捷键" class="headerlink" title="Idea常用快捷键"></a>Idea常用快捷键</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Tab</span>，代码标签输入完成后，按 <span class="title class_">Tab</span>，生成代码</span><br><span class="line"><span class="title class_">Ctrl</span>+E，最近的文件</span><br><span class="line"><span class="title class_">Ctrl</span>+X，删除行</span><br><span class="line"><span class="title class_">Ctrl</span>+D，复制行</span><br><span class="line"><span class="title class_">Alt</span>+<span class="number">1</span>，快速打开或隐藏工程面板</span><br><span class="line">ctrl+alt+t 快速代码块（<span class="keyword">try</span> <span class="keyword">catch</span>等）</span><br><span class="line">ctrl+<span class="regexp">/ 快速注释(单/</span>多行)</span><br><span class="line">ctrl+shift+/ 快速注释</span><br><span class="line"><span class="title class_">Alt</span>+<span class="title class_">Shift</span>+<span class="title class_">Up</span>/<span class="title class_">Down</span>，上/下移一行</span><br><span class="line">alt+shift+m 将选中的代码抽取出来 </span><br></pre></td></tr></table></figure>

<h4 id="Idea快捷键-全"><a href="#Idea快捷键-全" class="headerlink" title="Idea快捷键(全)"></a>Idea快捷键(全)</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Shift</span> + <span class="title class_">Enter</span>，语句完成</span><br><span class="line">“！”，否定完成，输入表达式时按 “！”键</span><br><span class="line"><span class="title class_">Ctrl</span>+E，最近的文件</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Shift</span>+E，最近更改的文件</span><br><span class="line"><span class="title class_">Shift</span>+<span class="title class_">Click</span>，可以关闭文件</span><br><span class="line"><span class="title class_">Ctrl</span>+[ <span class="variable constant_">OR</span> ]，可以跑到大括号的开头与结尾</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="variable constant_">F12</span>，可以显示当前文件的结构</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="variable constant_">F7</span>，可以查询当前元素在当前文件中的引用，然后按 <span class="variable constant_">F3</span> 可以选择</span><br><span class="line"><span class="title class_">Ctrl</span>+N，可以快速打开类</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Shift</span>+N，可以快速打开文件</span><br><span class="line"><span class="title class_">Alt</span>+Q，可以看到当前方法的声明</span><br><span class="line"><span class="title class_">Ctrl</span>+P，可以显示参数信息</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Shift</span>+<span class="title class_">Insert</span>，可以选择剪贴板内容并插入</span><br><span class="line"><span class="title class_">Alt</span>+<span class="title class_">Insert</span>，可以生成构造器/<span class="title class_">Getter</span>/<span class="title class_">Setter</span>等</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Alt</span>+V，可以引入变量。例如：<span class="keyword">new</span> <span class="title class_">String</span>(); 自动导入变量定义</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Alt</span>+T，可以把代码包在一个块内，例如：<span class="keyword">try</span>/<span class="keyword">catch</span></span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Enter</span>，导入包，自动修正</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Alt</span>+L，格式化代码</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Alt</span>+I，将选中的代码进行自动缩进编排，这个功能在编辑 <span class="variable constant_">JSP</span> 文件时也可以工作</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Alt</span>+O，优化导入的类和包</span><br><span class="line"><span class="title class_">Ctrl</span>+R，替换文本</span><br><span class="line"><span class="title class_">Ctrl</span>+F，查找文本</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Shift</span>+<span class="title class_">Space</span>，自动补全代码</span><br><span class="line"><span class="title class_">Ctrl</span>+空格，代码提示（与系统输入法快捷键冲突）</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Shift</span>+<span class="title class_">Alt</span>+N，查找类中的方法或变量</span><br><span class="line"><span class="title class_">Alt</span>+<span class="title class_">Shift</span>+C，最近的更改</span><br><span class="line"><span class="title class_">Alt</span>+<span class="title class_">Shift</span>+<span class="title class_">Up</span>/<span class="title class_">Down</span>，上/下移一行</span><br><span class="line"><span class="title class_">Shift</span>+<span class="variable constant_">F6</span>，重构 – 重命名</span><br><span class="line"><span class="title class_">Ctrl</span>+X，删除行</span><br><span class="line"><span class="title class_">Ctrl</span>+D，复制行</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="regexp">/或Ctrl+Shift+/</span>，注释（<span class="comment">//或者/**/）</span></span><br><span class="line"><span class="title class_">Ctrl</span>+J，自动代码（例如：serr）</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Alt</span>+J，用动态模板环绕</span><br><span class="line"><span class="title class_">Ctrl</span>+H，显示类结构图（类的继承层次）</span><br><span class="line"><span class="title class_">Ctrl</span>+Q，显示注释文档</span><br><span class="line"><span class="title class_">Alt</span>+<span class="variable constant_">F1</span>，查找代码所在位置</span><br><span class="line"><span class="title class_">Alt</span>+<span class="number">1</span>，快速打开或隐藏工程面板</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Alt</span>+left/right，返回至上次浏览的位置</span><br><span class="line"><span class="title class_">Alt</span>+left/right，切换代码视图</span><br><span class="line"><span class="title class_">Alt</span>+<span class="title class_">Up</span>/<span class="title class_">Down</span>，在方法间快速移动定位</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Shift</span>+<span class="title class_">Up</span>/<span class="title class_">Down</span>，向上/下移动语句</span><br><span class="line"><span class="variable constant_">F2</span> 或 <span class="title class_">Shift</span>+<span class="variable constant_">F2</span>，高亮错误或警告快速定位</span><br><span class="line"><span class="title class_">Tab</span>，代码标签输入完成后，按 <span class="title class_">Tab</span>，生成代码</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Shift</span>+<span class="variable constant_">F7</span>，高亮显示所有该文本，按 <span class="title class_">Esc</span> 高亮消失</span><br><span class="line"><span class="title class_">Alt</span>+<span class="variable constant_">F3</span>，逐个往下查找相同文本，并高亮显示</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Up</span>/<span class="title class_">Down</span>，光标中转到第一行或最后一行下</span><br><span class="line"><span class="title class_">Ctrl</span>+B/<span class="title class_">Ctrl</span>+<span class="title class_">Click</span>，快速打开光标处的类或方法（跳转到定义处）</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Alt</span>+B，跳转到方法实现处</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Shift</span>+<span class="title class_">Backspace</span>，跳转到上次编辑的地方</span><br><span class="line"><span class="title class_">Ctrl</span>+O，重写方法</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Alt</span>+<span class="title class_">Space</span>，类名自动完成</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Alt</span>+<span class="title class_">Up</span>/<span class="title class_">Down</span>，快速跳转搜索结果</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Shift</span>+J，整合两行</span><br><span class="line"><span class="title class_">Alt</span>+<span class="variable constant_">F8</span>，计算变量值</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Shift</span>+V，可以将最近使用的剪贴板内容选择插入到文本</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Alt</span>+<span class="title class_">Shift</span>+V，简单粘贴</span><br><span class="line"><span class="title class_">Shift</span>+<span class="title class_">Esc</span>，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口</span><br><span class="line"><span class="variable constant_">F12</span>，把焦点从编辑器移到最近使用的工具窗口</span><br><span class="line"><span class="title class_">Shift</span>+<span class="variable constant_">F1</span>，要打开编辑器光标字符处使用的类或者方法 <span class="title class_">Java</span> 文档的浏览器</span><br><span class="line"><span class="title class_">Ctrl</span>+W，可以选择单词继而语句继而行继而函数</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Shift</span>+W，取消选择光标所在词</span><br><span class="line"><span class="title class_">Alt</span>+<span class="variable constant_">F7</span>，查找整个工程中使用地某一个类、方法或者变量的位置</span><br><span class="line"><span class="title class_">Ctrl</span>+I，实现方法</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Shift</span>+U，大小写转化</span><br><span class="line"><span class="title class_">Ctrl</span>+Y，删除当前行</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="title class_">Shift</span>+<span class="title class_">Enter</span>，向下插入新行</span><br><span class="line">psvm/sout，main/<span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(); <span class="title class_">Ctrl</span>+J，查看更多</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Shift</span>+F，全局查找</span><br><span class="line"><span class="title class_">Ctrl</span>+F，查找/<span class="title class_">Shift</span>+<span class="variable constant_">F3</span>，向上查找/<span class="variable constant_">F3</span>，向下查找</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Shift</span>+S，高级搜索</span><br><span class="line"><span class="title class_">Ctrl</span>+U，转到父类</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Alt</span>+S，打开设置对话框</span><br><span class="line"><span class="title class_">Alt</span>+<span class="title class_">Shift</span>+<span class="title class_">Inert</span>，开启/关闭列选择模式</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Alt</span>+<span class="title class_">Shift</span>+S，打开当前项目/模块属性</span><br><span class="line"><span class="title class_">Ctrl</span>+G，定位行</span><br><span class="line"><span class="title class_">Alt</span>+<span class="title class_">Home</span>，跳转到导航栏</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Enter</span>，上插一行</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Backspace</span>，按单词删除</span><br><span class="line"><span class="title class_">Ctrl</span>+”+/-”，当前方法展开、折叠</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Shift</span>+”+/-”，全部展开、折叠</span><br><span class="line">【调试部分、编译】</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="variable constant_">F2</span>，停止</span><br><span class="line"><span class="title class_">Alt</span>+<span class="title class_">Shift</span>+<span class="variable constant_">F9</span>，选择 <span class="title class_">Debug</span></span><br><span class="line"><span class="title class_">Alt</span>+<span class="title class_">Shift</span>+<span class="variable constant_">F10</span>，选择 <span class="title class_">Run</span></span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Shift</span>+<span class="variable constant_">F9</span>，编译</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Shift</span>+<span class="variable constant_">F10</span>，运行</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Shift</span>+<span class="variable constant_">F8</span>，查看断点</span><br><span class="line"><span class="variable constant_">F8</span>，步过</span><br><span class="line"><span class="variable constant_">F7</span>，步入</span><br><span class="line"><span class="title class_">Shift</span>+<span class="variable constant_">F7</span>，智能步入</span><br><span class="line"><span class="title class_">Shift</span>+<span class="variable constant_">F8</span>，步出</span><br><span class="line"><span class="title class_">Alt</span>+<span class="title class_">Shift</span>+<span class="variable constant_">F8</span>，强制步过</span><br><span class="line"><span class="title class_">Alt</span>+<span class="title class_">Shift</span>+<span class="variable constant_">F7</span>，强制步入</span><br><span class="line"><span class="title class_">Alt</span>+<span class="variable constant_">F9</span>，运行至光标处</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Alt</span>+<span class="variable constant_">F9</span>，强制运行至光标处</span><br><span class="line"><span class="variable constant_">F9</span>，恢复程序</span><br><span class="line"><span class="title class_">Alt</span>+<span class="variable constant_">F10</span>，定位到断点</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="variable constant_">F8</span>，切换行断点</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="variable constant_">F9</span>，生成项目</span><br><span class="line"><span class="title class_">Alt</span>+<span class="number">1</span>，项目</span><br><span class="line"><span class="title class_">Alt</span>+<span class="number">2</span>，收藏</span><br><span class="line"><span class="title class_">Alt</span>+<span class="number">6</span>，<span class="variable constant_">TODO</span></span><br><span class="line"><span class="title class_">Alt</span>+<span class="number">7</span>，结构</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Shift</span>+C，复制路径</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Alt</span>+<span class="title class_">Shift</span>+C，复制引用，必须选择类名</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Alt</span>+Y，同步</span><br><span class="line"><span class="title class_">Ctrl</span>+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单）</span><br><span class="line"><span class="title class_">Shift</span>+<span class="variable constant_">F12</span>，还原默认布局</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Shift</span>+<span class="variable constant_">F12</span>，隐藏/恢复所有窗口</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="variable constant_">F4</span>，关闭</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Shift</span>+<span class="variable constant_">F4</span>，关闭活动选项卡</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Tab</span>，转到下一个拆分器</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Shift</span>+<span class="title class_">Tab</span>，转到上一个拆分器</span><br><span class="line">【重构】</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Alt</span>+<span class="title class_">Shift</span>+T，弹出重构菜单</span><br><span class="line"><span class="title class_">Shift</span>+<span class="variable constant_">F6</span>，重命名</span><br><span class="line"><span class="variable constant_">F6</span>，移动</span><br><span class="line"><span class="variable constant_">F5</span>，复制</span><br><span class="line"><span class="title class_">Alt</span>+<span class="title class_">Delete</span>，安全删除</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Alt</span>+N，内联</span><br><span class="line">【查找】</span><br><span class="line"><span class="title class_">Ctrl</span>+F，查找</span><br><span class="line"><span class="title class_">Ctrl</span>+R，替换</span><br><span class="line"><span class="variable constant_">F3</span>，查找下一个</span><br><span class="line"><span class="title class_">Shift</span>+<span class="variable constant_">F3</span>，查找上一个</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Shift</span>+F，在路径中查找</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Shift</span>+R，在路径中替换</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Shift</span>+S，搜索结构</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Shift</span>+M，替换结构</span><br><span class="line"><span class="title class_">Alt</span>+<span class="variable constant_">F7</span>，查找用法</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Alt</span>+<span class="variable constant_">F7</span>，显示用法</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="variable constant_">F7</span>，在文件中查找用法</span><br><span class="line"><span class="title class_">Ctrl</span>+<span class="title class_">Shift</span>+<span class="variable constant_">F7</span>，在文件中高亮显示用法</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程之Runnable、Callable和Future的详解和区别</title>
    <url>/2022/10/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BRunnable%E3%80%81Callable%E5%92%8CFuture%E7%9A%84%E8%AF%A6%E8%A7%A3%E5%92%8C%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="Runnable、Callable和Future的详解和区别"><a href="#Runnable、Callable和Future的详解和区别" class="headerlink" title="Runnable、Callable和Future的详解和区别"></a>Runnable、Callable和Future的详解和区别</h1><blockquote>
<p>在程序运行中，执行的时间和用户的体验是密切相关的，人们不希望用一个经常卡顿的网站或应用，这时候<a href="https://so.csdn.net/so/search?q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&spm=1001.2101.3001.7020">多线程</a>能给程序带来质的提升。</p>
</blockquote>
<h2 id="一、Runnable"><a href="#一、Runnable" class="headerlink" title="一、Runnable"></a>一、Runnable</h2><p><strong>简介</strong><br>Runnable接口只有一个抽象的run()方法，此方法是在Thread.start()的时候由<a href="https://so.csdn.net/so/search?q=JVM&spm=1001.2101.3001.7020">JVM</a>调用run方法，创建一个线程，并调用run方法。<br><strong>例子</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread1&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;处理完成&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;thread2&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable).start();</span><br><span class="line">        System.out.println(<span class="string">&quot;thread3&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<blockquote>
<p>thread2main<br>thread3main<br>thread1Thread-0<br>处理完成</p>
</blockquote>
<p><strong>结论</strong><br>主线程不会等待run方法执行完成，而是直接执行完成。</p>
<h2 id="二、Callable和Future"><a href="#二、Callable和Future" class="headerlink" title="二、Callable和Future"></a>二、Callable和Future</h2><p><strong>简介</strong><br>Callable和Future，它俩很有意思的，一个产生结果，一个拿到结果。<br>Callable接口类似于Runnable，从名字就可以看出来了，但是Runnable不会返回结果，并且无法抛出返回结果的异常，而Callable功能更强大一些，被线程执行后，可以返回值，这个返回值可以被Future拿到，也就是说，Future可以拿到异步执行任务的返回值。<br><strong>例子</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Callable&lt;Integer&gt; callable2 = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread1&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">return</span>  <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(callable2);</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread2&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread2&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<blockquote>
<p>Thread2main<br>Thread1Thread-0<br>17<br>Thread2main</p>
</blockquote>
<p><strong>结论</strong><br>调用futureTask的get方法会让主线程等待子线程拿到返回值再去执行下一步。但是一般不会立刻调用FutureTask的get方法，而是主线程处理其他操作，需要用到返回值再去调用。</p>
<p><strong>注意</strong><br>到这里可能有人会说了，调用FutureTask的get方法会让主线程等待，那不是还不如Runnable接口好？</p>
<p>其实这里只是夸张，把子线程计算时间设置大了点。</p>
<p>假设有一个很耗时的返回值需要计算，并且这个返回值不是立刻需要的话，那么就可以使用这个组合，用另一个线程去计算返回值，而当前线程在使用这个返回值之前可以做其它的操作，等到需要这个返回值时，再通过FutureTask的get方法得到。</p>
<h2 id="三、实战：Spring整合线程池，给Callable传参，并获取返回值"><a href="#三、实战：Spring整合线程池，给Callable传参，并获取返回值" class="headerlink" title="三、实战：Spring整合线程池，给Callable传参，并获取返回值"></a>三、实战：Spring整合线程池，给Callable传参，并获取返回值</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Resource(name = &quot;taskExecutor&quot;)</span></span><br><span class="line">	Executor taskExecutor;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">		test();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">		List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		List&lt;Future&lt;String&gt;&gt; results = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line">		list.stream().forEach(item-&gt;&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;主线程参数：&quot;</span> + item);</span><br><span class="line">			<span class="type">ThreadPoolTaskExecutor</span> <span class="variable">threadPoolTaskExecutor</span> <span class="operator">=</span>(ThreadPoolTaskExecutor) taskExecutor;</span><br><span class="line">			<span class="comment">//submit的时候，callable内部的call方法已经在开始计算了。</span></span><br><span class="line">			results.add(threadPoolTaskExecutor.submit(<span class="keyword">new</span> <span class="title class_">ApplicationTests</span>.CallableTest(item)));</span><br><span class="line">		&#125;);</span><br><span class="line">		System.out.println(<span class="string">&quot;主线程执行其他任务。。。花费3秒&quot;</span>);</span><br><span class="line">		Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;主线程执行其他任务完毕。。。开始使用返回值&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">CallableTest</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">		<span class="keyword">private</span> String stringArg;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">CallableTest</span><span class="params">(String item)</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;【主线程给Callable接口的call方法传参】：&quot;</span>+item+<span class="string">&quot;，当前线程：&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">			<span class="built_in">this</span>.stringArg = item;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">returnStr</span> <span class="operator">=</span> <span class="string">&quot;Hello: &quot;</span>+stringArg;</span><br><span class="line">			System.out.println(<span class="string">&quot;【Callable接口的call，返回值】&quot;</span>+returnStr+<span class="string">&quot;当前线程：&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">			<span class="keyword">return</span> returnStr;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<blockquote>
<p>主线程参数：aaa<br>【主线程给Callable接口的call方法传参】：aaa，当前线程：main<br>主线程参数：bbb<br>【主线程给Callable接口的call方法传参】：bbb，当前线程：main<br>主线程参数：ccc<br>【主线程给Callable接口的call方法传参】：ccc，当前线程：main<br>主线程参数：ddd<br>【主线程给Callable接口的call方法传参】：ddd，当前线程：main</p>
<p>主线程执行其他任务。。。花费3秒<br>【Callable接口的call，返回值】Hello: aaa当前线程：Executor-1<br>【Callable接口的call，返回值】Hello: bbb当前线程：Executor-1<br>【Callable接口的call，返回值】Hello: ccc当前线程：Executor-1<br>【Callable接口的call，返回值】Hello: ddd当前线程：Executor-1<br>主线程执行其他任务完毕。。。开始使用返回值</p>
</blockquote>
<p><strong>结论</strong><br>子线程的运行并不会被主线程阻塞</p>
<p>假设有一个很耗时的返回值需要计算，并且这个返回值不是立刻需要的话，那么就可以使用这个组合，用另一个线程去计算返回值，而当前线程在使用这个返回值之前可以做其它的操作，等到需要这个返回值时，再使用它。</p>
<p><strong>注意</strong><br>如果子线程Callable接口中的call方法执行时间比主线程长，如果主线程要调用Future的get方法获取返回值，那么主线程会等待子线程计算出值。</p>
<h2 id="四、线程池配置"><a href="#四、线程池配置" class="headerlink" title="四、线程池配置"></a>四、线程池配置</h2><p><strong>1、application.properties</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#线程池配置</span></span><br><span class="line"><span class="attr">threadpool.corePoolSize</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">threadpool.keepAliveSeconds</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">threadpool.maxPoolSize</span>=<span class="string">30</span></span><br><span class="line"><span class="attr">threadpool.queueCapacity</span>=<span class="string">2000</span></span><br></pre></td></tr></table></figure>

<p><strong>2、java配置代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncConfiguration</span> <span class="keyword">implements</span> <span class="title class_">AsyncConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(AsyncConfiguration.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;threadpool.corePoolSize&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> corePoolSize;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;threadpool.keepAliveSeconds&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> keepAliveSeconds;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;threadpool.maxPoolSize&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxPoolSize;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;threadpool.queueCapacity&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> queueCapacity;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;taskExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">getAsyncExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        System.setProperty(<span class="string">&quot;rocketmq.client.log.loadconfig&quot;</span>,<span class="string">&quot;false&quot;</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;Creating Async Task Executor&quot;</span>);</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        executor.setMaxPoolSize(corePoolSize);</span><br><span class="line">        executor.setKeepAliveSeconds(keepAliveSeconds);</span><br><span class="line">        executor.setKeepAliveSeconds(maxPoolSize);</span><br><span class="line">        executor.setQueueCapacity(queueCapacity);</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;Executor-&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>  executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AsyncUncaughtExceptionHandler <span class="title function_">getAsyncUncaughtExceptionHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleAsyncUncaughtExceptionHandler</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>openssl命令详解</title>
    <url>/2022/05/26/openssl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>OpenSSL是一个安全套接字层密码库，其包括常用的密码算法、常用的密钥生成和证书封装管理功能及SSL协议，并提供了丰富的应用程序以供测试。<br> OpenSSL是一个开源的项目，其由三个部分组成：</p>
<ol>
<li><p>openssl命令行工具；</p>
</li>
<li><p>libencrypt加密算法库；</p>
</li>
<li><p>libssl加密模块应用库</p>
</li>
</ol>
<p>这里主要学习下openssl命令工具的用法，openssl命令工具有两种运行模式：<strong>交换模式</strong>和<strong>批处理模式</strong>。直接输入openssl回车即可进入交互模式，而输入带命令选项的openssl命令则进行批处理模式。</p>
<h4 id="1、对称加密算法的应用"><a href="#1、对称加密算法的应用" class="headerlink" title="1、对称加密算法的应用"></a>1、对称加密算法的应用</h4><p>利用OpenSSL作对称加密需要使用其子命令enc，其用法为：</p>
<blockquote>
<p>openssl enc -ciphername [-in filename] [-out filename] [-pass arg] [-e] [-d] [-a&#x2F;-base64] [-A] [-k password] [-kfile filename] [-K key] [-iv IV] [-S salt] [-salt] [-nosalt] [-z] [-md] [-p] [-P] [-bufsize number] [-nopad] [-debug] [-none] [-engine id]</p>
</blockquote>
<p>其中常用的选项为：</p>
<blockquote>
<p>-e：加密；<br> -d：解密；<br> -ciphername：ciphername为相应的对称加密算命名字，如-des3、-ase128、-cast、-blowfish等等。<br> -a&#x2F;-base64：使用base-64位编码格式；<br> -salt：自动插入一个随机数作为文件内容加密，默认选项；<br> -in FILENAME：指定要加密的文件的存放路径；<br> -out FILENAME：指定加密后的文件的存放路径；</p>
</blockquote>
<p><strong>使用案例</strong>：</p>
<ul>
<li>加密字符串</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">[root<span class="variable">@localhost</span> ~]<span class="comment"># echo &quot;hello,world&quot; | openssl enc -aes128 -e -a -salt</span></span><br><span class="line">enter aes-<span class="number">128</span>-cbc encryption <span class="symbol">password:</span></span><br><span class="line">Verifying - enter aes-<span class="number">128</span>-cbc encryption <span class="symbol">password:</span></span><br><span class="line">U2FsdGVkX1/<span class="variable constant_">LT</span>+Ri9pzjjS0FIGXJLNRc8ljvZJ3hf0M=</span><br></pre></td></tr></table></figure>

<ul>
<li>加解密文件</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">[root<span class="variable">@localhost</span> ~]<span class="comment"># openssl enc -des3 -e -a -in /etc/fstab -out /tmp/fstab</span></span><br><span class="line">enter des-ede3-cbc encryption <span class="symbol">password:</span></span><br><span class="line">Verifying - enter des-ede3-cbc encryption <span class="symbol">password:</span></span><br><span class="line"></span><br><span class="line">[root<span class="variable">@localhost</span> ~]<span class="comment"># cat /tmp/fstab </span></span><br><span class="line">U2FsdGVkX1/pdsq5HUjsP5Kpqr378qnZSmH1j9a4KdasuG+6Jy+Mh0cRYA5IUuJ4</span><br><span class="line">732mG1td6x2jvLq0JNpT+WcTFXoH30x1o6KDN6Kwyc26+uTjYb+cwf9ZhZWoEi4c</span><br><span class="line">5Zh1h8S4PwKA9m/ebJAh97RSLuVWqPOsZDJ9w/zE3X0iKnb8nVNEkApB6OYjkV4s</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">[root<span class="variable">@localhost</span> ~]<span class="comment"># openssl enc -d -des3 -a -salt -in /tmp/fstab </span></span><br><span class="line">enter des-ede3-cbc decryption <span class="symbol">password:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># /etc/fstab</span></span><br><span class="line"><span class="comment"># Created by anaconda on Sun Nov 19 02:26:36 2017</span></span><br><span class="line">....</span><br><span class="line">devpts                  /dev/pts                devpts  gid=<span class="number">5</span>,mode=<span class="number">620</span>  <span class="number">0</span> <span class="number">0</span></span><br><span class="line">sysfs                   /sys                    sysfs   defaults        <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="built_in">proc</span>                    /<span class="built_in">proc</span>                   <span class="built_in">proc</span>    defaults        <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="2、单向加密"><a href="#2、单向加密" class="headerlink" title="2、单向加密"></a>2、单向加密</h4><p>OpenSSL单向加密的子命令为dgst，其语法如下：</p>
<blockquote>
<p>openssl dgst [-md5|-md4|-md2|-sha1|-sha|-mdc2|-ripemd160|-dss1] [-c] [-d] [-hex] [-binary] [-out filename] [-sign filename] [-keyform arg] [-passin arg] [-verify filename] [-prverify filename] [-signature filename] [-hmac key] [file…]</p>
</blockquote>
<p>其常用的选项为：</p>
<blockquote>
<p>[-md5|-md4|-md2|-sha1|-sha|-mdc2|-ripemd160|-dss1]：指定一种单向加密算法；<br> -out FILENAME：将加密的内容保存到指定的文件中；</p>
</blockquote>
<p>单向加密除了 openssl dgst 工具还有： md5sum，sha1sum，sha224sum，sha256sum ，sha384sum，sha512sum</p>
<p><strong>使用案例</strong>：</p>
<ul>
<li>生成指定文件的特征码</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">[root<span class="variable">@localhost</span> ~]<span class="comment"># openssl dgst -md5 /tmp/fstab </span></span><br><span class="line"><span class="variable constant_">MD5</span>(<span class="regexp">/tmp/fstab</span>)= ef7b65e9d3200487dc06427934ce5c2d</span><br><span class="line"></span><br><span class="line">[root<span class="variable">@localhost</span> ~]<span class="comment"># md5sum /tmp/fstab </span></span><br><span class="line">ef7b65e9d3200487dc06427934ce5c2d  /tmp/fstab</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">root@localhost ~</span>]<span class="meta"># echo hello,world | md5sum</span></span><br><span class="line"><span class="number">757228086</span>dc1e621e37bed30e0b73e17  -</span><br><span class="line"></span><br><span class="line">[<span class="meta">root@localhost ~</span>]<span class="meta"># echo hello,world | openssl dgst -md5</span></span><br><span class="line">(stdin)= <span class="number">757228086</span>dc1e621e37bed30e0b73e1</span><br></pre></td></tr></table></figure>

<h4 id="3、加密密码"><a href="#3、加密密码" class="headerlink" title="3、加密密码"></a>3、加密密码</h4><p>OpenSSL还支持生成密码的hash离散值，其子命令为passwd，语法如下：</p>
<blockquote>
<p>openssl passwd [-crypt] [-1] [-apr1] [-salt string] [-in file] [-stdin] [-noverify] [-quiet] [-table] {password}</p>
</blockquote>
<p>常用选项为：</p>
<blockquote>
<p>-salt STRING：添加随机数；<br> -in FILE：对输入的文件内容进行加密；<br> -stdin：对标准输入的内容进行加密；</p>
</blockquote>
<p><strong>使用案例</strong>：</p>
<ul>
<li>生成密码的hash值</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">[root<span class="variable">@localhost</span> ~]<span class="comment"># openssl passwd -1 -salt 123456 PASSWORD</span></span><br><span class="line">$<span class="number">1</span><span class="variable">$12345</span>6<span class="variable">$KP0rRo6agiZOiJz8GMOd0</span>0</span><br></pre></td></tr></table></figure>

<h4 id="4、生成随机数"><a href="#4、生成随机数" class="headerlink" title="4、生成随机数"></a>4、生成随机数</h4><p>openssl命令也支持生成随机数，其子命令为rand，对应的语法为：</p>
<blockquote>
<p>openssl rand [-out file] [-rand file(s)] [-base64] [-hex] num</p>
</blockquote>
<p>常用选项有：</p>
<blockquote>
<p>-base64：以base64编码格式输出；<br> -hex：使用十六进制编码格式；<br> -out FILE：将生成的内容保存在指定的文件中；</p>
</blockquote>
<p><strong>使用案例</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">root@localhost ~</span>]<span class="meta"># openssl rand  -base64  10</span></span><br><span class="line">d0etSF7CA13hhg==</span><br></pre></td></tr></table></figure>

<h4 id="5、生成密钥对"><a href="#5、生成密钥对" class="headerlink" title="5、生成密钥对"></a>5、生成密钥对</h4><p>利用openssl命令的子命令genrsa生成私钥，然后再使用子命令rsa私钥中提取公钥。<br> genrsa的语法如下：</p>
<blockquote>
<p>openssl genrsa [-out filename] [-passout arg] [-des] [-des3] [-idea] [-f4] [-3] [-rand file(s)] [-engine id] [numbits]<br> 常用选项：<br> -out FILENAME：将生成的私钥保存至指定的文件中；<br> [-des] [-des3] [-idea]：指定加密算法；<br> numbits：指明生成的私钥大小，默认是512；</p>
</blockquote>
<p>通常来说秘钥文件的权限一般只能由管理员访问，因此可以结合umask命令来设置生成的密钥文件的权限，如：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">root@localhost ~</span>]<span class="meta"># (umask 077;openssl genrsa -out CA.key 4096)</span></span><br><span class="line">Generating RSA <span class="keyword">private</span> key, <span class="number">4096</span> bit <span class="built_in">long</span> modulus</span><br><span class="line">.........................................................................................................................................++</span><br><span class="line">.................................................................++</span><br><span class="line">e <span class="keyword">is</span> <span class="number">65537</span> (<span class="number">0x10001</span>)</span><br><span class="line">[<span class="meta">root@localhost ~</span>]<span class="meta"># ll CA.key </span></span><br><span class="line">-rw-------. <span class="number">1</span> root root <span class="number">3243</span> Feb  <span class="number">2</span> <span class="number">06</span>:<span class="number">33</span> CA.key</span><br></pre></td></tr></table></figure>

<p>而随后可利用rsa子命令生成的私钥文件中提取公钥，rsa子命令的语法为：</p>
<blockquote>
<p>openssl rsa [-inform PEM|NET|DER] [-outform PEM|NET|DER] [-in filename] [-passin arg] [-out filename] [-passout arg] [-sgckey] [-des] [-des3] [-idea] [-text] [-noout] [-modulus] [-check] [-pubin] [-pubout] [-engine id]</p>
</blockquote>
<p>常用选项为：<br> -in FILENAME：指明私钥文件的存放路径；<br> -out FILENAME：指明将公钥的保存路径；<br> -pubout：根据提供的私钥，从中提取出公钥；</p>
<p>如：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">[root<span class="variable">@localhost</span> ~]<span class="comment"># openssl rsa -pubout -in CA.key </span></span><br><span class="line">writing <span class="variable constant_">RSA</span> key</span><br><span class="line">-----<span class="variable constant_">BEGIN</span> <span class="variable constant_">PUBLIC</span> <span class="variable constant_">KEY</span>-----</span><br><span class="line">MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA0r92sttB5yUOI3nE2nvj</span><br><span class="line">PeTZaKkFw2f4cVy8x615afGDhw/XvfWqd2X3BqUy9pPyVoYLOrO0fvGWtx0zVy76</span><br><span class="line"><span class="variable constant_">HZ</span>/N3vkUdmzQlJahwKl+K2rVYl2U7fw+qO1UHzrvnNqe6p10KURwAsD1nhuRf/ra</span><br><span class="line">SlxUuOPLNjyu5QeSjtoMuYbhk72M+ht+vNuZI8i2e9B6t6HzoHvnmxldjj+4tQje</span><br><span class="line">BCxeWwaerb8iWZ8KiNDGtqu1X20EevvJY7sp7RzzUPT4EKrXQ6BUyl+VeodHiHxp</span><br><span class="line">l/8gVdlDEYIyurjBwNJDl3I+ug+MZwB0BaPSqNdbgcQbwdM/E6SiBIKU366XkZ39</span><br><span class="line">uDneIZEaZIe12k3MlxqvXyLrsHc2V4jNdK+BNF0bU8pd8Z0wJ7B+Fl/k1+4fD5hS</span><br><span class="line">WLOziix36WrqWzgSgOAV4oEwZjLfBTWIPEcDLUO2LhrhHv4S9APi4FAIslu8QlHv</span><br><span class="line">dkzHaG0e6zolsIAHa1wClTVwFFfmABmo2axpc3IAu9EQA4lLJwK5MiDlANHJBTY7</span><br><span class="line">HXlAOGADgJXY3euiUB4oQ/WPcP2XPTmRQcYoey3hRETPbJd6heM6Rfx9TyCxjxeo</span><br><span class="line">xStmZmhHKZZek+h14Q/hmaK946SkPcbbszL1WzK/STwpceDgnijMgStq6fIippLb</span><br><span class="line">zaQiGXIq0SE8FGuYnCTYJPMCAwEAAQ==</span><br><span class="line">-----<span class="variable constant_">END</span> <span class="variable constant_">PUBLIC</span> <span class="variable constant_">KEY</span>-----</span><br></pre></td></tr></table></figure>

<h4 id="6、创建CA和申请证书"><a href="#6、创建CA和申请证书" class="headerlink" title="6、创建CA和申请证书"></a>6、创建CA和申请证书</h4><p>在使用OpenSSL命令创建证书前，可查看配置文件&#x2F;etc&#x2F;pki&#x2F;tls&#x2F;openss.conf文件，查看该文件定义了的证书存放位置及名称。<br> 1）创建自签证书<br> 首先为CA提供所需的目录及文件，并指明证书的开始编号：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkdir -pv /etc/pki/CA/&#123;certs,crl,newcerts&#125;</span></span><br><span class="line"><span class="comment"># touch /etc/pki/CA/&#123;serial,index.txt&#125;</span></span><br><span class="line"><span class="comment"># echo 01 &gt; /etc/pki/CA/serial</span></span><br></pre></td></tr></table></figure>

<p>随后生成私钥，注意私钥的文件名及其存放的位置，需与配置文件中相匹配：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">root@localhost ~</span>]<span class="meta"># (umask 077;openssl genrsa -out /etc/pki/CA/private/CAkey.pem 4096)</span></span><br><span class="line">Generating RSA <span class="keyword">private</span> key, <span class="number">4096</span> bit <span class="built_in">long</span> modulus</span><br><span class="line">..............................++</span><br><span class="line">.........................................................++</span><br><span class="line">e <span class="keyword">is</span> <span class="number">65537</span> (<span class="number">0x10001</span>)</span><br><span class="line">[<span class="meta">root@localhost ~</span>]<span class="meta"># ll /etc/pki/CA/private/CAkey.pem </span></span><br><span class="line">-rw-------. <span class="number">1</span> root root <span class="number">3243</span> Feb  <span class="number">2</span> <span class="number">07</span>:<span class="number">10</span> /etc/pki/CA/<span class="keyword">private</span>/CAkey.pem</span><br></pre></td></tr></table></figure>

<p>最后创建自签证书：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">[root<span class="variable">@localhost</span> <span class="variable constant_">CA</span>]<span class="comment"># openssl req -new -x509 -key /etc/pki/CA/private/cakey.pem  -out /etc/pki/CA/cacert.pem -days 3650</span></span><br><span class="line">You are about to be asked to enter information that will be incorporated</span><br><span class="line">into your certificate request.</span><br><span class="line">What you are about to enter is what is called a Distinguished Name <span class="keyword">or</span> a <span class="variable constant_">DN</span>.</span><br><span class="line">There are quite a few fields but you can leave some blank</span><br><span class="line">For some fields there will be a default value,</span><br><span class="line">If you enter <span class="string">&#x27;.&#x27;</span>, the field will be left blank.</span><br><span class="line">-----</span><br><span class="line">Country Name (<span class="number">2</span> letter code) [<span class="variable constant_">XX</span>]<span class="symbol">:CN</span></span><br><span class="line">State <span class="keyword">or</span> Province Name (full name) []<span class="symbol">:guangdong</span></span><br><span class="line">Locality Name (eg, city) [Default City]<span class="symbol">:shenzhen</span>  </span><br><span class="line">Organization Name (eg, company) [Default Company Ltd]<span class="symbol">:magedu</span></span><br><span class="line">Organizational Unit Name (eg, section) []<span class="symbol">:ops</span></span><br><span class="line">Common Name (eg, your name <span class="keyword">or</span> your server<span class="string">&#x27;s hostname) []:ca.magedu.com</span></span><br><span class="line"><span class="string">Email Address []:</span></span><br><span class="line"><span class="string">[root@localhost CA]# </span></span><br><span class="line"><span class="string">[root@localhost CA]# </span></span><br><span class="line"><span class="string">[root@localhost CA]# ll </span></span><br><span class="line"><span class="string">total 20</span></span><br><span class="line"><span class="string">-rw-r--r--. 1 root root 2025 Apr 17 02:14 cacert.pem</span></span><br><span class="line"><span class="string">drwxr-xr-x. 2 root root 4096 May  9  2016 certs</span></span><br><span class="line"><span class="string">drwxr-xr-x. 2 root root 4096 May  9  2016 crl</span></span><br><span class="line"><span class="string">drwxr-xr-x. 2 root root 4096 May  9  2016 newcerts</span></span><br><span class="line"><span class="string">drwx------. 2 root root 4096 Apr 17 02:12 private</span></span><br></pre></td></tr></table></figure>

<p>其中命令<code>openssl req -new -x509 -key /etc/pki/CA/private/cakey.pem -out /etc/pki/CA/cacert.pem -days 3650</code>用到子命令为req，其为证书请求及生成的工具，用到的选项解释为：</p>
<blockquote>
<p>-new：表示生成一个新的证书签署请求；<br> -x509：专用于生成CA自签证书；<br> -key：指定生成证书用到的私钥文件；<br> -out FILNAME：指定生成的证书的保存路径；<br> -days：指定证书的有效期限，单位为day，默认是365天；</p>
</blockquote>
<p>2）颁发证书<br> 通常来说在CA签署颁发证书需要进行以下步骤：</p>
<ul>
<li>在需要使用证书的主机上生成私钥（私钥文件位置无限制）</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">root@localhost ~</span>]<span class="meta"># (umask;openssl genrsa -out httpd.key 4096)</span></span><br><span class="line"><span class="number">0022</span></span><br><span class="line">Generating RSA <span class="keyword">private</span> key, <span class="number">4096</span> bit <span class="built_in">long</span> modulus</span><br><span class="line">...................................................................................................................................................................................................++</span><br><span class="line">............................................................++</span><br><span class="line">e <span class="keyword">is</span> <span class="number">65537</span> (<span class="number">0x10001</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>生成证书签署请求；</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">[root<span class="variable">@localhost</span> ~]<span class="comment"># openssl req -new -key httpd.key -out httpd.csr -days 3650</span></span><br><span class="line">You are about to be asked to enter information that will be incorporated</span><br><span class="line">into your certificate request.</span><br><span class="line">What you are about to enter is what is called a Distinguished Name <span class="keyword">or</span> a <span class="variable constant_">DN</span>.</span><br><span class="line">There are quite a few fields but you can leave some blank</span><br><span class="line">For some fields there will be a default value,</span><br><span class="line">If you enter <span class="string">&#x27;.&#x27;</span>, the field will be left blank.</span><br><span class="line">-----</span><br><span class="line">Country Name (<span class="number">2</span> letter code) [<span class="variable constant_">XX</span>]<span class="symbol">:CN</span>       </span><br><span class="line">State <span class="keyword">or</span> Province Name (full name) []<span class="symbol">:guangdong</span></span><br><span class="line">Locality Name (eg, city) [Default City]<span class="symbol">:shenzhen</span></span><br><span class="line">Organization Name (eg, company) [Default Company Ltd]<span class="symbol">:magedu</span></span><br><span class="line">Organizational Unit Name (eg, section) []<span class="symbol">:ops</span></span><br><span class="line">Common Name (eg, your name <span class="keyword">or</span> your server<span class="string">&#x27;s hostname) []:web.magedu.com</span></span><br><span class="line"><span class="string">Email Address []:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Please enter the following &#x27;</span>extra<span class="string">&#x27; attributes</span></span><br><span class="line"><span class="string">to be sent with your certificate request</span></span><br><span class="line"><span class="string">A challenge password []:</span></span><br><span class="line"><span class="string">An optional company name []:</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过可靠的方式将证书签署请求发送给CA主机；</li>
<li>在CA服务器上签署证书后颁发证书</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">root@localhost ~</span>]<span class="meta"># openssl ca -in httpd.csr -out /etc/pki/CA/certs/httpd.crt -days 365</span></span><br><span class="line">Using configuration <span class="keyword">from</span> /etc/pki/tls/openssl.cnf</span><br><span class="line">Check that the request matches the signature</span><br><span class="line">Signature ok</span><br><span class="line">Certificate Details:</span><br><span class="line">        Serial Number: <span class="number">1</span> (<span class="number">0x1</span>)</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Apr <span class="number">16</span> <span class="number">18</span>:<span class="number">31</span>:<span class="number">12</span> <span class="number">2018</span> GMT</span><br><span class="line">            Not After : Apr <span class="number">16</span> <span class="number">18</span>:<span class="number">31</span>:<span class="number">12</span> <span class="number">2019</span> GMT</span><br><span class="line">        Subject:</span><br><span class="line">            countryName               = CN</span><br><span class="line">            stateOrProvinceName       = guangdong</span><br><span class="line">            organizationName          = magedu</span><br><span class="line">            organizationalUnitName    = ops</span><br><span class="line">            commonName                = web.magedu.com</span><br><span class="line">        X509v3 extensions:</span><br><span class="line">            X509v3 Basic Constraints: </span><br><span class="line">                CA:FALSE</span><br><span class="line">            Netscape Comment: </span><br><span class="line">                OpenSSL Generated Certificate</span><br><span class="line">            X509v3 Subject Key Identifier: </span><br><span class="line">                D2:A2:<span class="number">81</span>:<span class="number">85</span>:<span class="number">70</span>:<span class="number">1B</span>:<span class="number">12</span>:A2:<span class="number">06</span>:<span class="number">7</span>E:F6:FB:<span class="number">32</span>:<span class="number">7B</span>:<span class="number">56</span>:<span class="number">3B</span>:<span class="number">7B</span>:CB:A2:B2</span><br><span class="line">            X509v3 Authority Key Identifier: </span><br><span class="line">                keyid:<span class="number">43</span>:AE:<span class="number">6</span>C:A2:<span class="number">6F</span>:<span class="number">6</span>E:E4:E1:C3:<span class="number">45</span>:<span class="number">3</span>E:<span class="number">1</span>D:<span class="number">74</span>:E6:<span class="number">94</span>:<span class="number">89</span>:<span class="number">50</span>:<span class="number">25</span>:<span class="number">0</span>C:<span class="number">0</span>A</span><br><span class="line"></span><br><span class="line">Certificate <span class="keyword">is</span> to be certified until Apr <span class="number">16</span> <span class="number">18</span>:<span class="number">31</span>:<span class="number">12</span> <span class="number">2019</span> GMT (<span class="number">365</span> days)</span><br><span class="line">Sign the certificate? [y/n]:y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">out</span> of <span class="number">1</span> certificate requests certified, commit? [y/n]y</span><br><span class="line">Write <span class="keyword">out</span> database <span class="keyword">with</span> <span class="number">1</span> <span class="keyword">new</span> entries</span><br><span class="line">Data Base Updated</span><br></pre></td></tr></table></figure>

<p>上述命令用到了openssl命令的子命令CA，用于在CA服务器上签署或吊销证书。</p>
<ul>
<li>查看证书信息：</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">[root<span class="variable">@localhost</span> ~]<span class="comment"># openssl x509 -in /etc/pki/CA/certs/httpd.crt -noout -serial -dates -subject</span></span><br><span class="line">serial=<span class="number">01</span></span><br><span class="line">notBefore=Apr <span class="number">16</span> <span class="number">18</span><span class="symbol">:</span><span class="number">31</span><span class="symbol">:</span><span class="number">12</span> <span class="number">2018</span> <span class="variable constant_">GMT</span></span><br><span class="line">notAfter=Apr <span class="number">16</span> <span class="number">18</span><span class="symbol">:</span><span class="number">31</span><span class="symbol">:</span><span class="number">12</span> <span class="number">2019</span> <span class="variable constant_">GMT</span></span><br><span class="line">subject= <span class="regexp">/C=CN/</span><span class="variable constant_">ST</span>=guangdong/O=magedu/<span class="variable constant_">OU</span>=ops/<span class="variable constant_">CN</span>=web.magedu.com</span><br></pre></td></tr></table></figure>

<p>上述查看证书使用了openssl命令的子命令x509，其选项解释为：</p>
<blockquote>
<p>-noout：不输出加密的证书内容；<br> -serial：输出证书序列号；<br> -dates：显示证书有效期的开始和终止时间；<br> -subject：输出证书的subject；</p>
</blockquote>
<p>3）吊销证书<br> 吊销证书的步骤通常为：</p>
<ul>
<li>在使用证书的主机上获取要吊销的证书的serial和subject信息（使用查看证书的命令）</li>
<li>根据客户提交的serial和subject信息，对比本机数据库index.txt中存储的是否一致</li>
<li>如一致，则执行吊销证书的操作；</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">root@localhost ~</span>]<span class="meta"># openssl ca -revoke /etc/pki/CA/newcerts/01.pem </span></span><br><span class="line">Using configuration <span class="keyword">from</span> /etc/pki/tls/openssl.cnf</span><br><span class="line">Revoking Certificate <span class="number">01.</span></span><br><span class="line">Data Base Updated</span><br></pre></td></tr></table></figure>

<ul>
<li>生成吊销证书的吊销编号（第一次吊销证书时执行）</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">root@localhost ~</span>]<span class="meta"># echo 01 &gt; /etc/pki/CA/crlnumber</span></span><br><span class="line">[<span class="meta">root@localhost ~</span>]<span class="meta"># cat /etc/pki/CA/crlnumber</span></span><br><span class="line"><span class="number">01</span></span><br></pre></td></tr></table></figure>

<ul>
<li>更新证书吊销列表</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">root@localhost ~</span>]<span class="meta"># openssl ca -gencrl -out /etc/pki/CA/crl/ca.crl</span></span><br><span class="line">Using configuration <span class="keyword">from</span> /etc/pki/tls/openssl.cnf</span><br></pre></td></tr></table></figure>

<p>-gencrl选项为根据&#x2F;etc&#x2F;pki&#x2F;CA&#x2F;index.txt文件中的信息生成crl文件。</p>
<ul>
<li>查看crl文件</li>
</ul>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">[root<span class="meta">@localhost</span> ~]# openssl crl -<span class="keyword">in</span> /etc/pki/<span class="variable constant_">CA</span>/crl/ca.<span class="property">crl</span> -noout -text</span><br><span class="line"><span class="title class_">Certificate</span> <span class="title class_">Revocation</span> <span class="title class_">List</span> (<span class="variable constant_">CRL</span>):</span><br><span class="line">        <span class="title class_">Version</span> <span class="number">2</span> (<span class="number">0x1</span>)</span><br><span class="line">    <span class="title class_">Signature</span> <span class="title class_">Algorithm</span>: sha1WithRSAEncryption</span><br><span class="line">        <span class="title class_">Issuer</span>: <span class="regexp">/C=CN/</span><span class="variable constant_">ST</span>=guangdong/L=shenzhen/O=magedu/<span class="variable constant_">OU</span>=ops/<span class="variable constant_">CN</span>=ca.<span class="property">magedu</span>.<span class="property">com</span></span><br><span class="line">        <span class="title class_">Last</span> <span class="title class_">Update</span>: <span class="title class_">Apr</span> <span class="number">16</span> <span class="number">18</span>:<span class="number">54</span>:<span class="number">35</span> <span class="number">2018</span> <span class="variable constant_">GMT</span></span><br><span class="line">        <span class="title class_">Next</span> <span class="title class_">Update</span>: <span class="title class_">May</span> <span class="number">16</span> <span class="number">18</span>:<span class="number">54</span>:<span class="number">35</span> <span class="number">2018</span> <span class="variable constant_">GMT</span></span><br><span class="line">        <span class="variable constant_">CRL</span> <span class="attr">extensions</span>:</span><br><span class="line">            X509v3 <span class="variable constant_">CRL</span> <span class="title class_">Number</span>: </span><br><span class="line">                <span class="number">1</span></span><br><span class="line"><span class="title class_">Revoked</span> <span class="title class_">Certificates</span>:</span><br><span class="line">    <span class="title class_">Serial</span> <span class="title class_">Number</span>: <span class="number">01</span>                 #吊销的证书serial</span><br><span class="line">        <span class="title class_">Revocation</span> <span class="title class_">Date</span>: <span class="title class_">Apr</span> <span class="number">16</span> <span class="number">18</span>:<span class="number">51</span>:<span class="number">24</span> <span class="number">2018</span> <span class="variable constant_">GMT</span></span><br><span class="line">    <span class="title class_">Signature</span> <span class="title class_">Algorithm</span>: sha1WithRSAEncryption</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>



<blockquote>
<p>作者：小尛酒窝<br>链接：<a href="https://www.jianshu.com/p/e311a6537467">https://www.jianshu.com/p/e311a6537467</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
]]></content>
      <categories>
        <category>ssl</category>
      </categories>
      <tags>
        <tag>ssl</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo Hello World</title>
    <url>/2022/05/24/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Kubernetes详细教程</title>
    <url>/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="1-Kubernetes介绍"><a href="#1-Kubernetes介绍" class="headerlink" title="1. Kubernetes介绍"></a>1. Kubernetes介绍</h3><h4 id="1-1-应用部署方式演变"><a href="#1-1-应用部署方式演变" class="headerlink" title="1.1 应用部署方式演变"></a>1.1 应用部署方式演变</h4><p>在部署应用程序的方式上，主要经历了三个时代：</p>
<ul>
<li><p><strong>传统部署</strong>：互联网早期，会直接将应用程序部署在物理机上</p>
<blockquote>
<p>优点：简单，不需要其它技术的参与</p>
<p>缺点：不能为应用程序定义资源使用边界，很难合理地分配计算资源，而且程序之间容易产生影响</p>
</blockquote>
</li>
<li><p><strong>虚拟化部署</strong>：可以在一台物理机上运行多个虚拟机，每个虚拟机都是独立的一个环境</p>
<blockquote>
<p>优点：程序环境不会相互产生影响，提供了一定程度的安全性</p>
<p>缺点：增加了操作系统，浪费了部分资源</p>
</blockquote>
</li>
<li><p><strong>容器化部署</strong>：与虚拟化类似，但是共享了操作系统</p>
<blockquote>
<p>优点：</p>
<p>可以保证每个容器拥有自己的文件系统、CPU、内存、进程空间等</p>
<p>运行应用程序所需要的资源都被容器包装，并和底层基础架构解耦</p>
<p>容器化的应用程序可以跨云服务商、跨Linux操作系统发行版进行部署</p>
</blockquote>
</li>
</ul>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200505183738289-165356431070859.png" alt="image-20200505183738289"></p>
<p>容器化部署方式给带来很多的便利，但是也会出现一些问题，比如说：</p>
<ul>
<li>一个容器故障停机了，怎么样让另外一个容器立刻启动去替补停机的容器</li>
<li>当并发访问量变大的时候，怎么样做到横向扩展容器数量</li>
</ul>
<p>这些容器管理的问题统称为<strong>容器编排</strong>问题，为了解决这些容器编排问题，就产生了一些容器编排的软件：</p>
<ul>
<li><strong>Swarm</strong>：Docker自己的容器编排工具</li>
<li><strong>Mesos</strong>：Apache的一个资源统一管控的工具，需要和Marathon结合使用</li>
<li><strong>Kubernetes</strong>：Google开源的的容器编排工具</li>
</ul>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200524150339551-165356431070860.png" alt="image-20200524150339551"></p>
<h4 id="1-2-kubernetes简介"><a href="#1-2-kubernetes简介" class="headerlink" title="1.2 kubernetes简介"></a>1.2 kubernetes简介</h4><p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200406232838722-165356431070861.png" alt="image-20200406232838722"></p>
<p>kubernetes，是一个全新的基于容器技术的分布式架构领先方案，是谷歌严格保密十几年的秘密武器—-Borg系统的一个开源版本，于2014年9月发布第一个版本，2015年7月发布第一个正式版本。</p>
<p>kubernetes的本质是<strong>一组服务器集群</strong>，它可以在集群的每个节点上运行特定的程序，来对节点中的容器进行管理。目的是实现资源管理的自动化，主要提供了如下的主要功能：</p>
<ul>
<li><strong>自我修复</strong>：一旦某一个容器崩溃，能够在1秒中左右迅速启动新的容器</li>
<li><strong>弹性伸缩</strong>：可以根据需要，自动对集群中正在运行的容器数量进行调整</li>
<li><strong>服务发现</strong>：服务可以通过自动发现的形式找到它所依赖的服务</li>
<li><strong>负载均衡</strong>：如果一个服务起动了多个容器，能够自动实现请求的负载均衡</li>
<li><strong>版本回退</strong>：如果发现新发布的程序版本有问题，可以立即回退到原来的版本</li>
<li><strong>存储编排</strong>：可以根据容器自身的需求自动创建存储卷</li>
</ul>
<h4 id="1-3-kubernetes组件"><a href="#1-3-kubernetes组件" class="headerlink" title="1.3 kubernetes组件"></a>1.3 kubernetes组件</h4><p>一个kubernetes集群主要是由**控制节点(master)<strong>、</strong>工作节点(node)**构成，每个节点上都会安装不同的组件。</p>
<p><strong>master：集群的控制平面，负责集群的决策 ( 管理 )</strong></p>
<blockquote>
<p><strong>ApiServer</strong> : 资源操作的唯一入口，接收用户输入的命令，提供认证、授权、API注册和发现等机制</p>
<p><strong>Scheduler</strong> : 负责集群资源调度，按照预定的调度策略将Pod调度到相应的node节点上</p>
<p><strong>ControllerManager</strong> : 负责维护集群的状态，比如程序部署安排、故障检测、自动扩展、滚动更新等</p>
<p><strong>Etcd</strong> ：负责存储集群中各种资源对象的信息</p>
</blockquote>
<p><strong>node：集群的数据平面，负责为容器提供运行环境 ( 干活 )</strong></p>
<blockquote>
<p><strong>Kubelet</strong> : 负责维护容器的生命周期，即通过控制docker，来创建、更新、销毁容器</p>
<p><strong>KubeProxy</strong> : 负责提供集群内部的服务发现和负载均衡</p>
<p><strong>Docker</strong> : 负责节点上容器的各种操作</p>
</blockquote>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200406184656917-165356431070862.png" alt="image-20200406184656917"></p>
<p>下面，以部署一个nginx服务来说明kubernetes系统各个组件调用关系：</p>
<ol>
<li><p>首先要明确，一旦kubernetes环境启动之后，master和node都会将自身的信息存储到etcd数据库中</p>
</li>
<li><p>一个nginx服务的安装请求会首先被发送到master节点的apiServer组件</p>
</li>
<li><p>apiServer组件会调用scheduler组件来决定到底应该把这个服务安装到哪个node节点上</p>
<p>在此时，它会从etcd中读取各个node节点的信息，然后按照一定的算法进行选择，并将结果告知apiServer</p>
</li>
<li><p>apiServer调用controller-manager去调度Node节点安装nginx服务</p>
</li>
<li><p>kubelet接收到指令后，会通知docker，然后由docker来启动一个nginx的pod</p>
<p>pod是kubernetes的最小操作单元，容器必须跑在pod中至此，</p>
</li>
<li><p>一个nginx服务就运行了，如果需要访问nginx，就需要通过kube-proxy来对pod产生访问的代理</p>
</li>
</ol>
<p>这样，外界用户就可以访问集群中的nginx服务了</p>
<h4 id="1-4-kubernetes概念"><a href="#1-4-kubernetes概念" class="headerlink" title="1.4 kubernetes概念"></a>1.4 kubernetes概念</h4><p><strong>Master</strong>：集群控制节点，每个集群需要至少一个master节点负责集群的管控</p>
<p><strong>Node</strong>：工作负载节点，由master分配容器到这些node工作节点上，然后node节点上的docker负责容器的运行</p>
<p><strong>Pod</strong>：kubernetes的最小控制单元，容器都是运行在pod中的，一个pod中可以有1个或者多个容器</p>
<p><strong>Controller</strong>：控制器，通过它来实现对pod的管理，比如启动pod、停止pod、伸缩pod的数量等等</p>
<p><strong>Service</strong>：pod对外服务的统一入口，下面可以维护者同一类的多个pod</p>
<p><strong>Label</strong>：标签，用于对pod进行分类，同一类pod会拥有相同的标签</p>
<p><strong>NameSpace</strong>：命名空间，用来隔离pod的运行环境</p>
<h3 id="2-kubernetes集群环境搭建"><a href="#2-kubernetes集群环境搭建" class="headerlink" title="2. kubernetes集群环境搭建"></a>2. kubernetes集群环境搭建</h3><h4 id="2-1-前置知识点"><a href="#2-1-前置知识点" class="headerlink" title="2.1 前置知识点"></a>2.1 前置知识点</h4><p>目前生产部署Kubernetes 集群主要有两种方式：</p>
<p><strong>kubeadm</strong></p>
<p>Kubeadm 是一个K8s 部署工具，提供kubeadm init 和kubeadm join，用于快速部署Kubernetes 集群。</p>
<p>官方地址：<a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/">https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/</a></p>
<p><strong>二进制包</strong></p>
<p>从github 下载发行版的二进制包，手动部署每个组件，组成Kubernetes 集群。</p>
<p>Kubeadm 降低部署门槛，但屏蔽了很多细节，遇到问题很难排查。如果想更容易可控，推荐使用二进制包部署Kubernetes 集群，虽然手动部署麻烦点，期间可以学习很多工作原理，也利于后期维护。</p>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200404094800622-165356431070863.png" alt="image-20200404094800622"></p>
<h4 id="2-2-kubeadm-部署方式介绍"><a href="#2-2-kubeadm-部署方式介绍" class="headerlink" title="2.2 kubeadm 部署方式介绍"></a>2.2 kubeadm 部署方式介绍</h4><p>kubeadm 是官方社区推出的一个用于快速部署kubernetes 集群的工具，这个工具能通过两条指令完成一个kubernetes 集群的部署：</p>
<ul>
<li>创建一个Master 节点kubeadm init</li>
<li>将Node 节点加入到当前集群中$ kubeadm join &lt;Master 节点的IP 和端口&gt;</li>
</ul>
<h4 id="2-3-安装要求"><a href="#2-3-安装要求" class="headerlink" title="2.3 安装要求"></a>2.3 安装要求</h4><p>在开始之前，部署Kubernetes 集群机器需要满足以下几个条件：</p>
<ul>
<li>一台或多台机器，操作系统CentOS7.x-86_x64</li>
<li>硬件配置：2GB 或更多RAM，2 个CPU 或更多CPU，硬盘30GB 或更多</li>
<li>集群中所有机器之间网络互通</li>
<li>可以访问外网，需要拉取镜像</li>
<li>禁止swap 分区</li>
</ul>
<h4 id="2-4-最终目标"><a href="#2-4-最终目标" class="headerlink" title="2.4 最终目标"></a>2.4 最终目标</h4><ul>
<li>在所有节点上安装Docker 和kubeadm</li>
<li>部署Kubernetes Master</li>
<li>部署容器网络插件</li>
<li>部署Kubernetes Node，将节点加入Kubernetes 集群中</li>
<li>部署Dashboard Web 页面，可视化查看Kubernetes 资源</li>
</ul>
<h4 id="2-5-准备环境"><a href="#2-5-准备环境" class="headerlink" title="2.5 准备环境"></a>2.5 准备环境</h4><p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20210609000002940-165356431070864.png" alt="image-20210609000002940"></p>
<table>
<thead>
<tr>
<th align="left">角色</th>
<th align="left">IP地址</th>
<th align="left">组件</th>
</tr>
</thead>
<tbody><tr>
<td align="left">master01</td>
<td align="left">192.168.5.3</td>
<td align="left">docker，kubectl，kubeadm，kubelet</td>
</tr>
<tr>
<td align="left">node01</td>
<td align="left">192.168.5.4</td>
<td align="left">docker，kubectl，kubeadm，kubelet</td>
</tr>
<tr>
<td align="left">node02</td>
<td align="left">192.168.5.5</td>
<td align="left">docker，kubectl，kubeadm，kubelet</td>
</tr>
</tbody></table>
<h4 id="2-6-环境初始化"><a href="#2-6-环境初始化" class="headerlink" title="2.6 环境初始化"></a>2.6 环境初始化</h4><h5 id="2-6-1-检查操作系统的版本"><a href="#2-6-1-检查操作系统的版本" class="headerlink" title="2.6.1 检查操作系统的版本"></a>2.6.1 检查操作系统的版本</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此方式下安装kubernetes集群要求Centos版本要在7.5或之上</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># cat /etc/redhat-release</span></span><br><span class="line">Centos Linux <span class="number">7.5</span>.<span class="number">1804</span> (Core)</span><br></pre></td></tr></table></figure>

<h5 id="2-6-2-主机名解析"><a href="#2-6-2-主机名解析" class="headerlink" title="2.6.2 主机名解析"></a>2.6.2 主机名解析</h5><p>为了方便集群节点间的直接调用，在这个配置一下主机名解析，企业中推荐使用内部DNS服务器</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 主机名成解析 编辑三台服务器的/etc/hosts文件，添加下面内容</span></span><br><span class="line"><span class="number">192.168</span>.<span class="number">90.100</span> master</span><br><span class="line"><span class="number">192.168</span>.<span class="number">90.106</span> node1</span><br><span class="line"><span class="number">192.168</span>.<span class="number">90.107</span> node2</span><br></pre></td></tr></table></figure>

<h5 id="2-6-3-时间同步"><a href="#2-6-3-时间同步" class="headerlink" title="2.6.3 时间同步"></a>2.6.3 时间同步</h5><p>kubernetes要求集群中的节点时间必须精确一直，这里使用chronyd服务从网络同步时间</p>
<p>企业中建议配置内部的会见同步服务器</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动chronyd服务</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl start chronyd</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl enable chronyd</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># date</span></span><br></pre></td></tr></table></figure>

<h5 id="2-6-4-禁用iptable和firewalld服务"><a href="#2-6-4-禁用iptable和firewalld服务" class="headerlink" title="2.6.4  禁用iptable和firewalld服务"></a>2.6.4  禁用iptable和firewalld服务</h5><p>kubernetes和docker 在运行的中会产生大量的iptables规则，为了不让系统规则跟它们混淆，直接关闭系统的规则</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 关闭firewalld服务</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl stop firewalld</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl disable firewalld</span></span><br><span class="line"><span class="comment"># 2 关闭iptables服务</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl stop iptables</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl disable iptables</span></span><br></pre></td></tr></table></figure>

<h5 id="2-6-5-禁用selinux"><a href="#2-6-5-禁用selinux" class="headerlink" title="2.6.5 禁用selinux"></a>2.6.5 禁用selinux</h5><p>selinux是linux系统下的一个安全服务，如果不关闭它，在安装集群中会产生各种各样的奇葩问题</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑 /etc/selinux/config 文件，修改SELINUX的值为disable</span></span><br><span class="line"><span class="comment"># 注意修改完毕之后需要重启linux服务</span></span><br><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure>

<h5 id="2-6-6-禁用swap分区"><a href="#2-6-6-禁用swap分区" class="headerlink" title="2.6.6 禁用swap分区"></a>2.6.6 禁用swap分区</h5><p>swap分区指的是虚拟内存分区，它的作用是物理内存使用完，之后将磁盘空间虚拟成内存来使用，启用swap设备会对系统的性能产生非常负面的影响，因此kubernetes要求每个节点都要禁用swap设备，但是如果因为某些原因确实不能关闭swap分区，就需要在集群安装过程中通过明确的参数进行配置说明</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑分区配置文件/etc/fstab，注释掉swap分区一行</span></span><br><span class="line"><span class="comment"># 注意修改完毕之后需要重启linux服务</span></span><br><span class="line">vim /etc/fstab</span><br><span class="line">注释掉 /dev/mapper/centos<span class="literal">-swap</span> swap</span><br><span class="line"><span class="comment"># /dev/mapper/centos-swap swap</span></span><br></pre></td></tr></table></figure>

<h5 id="2-6-7-修改linux的内核参数"><a href="#2-6-7-修改linux的内核参数" class="headerlink" title="2.6.7 修改linux的内核参数"></a>2.6.7 修改linux的内核参数</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改linux的内核采纳数，添加网桥过滤和地址转发功能</span></span><br><span class="line"><span class="comment"># 编辑/etc/sysctl.d/kubernetes.conf文件，添加如下配置：</span></span><br><span class="line">net.bridge.bridge<span class="literal">-nf-call-ip6tables</span> = <span class="number">1</span></span><br><span class="line">net.bridge.bridge<span class="literal">-nf-call-iptables</span> = <span class="number">1</span></span><br><span class="line">net.ipv4.ip_forward = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载配置</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># sysctl -p</span></span><br><span class="line"><span class="comment"># 加载网桥过滤模块</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># modprobe br_netfilter</span></span><br><span class="line"><span class="comment"># 查看网桥过滤模块是否加载成功</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># lsmod | grep br_netfilter</span></span><br></pre></td></tr></table></figure>

<h5 id="2-6-8-配置ipvs功能"><a href="#2-6-8-配置ipvs功能" class="headerlink" title="2.6.8 配置ipvs功能"></a>2.6.8 配置ipvs功能</h5><p>在Kubernetes中Service有两种带来模型，一种是基于iptables的，一种是基于ipvs的两者比较的话，ipvs的性能明显要高一些，但是如果要使用它，需要手动载入ipvs模块</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.安装ipset和ipvsadm</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># yum install ipset ipvsadm -y</span></span><br><span class="line"><span class="comment"># 2.添加需要加载的模块写入脚本文件</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># cat &lt;&lt;EOF&gt; /etc/sysconfig/modules/ipvs.modules</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">modprobe <span class="literal">--</span> ip_vs</span><br><span class="line">modprobe <span class="literal">--</span> ip_vs_rr</span><br><span class="line">modprobe <span class="literal">--</span> ip_vs_wrr</span><br><span class="line">modprobe <span class="literal">--</span> ip_vs_sh</span><br><span class="line">modprobe <span class="literal">--</span> nf_conntrack_ipv4</span><br><span class="line">EOF</span><br><span class="line"><span class="comment"># 3.为脚本添加执行权限</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># chmod +x /etc/sysconfig/modules/ipvs.modules</span></span><br><span class="line"><span class="comment"># 4.执行脚本文件</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># /bin/bash /etc/sysconfig/modules/ipvs.modules</span></span><br><span class="line"><span class="comment"># 5.查看对应的模块是否加载成功</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># lsmod | grep -e ip_vs -e nf_conntrack_ipv4</span></span><br></pre></td></tr></table></figure>

<h5 id="2-6-9-安装docker"><a href="#2-6-9-安装docker" class="headerlink" title="2.6.9 安装docker"></a>2.6.9 安装docker</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、切换镜像源</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、查看当前镜像源中支持的docker版本</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># yum list docker-ce --showduplicates</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、安装特定版本的docker-ce</span></span><br><span class="line"><span class="comment"># 必须制定--setopt=obsoletes=0，否则yum会自动安装更高版本</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># yum install --setopt=obsoletes=0 docker-ce-18.06.3.ce-3.el7 -y</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4、添加一个配置文件</span></span><br><span class="line"><span class="comment">#Docker 在默认情况下使用Vgroup Driver为cgroupfs，而Kubernetes推荐使用systemd来替代cgroupfs</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># mkdir /etc/docker</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># cat &lt;&lt;EOF&gt; /etc/docker/daemon.json</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;exec-opts&quot;</span>: [<span class="string">&quot;native.cgroupdriver=systemd&quot;</span>],</span><br><span class="line">	<span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://kn0t2bca.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5、启动dokcer</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl restart docker</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl enable docker</span></span><br></pre></td></tr></table></figure>

<h5 id="2-6-10-安装Kubernetes组件"><a href="#2-6-10-安装Kubernetes组件" class="headerlink" title="2.6.10 安装Kubernetes组件"></a>2.6.10 安装Kubernetes组件</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、由于kubernetes的镜像在国外，速度比较慢，这里切换成国内的镜像源</span></span><br><span class="line"><span class="comment"># 2、编辑/etc/yum.repos.d/kubernetes.repo,添加下面的配置</span></span><br><span class="line">[<span class="type">kubernetes</span>]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes<span class="literal">-el7-x86_64</span></span><br><span class="line">enabled=<span class="number">1</span></span><br><span class="line">gpgchech=<span class="number">0</span></span><br><span class="line">repo_gpgcheck=<span class="number">0</span></span><br><span class="line">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum<span class="literal">-key</span>.gpg</span><br><span class="line">			http://mirrors.aliyun.com/kubernetes/yum/doc/rpm<span class="literal">-package-key</span>.gpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、安装kubeadm、kubelet和kubectl</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># yum install --setopt=obsoletes=0 kubeadm-1.17.4-0 kubelet-1.17.4-0 kubectl-1.17.4-0 -y</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4、配置kubelet的cgroup</span></span><br><span class="line"><span class="comment">#编辑/etc/sysconfig/kubelet, 添加下面的配置</span></span><br><span class="line">KUBELET_CGROUP_ARGS=<span class="string">&quot;--cgroup-driver=systemd&quot;</span></span><br><span class="line">KUBE_PROXY_MODE=<span class="string">&quot;ipvs&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5、设置kubelet开机自启</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl enable kubelet</span></span><br></pre></td></tr></table></figure>

<h5 id="2-6-11-准备集群镜像"><a href="#2-6-11-准备集群镜像" class="headerlink" title="2.6.11 准备集群镜像"></a>2.6.11 准备集群镜像</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在安装kubernetes集群之前，必须要提前准备好集群需要的镜像，所需镜像可以通过下面命令查看</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubeadm config images list</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载镜像</span></span><br><span class="line"><span class="comment"># 此镜像kubernetes的仓库中，由于网络原因，无法连接，下面提供了一种替换方案</span></span><br><span class="line">images=(</span><br><span class="line">	kube<span class="literal">-apiserver</span>:v1.<span class="number">17.4</span></span><br><span class="line">	kube<span class="literal">-controller-manager</span>:v1.<span class="number">17.4</span></span><br><span class="line">	kube<span class="literal">-scheduler</span>:v1.<span class="number">17.4</span></span><br><span class="line">	kube<span class="literal">-proxy</span>:v1.<span class="number">17.4</span></span><br><span class="line">	pause:<span class="number">3.1</span></span><br><span class="line">	etcd:<span class="number">3.4</span>.<span class="number">3</span><span class="literal">-0</span></span><br><span class="line">	coredns:<span class="number">1.6</span>.<span class="number">5</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> imageName <span class="keyword">in</span> <span class="variable">$</span>&#123;images[<span class="selector-tag">@</span>]&#125;;<span class="keyword">do</span></span><br><span class="line">	docker pull registry.cn<span class="literal">-hangzhou</span>.aliyuncs.com/google_containers/<span class="variable">$imageName</span></span><br><span class="line">	docker tag registry.cn<span class="literal">-hangzhou</span>.aliyuncs.com/google_containers/<span class="variable">$imageName</span> k8s.gcr.io/<span class="variable">$imageName</span></span><br><span class="line">	docker rmi registry.cn<span class="literal">-hangzhou</span>.aliyuncs.com/google_containers/<span class="variable">$imageName</span> </span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-6-11-集群初始化"><a href="#2-6-11-集群初始化" class="headerlink" title="2.6.11 集群初始化"></a>2.6.11 集群初始化</h5><blockquote>
<p>下面的操作只需要在master节点上执行即可</p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建集群</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubeadm init \</span></span><br><span class="line">	<span class="literal">--apiserver-advertise-address</span>=<span class="number">192.168</span>.<span class="number">90.100</span> \</span><br><span class="line">	<span class="literal">--image-repository</span> registry.aliyuncs.com/google_containers \</span><br><span class="line">	<span class="literal">--kubernetes-version</span>=v1.<span class="number">17.4</span> \</span><br><span class="line">	<span class="literal">--service-cidr</span>=<span class="number">10.96</span>.<span class="number">0.0</span>/<span class="number">12</span> \</span><br><span class="line">	<span class="literal">--pod-network-cidr</span>=<span class="number">10.244</span>.<span class="number">0.0</span>/<span class="number">16</span></span><br><span class="line"><span class="comment"># 创建必要文件</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># mkdir -p $HOME/.kube</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># sudo chown $(id -u):$(id -g) $HOME/.kube/config</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>下面的操作只需要在node节点上执行即可</p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">kubeadm join <span class="number">192.168</span>.<span class="number">0.100</span>:<span class="number">6443</span> <span class="literal">--token</span> awk15p.t6bamck54w69u4s8 \</span><br><span class="line">    <span class="literal">--discovery-token-ca-cert-hash</span> sha256:a94fa09562466d32d29523ab6cff122186f1127599fa4dcd5fa0152694f17117 </span><br></pre></td></tr></table></figure>

<p>在master上查看节点信息</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get nodes</span></span><br><span class="line">NAME    STATUS   ROLES     AGE   VERSION</span><br><span class="line">master  NotReady  master   <span class="number">6</span>m    v1.<span class="number">17.4</span></span><br><span class="line">node1   NotReady   &lt;none&gt;  <span class="number">22</span>s   v1.<span class="number">17.4</span></span><br><span class="line">node2   NotReady   &lt;none&gt;  <span class="number">19</span>s   v1.<span class="number">17.4</span></span><br></pre></td></tr></table></figure>

<h5 id="2-6-13-安装网络插件，只在master节点操作即可"><a href="#2-6-13-安装网络插件，只在master节点操作即可" class="headerlink" title="2.6.13 安装网络插件，只在master节点操作即可"></a>2.6.13 安装网络插件，只在master节点操作即可</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">wget</span> https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube<span class="literal">-flannel</span>.yml</span><br></pre></td></tr></table></figure>

<p>由于外网不好访问，如果出现无法访问的情况，可以直接用下面的 记得文件名是kube-flannel.yml，位置：&#x2F;root&#x2F;kube-flannel.yml内容：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">https://github.com/flannel<span class="literal">-io</span>/flannel/tree/master/Documentation/kube<span class="literal">-flannel</span>.yml</span><br></pre></td></tr></table></figure>

<p>也可手动拉取指定版本<br>docker pull quay.io&#x2F;coreos&#x2F;flannel:v0.14.0              #拉取flannel网络，三台主机<br>docker images                  #查看仓库是否拉去下来</p>
<p><code>个人笔记</code><br>若是集群状态一直是 notready,用下面语句查看原因，<br>journalctl -f -u kubelet.service<br>若原因是： cni.go:237] Unable to update cni config: no networks found in &#x2F;etc&#x2F;cni&#x2F;net.d<br>mkdir -p &#x2F;etc&#x2F;cni&#x2F;net.d                    #创建目录给flannel做配置文件<br>vim &#x2F;etc&#x2F;cni&#x2F;net.d&#x2F;10-flannel.conf         #编写配置文件</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;name&quot;</span>:<span class="string">&quot;cbr0&quot;</span>,</span><br><span class="line"> <span class="string">&quot;cniVersion&quot;</span>:<span class="string">&quot;0.3.1&quot;</span>,</span><br><span class="line"> <span class="string">&quot;type&quot;</span>:<span class="string">&quot;flannel&quot;</span>,</span><br><span class="line"> <span class="string">&quot;deledate&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;hairpinMode&quot;</span>:true,</span><br><span class="line">    <span class="string">&quot;isDefaultGateway&quot;</span>:true</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h5 id="2-6-14-使用kubeadm-reset重置集群"><a href="#2-6-14-使用kubeadm-reset重置集群" class="headerlink" title="2.6.14 使用kubeadm reset重置集群"></a>2.6.14 使用kubeadm reset重置集群</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#在master节点之外的节点进行操作</span><br><span class="line">kubeadm reset</span><br><span class="line">systemctl stop kubelet</span><br><span class="line">systemctl stop docker</span><br><span class="line">rm -rf /var/lib/cni/</span><br><span class="line">rm -rf /var/lib/kubelet/*</span><br><span class="line">rm -rf /etc/cni/</span><br><span class="line">ifconfig cni0 down</span><br><span class="line">ifconfig flannel.1 down</span><br><span class="line">ifconfig docker0 down</span><br><span class="line">ip link delete cni0</span><br><span class="line">ip link delete flannel.1</span><br><span class="line">##重启kubelet</span><br><span class="line">systemctl restart kubelet</span><br><span class="line">##重启docker</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<h5 id="2-6-15-重启kubelet和docker"><a href="#2-6-15-重启kubelet和docker" class="headerlink" title="2.6.15 重启kubelet和docker"></a>2.6.15 重启kubelet和docker</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重启kubelet</span></span><br><span class="line">systemctl restart kubelet</span><br><span class="line"><span class="comment"># 重启docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>使用配置文件启动fannel</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">kubectl apply <span class="operator">-f</span> kube<span class="literal">-flannel</span>.yml</span><br></pre></td></tr></table></figure>

<p>等待它安装完毕 发现已经是 集群的状态已经是Ready</p>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/2232696-20210621233106024-1676033717-165356431070865.png" alt="img"></p>
<h5 id="2-6-16-kubeadm中的命令"><a href="#2-6-16-kubeadm中的命令" class="headerlink" title="2.6.16 kubeadm中的命令"></a>2.6.16 kubeadm中的命令</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成 新的token</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubeadm token create --print-join-command</span></span><br></pre></td></tr></table></figure>

<h4 id="2-7-集群测试"><a href="#2-7-集群测试" class="headerlink" title="2.7 集群测试"></a>2.7 集群测试</h4><h5 id="2-7-1-创建一个nginx服务"><a href="#2-7-1-创建一个nginx服务" class="headerlink" title="2.7.1 创建一个nginx服务"></a>2.7.1 创建一个nginx服务</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">kubectl create deployment nginx  <span class="literal">--image</span>=nginx:<span class="number">1.14</span><span class="literal">-alpine</span></span><br></pre></td></tr></table></figure>

<h5 id="2-7-2-暴露端口"><a href="#2-7-2-暴露端口" class="headerlink" title="2.7.2 暴露端口"></a>2.7.2 暴露端口</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">kubectl expose deploy nginx  <span class="literal">--port</span>=<span class="number">80</span> <span class="literal">--target-port</span>=<span class="number">80</span>  <span class="literal">--type</span>=NodePort</span><br></pre></td></tr></table></figure>

<h5 id="2-7-3-查看服务"><a href="#2-7-3-查看服务" class="headerlink" title="2.7.3 查看服务"></a>2.7.3 查看服务</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">kubectl get pod,svc</span><br></pre></td></tr></table></figure>

<h5 id="2-7-4-查看pod"><a href="#2-7-4-查看pod" class="headerlink" title="2.7.4 查看pod"></a>2.7.4 查看pod</h5><p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/2232696-20210621233130477-111035427-165356431070866.png" alt="img"></p>
<p>浏览器测试结果：</p>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/2232696-20210621233157075-1117518703-165356431070867.png" alt="img"></p>
<h3 id="3-资源管理"><a href="#3-资源管理" class="headerlink" title="3. 资源管理"></a>3. 资源管理</h3><h4 id="3-1-资源管理介绍"><a href="#3-1-资源管理介绍" class="headerlink" title="3.1 资源管理介绍"></a>3.1 资源管理介绍</h4><p>在kubernetes中，所有的内容都抽象为资源，用户需要通过操作资源来管理kubernetes。</p>
<blockquote>
<p>kubernetes的本质上就是一个集群系统，用户可以在集群中部署各种服务，所谓的部署服务，其实就是在kubernetes集群中运行一个个的容器，并将指定的程序跑在容器中。</p>
<p>kubernetes的最小管理单元是pod而不是容器，所以只能将容器放在<code>Pod</code>中，而kubernetes一般也不会直接管理Pod，而是通过<code>Pod控制器</code>来管理Pod的。</p>
<p>Pod可以提供服务之后，就要考虑如何访问Pod中服务，kubernetes提供了<code>Service</code>资源实现这个功能。</p>
<p>当然，如果Pod中程序的数据需要持久化，kubernetes还提供了各种<code>存储</code>系统。</p>
</blockquote>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200406225334627-165356431070868.png" alt="image-20200406225334627"></p>
<blockquote>
<p>学习kubernetes的核心，就是学习如何对集群上的<code>Pod、Pod控制器、Service、存储</code>等各种资源进行操作</p>
</blockquote>
<h4 id="3-2-YAML语言介绍"><a href="#3-2-YAML语言介绍" class="headerlink" title="3.2 YAML语言介绍"></a>3.2 YAML语言介绍</h4><p>YAML是一个类似 XML、JSON 的标记性语言。它强调以<strong>数据</strong>为中心，并不是以标识语言为重点。因而YAML本身的定义比较简单，号称”一种人性化的数据格式语言”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;heima&gt;</span><br><span class="line">    &lt;age&gt;15&lt;/age&gt;</span><br><span class="line">    &lt;address&gt;Beijing&lt;/address&gt;</span><br><span class="line">&lt;/heima&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">heima:</span><br><span class="line">  age: 15</span><br><span class="line">  address: Beijing</span><br></pre></td></tr></table></figure>

<p>YAML的语法比较简单，主要有下面几个：</p>
<ul>
<li>大小写敏感</li>
<li>使用缩进表示层级关系</li>
<li>缩进不允许使用tab，只允许空格( 低版本限制 )</li>
<li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li>
<li>‘#’表示注释</li>
</ul>
<p>YAML支持以下几种数据类型：</p>
<ul>
<li>纯量：单个的、不可再分的值</li>
<li>对象：键值对的集合，又称为映射（mapping）&#x2F; 哈希（hash） &#x2F; 字典（dictionary）</li>
<li>数组：一组按次序排列的值，又称为序列（sequence） &#x2F; 列表（list）</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 纯量, 就是指的一个简单的值，字符串、布尔值、整数、浮点数、Null、时间、日期</span></span><br><span class="line"><span class="comment"># 1 布尔类型</span></span><br><span class="line"><span class="attr">c1:</span> <span class="literal">true</span> <span class="string">(或者True)</span></span><br><span class="line"><span class="comment"># 2 整型</span></span><br><span class="line"><span class="attr">c2:</span> <span class="number">234</span></span><br><span class="line"><span class="comment"># 3 浮点型</span></span><br><span class="line"><span class="attr">c3:</span> <span class="number">3.14</span></span><br><span class="line"><span class="comment"># 4 null类型 </span></span><br><span class="line"><span class="attr">c4:</span> <span class="string">~</span>  <span class="comment"># 使用~表示null</span></span><br><span class="line"><span class="comment"># 5 日期类型</span></span><br><span class="line"><span class="attr">c5:</span> <span class="number">2018-02-17</span>    <span class="comment"># 日期必须使用ISO 8601格式，即yyyy-MM-dd</span></span><br><span class="line"><span class="comment"># 6 时间类型</span></span><br><span class="line"><span class="attr">c6:</span> <span class="number">2018-02-17T15:02:31+08:00</span>  <span class="comment"># 时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区</span></span><br><span class="line"><span class="comment"># 7 字符串类型</span></span><br><span class="line"><span class="attr">c7:</span> <span class="string">heima</span>     <span class="comment"># 简单写法，直接写值 , 如果字符串中间有特殊字符，必须使用双引号或者单引号包裹 </span></span><br><span class="line"><span class="attr">c8:</span> <span class="string">line1</span></span><br><span class="line">    <span class="string">line2</span>     <span class="comment"># 字符串过多的情况可以拆成多行，每一行会被转化成一个空格</span></span><br></pre></td></tr></table></figure>



<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对象</span></span><br><span class="line"><span class="comment"># 形式一(推荐):</span></span><br><span class="line"><span class="attr">heima:</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">15</span></span><br><span class="line">  <span class="attr">address:</span> <span class="string">Beijing</span></span><br><span class="line"><span class="comment"># 形式二(了解):</span></span><br><span class="line"><span class="attr">heima:</span> &#123;<span class="attr">age:</span> <span class="number">15</span>,<span class="attr">address:</span> <span class="string">Beijing</span>&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数组</span></span><br><span class="line"><span class="comment"># 形式一(推荐):</span></span><br><span class="line"><span class="attr">address:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">顺义</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">昌平</span>  </span><br><span class="line"><span class="comment"># 形式二(了解):</span></span><br><span class="line"><span class="attr">address:</span> [<span class="string">顺义</span>,<span class="string">昌平</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小提示：</p>
<p>1 书写yaml切记<code>:</code> 后面要加一个空格</p>
<p>2 如果需要将多段yaml配置放在一个文件中，中间要使用<code>---</code>分隔</p>
<p>3 下面是一个yaml转json的网站，可以通过它验证yaml是否书写正确</p>
<p><a href="https://www.json2yaml.com/convert-yaml-to-json">https://www.json2yaml.com/convert-yaml-to-json</a></p>
</blockquote>
<h4 id="3-3-资源管理方式"><a href="#3-3-资源管理方式" class="headerlink" title="3.3 资源管理方式"></a>3.3 资源管理方式</h4><ul>
<li><p>命令式对象管理：直接使用命令去操作kubernetes资源</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">kubectl run nginx<span class="literal">-pod</span> <span class="literal">--image</span>=nginx:<span class="number">1.17</span>.<span class="number">1</span> <span class="literal">--port</span>=<span class="number">80</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>命令式对象配置：通过命令配置和配置文件去操作kubernetes资源</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">kubectl create/patch <span class="operator">-f</span> nginx<span class="literal">-pod</span>.yaml</span><br></pre></td></tr></table></figure>
</li>
<li><p>声明式对象配置：通过apply命令和配置文件去操作kubernetes资源</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">kubectl apply <span class="operator">-f</span> nginx<span class="literal">-pod</span>.yaml</span><br></pre></td></tr></table></figure></li>
</ul>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">操作对象</th>
<th align="left">适用环境</th>
<th align="left">优点</th>
<th align="left">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">命令式对象管理</td>
<td align="left">对象</td>
<td align="left">测试</td>
<td align="left">简单</td>
<td align="left">只能操作活动对象，无法审计、跟踪</td>
</tr>
<tr>
<td align="left">命令式对象配置</td>
<td align="left">文件</td>
<td align="left">开发</td>
<td align="left">可以审计、跟踪</td>
<td align="left">项目大时，配置文件多，操作麻烦</td>
</tr>
<tr>
<td align="left">声明式对象配置</td>
<td align="left">目录</td>
<td align="left">开发</td>
<td align="left">支持目录操作</td>
<td align="left">意外情况下难以调试</td>
</tr>
</tbody></table>
<h5 id="3-3-1-命令式对象管理"><a href="#3-3-1-命令式对象管理" class="headerlink" title="3.3.1 命令式对象管理"></a>3.3.1 命令式对象管理</h5><p><strong>kubectl命令</strong></p>
<p>kubectl是kubernetes集群的命令行工具，通过它能够对集群本身进行管理，并能够在集群上进行容器化应用的安装部署。kubectl命令的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl [command] [type] [name] [flags]</span><br></pre></td></tr></table></figure>

<p><strong>comand</strong>：指定要对资源执行的操作，例如create、get、delete</p>
<p><strong>type</strong>：指定资源类型，比如deployment、pod、service</p>
<p><strong>name</strong>：指定资源的名称，名称大小写敏感</p>
<p><strong>flags</strong>：指定额外的可选参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有pod</span></span><br><span class="line">kubectl get pod </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看某个pod</span></span><br><span class="line">kubectl get pod pod_name</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看某个pod,以yaml格式展示结果</span></span><br><span class="line">kubectl get pod pod_name -o yaml</span><br></pre></td></tr></table></figure>

<p><strong>资源类型</strong></p>
<p>kubernetes中所有的内容都抽象为资源，可以通过下面的命令进行查看:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl api-resources</span><br></pre></td></tr></table></figure>

<p>经常使用的资源有下面这些：</p>
<table>
<thead>
<tr>
<th align="left">资源分类</th>
<th align="left">资源名称</th>
<th align="left">缩写</th>
<th align="left">资源作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">集群级别资源</td>
<td align="left">nodes</td>
<td align="left">no</td>
<td align="left">集群组成部分</td>
</tr>
<tr>
<td align="left">namespaces</td>
<td align="left">ns</td>
<td align="left">隔离Pod</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">pod资源</td>
<td align="left">pods</td>
<td align="left">po</td>
<td align="left">装载容器</td>
</tr>
<tr>
<td align="left">pod资源控制器</td>
<td align="left">replicationcontrollers</td>
<td align="left">rc</td>
<td align="left">控制pod资源</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">replicasets</td>
<td align="left">rs</td>
<td align="left">控制pod资源</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">deployments</td>
<td align="left">deploy</td>
<td align="left">控制pod资源</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">daemonsets</td>
<td align="left">ds</td>
<td align="left">控制pod资源</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">jobs</td>
<td align="left"></td>
<td align="left">控制pod资源</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">cronjobs</td>
<td align="left">cj</td>
<td align="left">控制pod资源</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">horizontalpodautoscalers</td>
<td align="left">hpa</td>
<td align="left">控制pod资源</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">statefulsets</td>
<td align="left">sts</td>
<td align="left">控制pod资源</td>
</tr>
<tr>
<td align="left">服务发现资源</td>
<td align="left">services</td>
<td align="left">svc</td>
<td align="left">统一pod对外接口</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">ingress</td>
<td align="left">ing</td>
<td align="left">统一pod对外接口</td>
</tr>
<tr>
<td align="left">存储资源</td>
<td align="left">volumeattachments</td>
<td align="left"></td>
<td align="left">存储</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">persistentvolumes</td>
<td align="left">pv</td>
<td align="left">存储</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">persistentvolumeclaims</td>
<td align="left">pvc</td>
<td align="left">存储</td>
</tr>
<tr>
<td align="left">配置资源</td>
<td align="left">configmaps</td>
<td align="left">cm</td>
<td align="left">配置</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">secrets</td>
<td align="left"></td>
<td align="left">配置</td>
</tr>
</tbody></table>
<p><strong>操作</strong></p>
<p>kubernetes允许对资源进行多种操作，可以通过–help查看详细的操作命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl --help</span><br></pre></td></tr></table></figure>

<p>经常使用的操作有下面这些：</p>
<table>
<thead>
<tr>
<th align="left">命令分类</th>
<th align="left">命令</th>
<th align="left">翻译</th>
<th align="left">命令作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">基本命令</td>
<td align="left">create</td>
<td align="left">创建</td>
<td align="left">创建一个资源</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">edit</td>
<td align="left">编辑</td>
<td align="left">编辑一个资源</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">get</td>
<td align="left">获取</td>
<td align="left">获取一个资源</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">patch</td>
<td align="left">更新</td>
<td align="left">更新一个资源</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">delete</td>
<td align="left">删除</td>
<td align="left">删除一个资源</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">explain</td>
<td align="left">解释</td>
<td align="left">展示资源文档</td>
</tr>
<tr>
<td align="left">运行和调试</td>
<td align="left">run</td>
<td align="left">运行</td>
<td align="left">在集群中运行一个指定的镜像</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">expose</td>
<td align="left">暴露</td>
<td align="left">暴露资源为Service</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">describe</td>
<td align="left">描述</td>
<td align="left">显示资源内部信息</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">logs</td>
<td align="left">日志输出容器在 pod 中的日志</td>
<td align="left">输出容器在 pod 中的日志</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">attach</td>
<td align="left">缠绕进入运行中的容器</td>
<td align="left">进入运行中的容器</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">exec</td>
<td align="left">执行容器中的一个命令</td>
<td align="left">执行容器中的一个命令</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">cp</td>
<td align="left">复制</td>
<td align="left">在Pod内外复制文件</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">rollout</td>
<td align="left">首次展示</td>
<td align="left">管理资源的发布</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">scale</td>
<td align="left">规模</td>
<td align="left">扩(缩)容Pod的数量</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">autoscale</td>
<td align="left">自动调整</td>
<td align="left">自动调整Pod的数量</td>
</tr>
<tr>
<td align="left">高级命令</td>
<td align="left">apply</td>
<td align="left">rc</td>
<td align="left">通过文件对资源进行配置</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">label</td>
<td align="left">标签</td>
<td align="left">更新资源上的标签</td>
</tr>
<tr>
<td align="left">其他命令</td>
<td align="left">cluster-info</td>
<td align="left">集群信息</td>
<td align="left">显示集群信息</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">version</td>
<td align="left">版本</td>
<td align="left">显示当前Server和Client的版本</td>
</tr>
</tbody></table>
<p>下面以一个namespace &#x2F; pod的创建和删除简单演示下命令的使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个namespace</span></span><br><span class="line">[root@master ~]# kubectl create namespace dev</span><br><span class="line">namespace/dev created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取namespace</span></span><br><span class="line">[root@master ~]# kubectl get ns</span><br><span class="line">NAME              STATUS   AGE</span><br><span class="line">default           Active   21h</span><br><span class="line">dev               Active   21s</span><br><span class="line">kube-node-lease   Active   21h</span><br><span class="line">kube-public       Active   21h</span><br><span class="line">kube-system       Active   21h</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在此namespace下创建并运行一个nginx的Pod</span></span><br><span class="line">[root@master ~]# kubectl run pod --image=nginx:latest -n dev</span><br><span class="line">kubectl run --generator=deployment/apps.v1 is DEPRECATED and will be removed in a future version. Use kubectl run --generator=run-pod/v1 or kubectl create instead.</span><br><span class="line">deployment.apps/pod created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看新创建的pod</span></span><br><span class="line">[root@master ~]# kubectl get pod -n dev</span><br><span class="line">NAME  READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod   1/1     Running   0          21s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除指定的pod</span></span><br><span class="line">[root@master ~]# kubectl delete pod pod-864f9875b9-pcw7x</span><br><span class="line">pod &quot;pod&quot; deleted</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除指定的namespace</span></span><br><span class="line">[root@master ~]# kubectl delete ns dev</span><br><span class="line">namespace &quot;dev&quot; deleted</span><br></pre></td></tr></table></figure>

<h3 id="3-3-2-命令式对象配置"><a href="#3-3-2-命令式对象配置" class="headerlink" title="3.3.2 命令式对象配置"></a>3.3.2 命令式对象配置</h3><p>命令式对象配置就是使用命令配合配置文件一起来操作kubernetes资源。</p>
<p>1） 创建一个nginxpod.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dev</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginxpod</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-containers</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br></pre></td></tr></table></figure>

<p>2）执行create命令，创建资源：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f nginxpod.yaml</span></span><br><span class="line">namespace/dev created</span><br><span class="line">pod/nginxpod created</span><br></pre></td></tr></table></figure>

<p>此时发现创建了两个资源对象，分别是namespace和pod</p>
<p>3）执行get命令，查看资源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]#  kubectl get -f nginxpod.yaml</span><br><span class="line">NAME            STATUS   AGE</span><br><span class="line">namespace/dev   Active   18s</span><br><span class="line"></span><br><span class="line">NAME            READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/nginxpod    1/1     Running   0          17s</span><br></pre></td></tr></table></figure>

<p>这样就显示了两个资源对象的信息</p>
<p>4）执行delete命令，删除资源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# kubectl delete -f nginxpod.yaml</span><br><span class="line">namespace &quot;dev&quot; deleted</span><br><span class="line">pod &quot;nginxpod&quot; deleted</span><br></pre></td></tr></table></figure>

<p>此时发现两个资源对象被删除了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">总结:</span><br><span class="line">    命令式对象配置的方式操作资源，可以简单的认为：命令  +  yaml配置文件（里面是命令需要的各种参数）</span><br></pre></td></tr></table></figure>

<h3 id="3-3-3-声明式对象配置"><a href="#3-3-3-声明式对象配置" class="headerlink" title="3.3.3 声明式对象配置"></a>3.3.3 声明式对象配置</h3><p>声明式对象配置跟命令式对象配置很相似，但是它只有一个命令apply。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">首先执行一次kubectl apply -f yaml文件，发现创建了资源</span></span><br><span class="line">[root@master ~]#  kubectl apply -f nginxpod.yaml</span><br><span class="line">namespace/dev created</span><br><span class="line">pod/nginxpod created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再次执行一次kubectl apply -f yaml文件，发现说资源没有变动</span></span><br><span class="line">[root@master ~]#  kubectl apply -f nginxpod.yaml</span><br><span class="line">namespace/dev unchanged</span><br><span class="line">pod/nginxpod unchanged</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">总结:</span><br><span class="line">    其实声明式对象配置就是使用apply描述一个资源最终的状态（在yaml中定义状态）</span><br><span class="line">    使用apply操作资源：</span><br><span class="line">        如果资源不存在，就创建，相当于 kubectl create</span><br><span class="line">        如果资源已存在，就更新，相当于 kubectl patch</span><br></pre></td></tr></table></figure>

<blockquote>
<p>扩展：kubectl可以在node节点上运行吗 ?</p>
</blockquote>
<p>kubectl的运行是需要进行配置的，它的配置文件是$HOME&#x2F;.kube，如果想要在node节点运行此命令，需要将master上的.kube文件复制到node节点上，即在master节点上执行下面操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp  -r  HOME/.kube   node1: HOME/</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用推荐: 三种方式应该怎么用 ?</p>
</blockquote>
<p>创建&#x2F;更新资源 使用声明式对象配置 kubectl apply -f XXX.yaml</p>
<p>删除资源 使用命令式对象配置 kubectl delete -f XXX.yaml</p>
<p>查询资源 使用命令式对象管理 kubectl get(describe) 资源名称</p>
<h3 id="4-实战入门"><a href="#4-实战入门" class="headerlink" title="4. 实战入门"></a>4. 实战入门</h3><p>本章节将介绍如何在kubernetes集群中部署一个nginx服务，并且能够对其进行访问。</p>
<h4 id="4-1-Namespace"><a href="#4-1-Namespace" class="headerlink" title="4.1 Namespace"></a>4.1 Namespace</h4><p>Namespace是kubernetes系统中的一种非常重要资源，它的主要作用是用来实现<strong>多套环境的资源隔离</strong>或者<strong>多租户的资源隔离</strong>。</p>
<p>默认情况下，kubernetes集群中的所有的Pod都是可以相互访问的。但是在实际中，可能不想让两个Pod之间进行互相的访问，那此时就可以将两个Pod划分到不同的namespace下。kubernetes通过将集群内部的资源分配到不同的Namespace中，可以形成逻辑上的”组”，以方便不同的组的资源进行隔离使用和管理。</p>
<p>可以通过kubernetes的授权机制，将不同的namespace交给不同租户进行管理，这样就实现了多租户的资源隔离。此时还能结合kubernetes的资源配额机制，限定不同租户能占用的资源，例如CPU使用量、内存使用量等等，来实现租户可用资源的管理。</p>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200407100850484-165356431070869.png" alt="image-20200407100850484"></p>
<p>kubernetes在集群启动之后，会默认创建几个namespace</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# kubectl  get namespace</span><br><span class="line">NAME              STATUS   AGE</span><br><span class="line">default           Active   45h     #  所有未指定Namespace的对象都会被分配在default命名空间</span><br><span class="line">kube-node-lease   Active   45h     #  集群节点之间的心跳维护，v1.13开始引入</span><br><span class="line">kube-public       Active   45h     #  此命名空间下的资源可以被所有人访问（包括未认证用户）</span><br><span class="line">kube-system       Active   45h     #  所有由Kubernetes系统创建的资源都处于这个命名空间</span><br></pre></td></tr></table></figure>

<p>下面来看namespace资源的具体操作：</p>
<h5 id="4-1-1-查看"><a href="#4-1-1-查看" class="headerlink" title="4.1.1 查看"></a>4.1.1 <strong>查看</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1 查看所有的ns  命令：kubectl get ns</span></span><br><span class="line">[root@master ~]# kubectl get ns</span><br><span class="line">NAME              STATUS   AGE</span><br><span class="line">default           Active   45h</span><br><span class="line">kube-node-lease   Active   45h</span><br><span class="line">kube-public       Active   45h     </span><br><span class="line">kube-system       Active   45h     </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2 查看指定的ns   命令：kubectl get ns ns名称</span></span><br><span class="line">[root@master ~]# kubectl get ns default</span><br><span class="line">NAME      STATUS   AGE</span><br><span class="line">default   Active   45h</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3 指定输出格式  命令：kubectl get ns ns名称  -o 格式参数</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kubernetes支持的格式有很多，比较常见的是wide、json、yaml</span></span><br><span class="line">[root@master ~]# kubectl get ns default -o yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Namespace</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: &quot;2021-05-08T04:44:16Z&quot;</span><br><span class="line">  name: default</span><br><span class="line">  resourceVersion: &quot;151&quot;</span><br><span class="line">  selfLink: /api/v1/namespaces/default</span><br><span class="line">  uid: 7405f73a-e486-43d4-9db6-145f1409f090</span><br><span class="line">spec:</span><br><span class="line">  finalizers:</span><br><span class="line">  - kubernetes</span><br><span class="line">status:</span><br><span class="line">  phase: Active</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4 查看ns详情  命令：kubectl describe ns ns名称</span></span><br><span class="line">[root@master ~]# kubectl describe ns default</span><br><span class="line">Name:         default</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Status:       Active  # Active 命名空间正在使用中  Terminating 正在删除命名空间</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ResourceQuota 针对namespace做的资源限制</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">LimitRange针对namespace中的每个组件做的资源限制</span></span><br><span class="line">No resource quota.</span><br><span class="line">No LimitRange resource.</span><br></pre></td></tr></table></figure>

<h5 id="4-1-2-创建"><a href="#4-1-2-创建" class="headerlink" title="4.1.2 创建"></a>4.1.2 <strong>创建</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建namespace</span></span><br><span class="line">[root@master ~]# kubectl create ns dev</span><br><span class="line">namespace/dev created</span><br></pre></td></tr></table></figure>

<h5 id="4-1-3-删除"><a href="#4-1-3-删除" class="headerlink" title="4.1.3 删除"></a>4.1.3 <strong>删除</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除namespace</span></span><br><span class="line">[root@master ~]# kubectl delete ns dev</span><br><span class="line">namespace &quot;dev&quot; deleted</span><br></pre></td></tr></table></figure>

<h5 id="4-1-4-配置方式"><a href="#4-1-4-配置方式" class="headerlink" title="4.1.4 配置方式"></a>4.1.4 <strong>配置方式</strong></h5><p>首先准备一个yaml文件：ns-dev.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure>

<p>然后就可以执行对应的创建和删除命令了：</p>
<p>创建：kubectl create -f ns-dev.yaml</p>
<p>删除：kubectl delete -f ns-dev.yaml</p>
<h4 id="4-2-Pod"><a href="#4-2-Pod" class="headerlink" title="4.2 Pod"></a>4.2 Pod</h4><p>Pod是kubernetes集群进行管理的最小单元，程序要运行必须部署在容器中，而容器必须存在于Pod中。</p>
<p>Pod可以认为是容器的封装，一个Pod中可以存在一个或者多个容器。</p>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200407121501907-165356431070870.png" alt="image-20200407121501907"></p>
<p>kubernetes在集群启动之后，集群中的各个组件也都是以Pod方式运行的。可以通过下面命令查看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# kubectl get pod -n kube-system</span><br><span class="line">NAMESPACE     NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">kube-system   coredns-6955765f44-68g6v         1/1     Running   0          2d1h</span><br><span class="line">kube-system   coredns-6955765f44-cs5r8         1/1     Running   0          2d1h</span><br><span class="line">kube-system   etcd-master                      1/1     Running   0          2d1h</span><br><span class="line">kube-system   kube-apiserver-master            1/1     Running   0          2d1h</span><br><span class="line">kube-system   kube-controller-manager-master   1/1     Running   0          2d1h</span><br><span class="line">kube-system   kube-flannel-ds-amd64-47r25      1/1     Running   0          2d1h</span><br><span class="line">kube-system   kube-flannel-ds-amd64-ls5lh      1/1     Running   0          2d1h</span><br><span class="line">kube-system   kube-proxy-685tk                 1/1     Running   0          2d1h</span><br><span class="line">kube-system   kube-proxy-87spt                 1/1     Running   0          2d1h</span><br><span class="line">kube-system   kube-scheduler-master            1/1     Running   0          2d1h</span><br></pre></td></tr></table></figure>

<h5 id="4-2-1-创建并运行"><a href="#4-2-1-创建并运行" class="headerlink" title="4.2.1 创建并运行"></a>4.2.1 创建并运行</h5><p>kubernetes没有提供单独运行Pod的命令，都是通过Pod控制器来实现的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令格式： kubectl run (pod控制器名称) [参数]</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--image  指定Pod的镜像</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--port   指定端口</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--namespace  指定namespace</span></span><br><span class="line">[root@master ~]# kubectl run nginx --image=nginx:latest --port=80 --namespace dev </span><br><span class="line">deployment.apps/nginx created</span><br></pre></td></tr></table></figure>

<h5 id="4-2-2-查看pod信息"><a href="#4-2-2-查看pod信息" class="headerlink" title="4.2.2 查看pod信息"></a>4.2.2 查看pod信息</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Pod基本信息</span></span><br><span class="line">[root@master ~]# kubectl get pods -n dev</span><br><span class="line">NAME    READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx   1/1     Running   0          43s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Pod的详细信息</span></span><br><span class="line">[root@master ~]# kubectl describe pod nginx -n dev</span><br><span class="line">Name:         nginx</span><br><span class="line">Namespace:    dev</span><br><span class="line">Priority:     0</span><br><span class="line">Node:         node1/192.168.5.4</span><br><span class="line">Start Time:   Wed, 08 May 2021 09:29:24 +0800</span><br><span class="line">Labels:       pod-template-hash=5ff7956ff6</span><br><span class="line">              run=nginx</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Status:       Running</span><br><span class="line">IP:           10.244.1.23</span><br><span class="line">IPs:</span><br><span class="line">  IP:           10.244.1.23</span><br><span class="line">Controlled By:  ReplicaSet/nginx</span><br><span class="line">Containers:</span><br><span class="line">  nginx:</span><br><span class="line">    Container ID:   docker://4c62b8c0648d2512380f4ffa5da2c99d16e05634979973449c98e9b829f6253c</span><br><span class="line">    Image:          nginx:latest</span><br><span class="line">    Image ID:       docker-pullable://nginx@sha256:485b610fefec7ff6c463ced9623314a04ed67e3945b9c08d7e53a47f6d108dc7</span><br><span class="line">    Port:           80/TCP</span><br><span class="line">    Host Port:      0/TCP</span><br><span class="line">    State:          Running</span><br><span class="line">      Started:      Wed, 08 May 2021 09:30:01 +0800</span><br><span class="line">    Ready:          True</span><br><span class="line">    Restart Count:  0</span><br><span class="line">    Environment:    &lt;none&gt;</span><br><span class="line">    Mounts:</span><br><span class="line">      /var/run/secrets/kubernetes.io/serviceaccount from default-token-hwvvw (ro)</span><br><span class="line">Conditions:</span><br><span class="line">  Type              Status</span><br><span class="line">  Initialized       True</span><br><span class="line">  Ready             True</span><br><span class="line">  ContainersReady   True</span><br><span class="line">  PodScheduled      True</span><br><span class="line">Volumes:</span><br><span class="line">  default-token-hwvvw:</span><br><span class="line">    Type:        Secret (a volume populated by a Secret)</span><br><span class="line">    SecretName:  default-token-hwvvw</span><br><span class="line">    Optional:    false</span><br><span class="line">QoS Class:       BestEffort</span><br><span class="line">Node-Selectors:  &lt;none&gt;</span><br><span class="line">Tolerations:     node.kubernetes.io/not-ready:NoExecute for 300s</span><br><span class="line">                 node.kubernetes.io/unreachable:NoExecute for 300s</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason     Age        From               Message</span><br><span class="line">  ----    ------     ----       ----               -------</span><br><span class="line">  Normal  Scheduled  &lt;unknown&gt;  default-scheduler  Successfully assigned dev/nginx-5ff7956ff6-fg2db to node1</span><br><span class="line">  Normal  Pulling    4m11s      kubelet, node1     Pulling image &quot;nginx:latest&quot;</span><br><span class="line">  Normal  Pulled     3m36s      kubelet, node1     Successfully pulled image &quot;nginx:latest&quot;</span><br><span class="line">  Normal  Created    3m36s      kubelet, node1     Created container nginx</span><br><span class="line">  Normal  Started    3m36s      kubelet, node1     Started container nginx</span><br></pre></td></tr></table></figure>

<h5 id="4-2-3-访问Pod"><a href="#4-2-3-访问Pod" class="headerlink" title="4.2.3 访问Pod"></a>4.2.3 访问Pod</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取podIP</span></span><br><span class="line">[root@master ~]# kubectl get pods -n dev -o wide</span><br><span class="line">NAME    READY   STATUS    RESTARTS   AGE    IP             NODE    ... </span><br><span class="line">nginx   1/1     Running   0          190s   10.244.1.23   node1   ...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">访问POD</span></span><br><span class="line">[root@master ~]# curl http://10.244.1.23:80</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-4-删除指定Pod"><a href="#4-2-4-删除指定Pod" class="headerlink" title="4.2.4 删除指定Pod"></a>4.2.4 删除指定Pod</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除指定Pod</span></span><br><span class="line">[root@master ~]# kubectl delete pod nginx -n dev</span><br><span class="line">pod &quot;nginx&quot; deleted</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此时，显示删除Pod成功，但是再查询，发现又新产生了一个</span> </span><br><span class="line">[root@master ~]# kubectl get pods -n dev</span><br><span class="line">NAME    READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx   1/1     Running   0          21s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这是因为当前Pod是由Pod控制器创建的，控制器会监控Pod状况，一旦发现Pod死亡，会立即重建</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此时要想删除Pod，必须删除Pod控制器</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先来查询一下当前namespace下的Pod控制器</span></span><br><span class="line">[root@master ~]# kubectl get deploy -n  dev</span><br><span class="line">NAME    READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx   1/1     1            1           9m7s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">接下来，删除此PodPod控制器</span></span><br><span class="line">[root@master ~]# kubectl delete deploy nginx -n dev</span><br><span class="line">deployment.apps &quot;nginx&quot; deleted</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">稍等片刻，再查询Pod，发现Pod被删除了</span></span><br><span class="line">[root@master ~]# kubectl get pods -n dev</span><br><span class="line">No resources found in dev namespace.</span><br></pre></td></tr></table></figure>

<h5 id="4-2-5-配置操作"><a href="#4-2-5-配置操作" class="headerlink" title="4.2.5 配置操作"></a>4.2.5 配置操作</h5><p>创建一个pod-nginx.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">pod</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>

<p>然后就可以执行对应的创建和删除命令了：</p>
<p>创建：kubectl create -f pod-nginx.yaml</p>
<p>删除：kubectl delete -f pod-nginx.yaml</p>
<h4 id="4-3-Label"><a href="#4-3-Label" class="headerlink" title="4.3 Label"></a>4.3 Label</h4><p>Label是kubernetes系统中的一个重要概念。它的作用就是在资源上添加标识，用来对它们进行区分和选择。</p>
<p>Label的特点：</p>
<ul>
<li>一个Label会以key&#x2F;value键值对的形式附加到各种对象上，如Node、Pod、Service等等</li>
<li>一个资源对象可以定义任意数量的Label ，同一个Label也可以被添加到任意数量的资源对象上去</li>
<li>Label通常在资源对象定义时确定，当然也可以在对象创建后动态添加或者删除</li>
</ul>
<p>可以通过Label实现资源的多维度分组，以便灵活、方便地进行资源分配、调度、配置、部署等管理工作。</p>
<blockquote>
<p>一些常用的Label 示例如下：</p>
<ul>
<li>版本标签：”version”:”release”, “version”:”stable”……</li>
<li>环境标签：”environment”:”dev”，”environment”:”test”，”environment”:”pro”</li>
<li>架构标签：”tier”:”frontend”，”tier”:”backend”</li>
</ul>
</blockquote>
<p>标签定义完毕之后，还要考虑到标签的选择，这就要使用到Label Selector，即：</p>
<p>Label用于给某个资源对象定义标识</p>
<p>Label Selector用于查询和筛选拥有某些标签的资源对象</p>
<p>当前有两种Label Selector：</p>
<ul>
<li><p>基于等式的Label Selector</p>
<p>name &#x3D; slave: 选择所有包含Label中key&#x3D;”name”且value&#x3D;”slave”的对象</p>
<p>env !&#x3D; production: 选择所有包括Label中的key&#x3D;”env”且value不等于”production”的对象</p>
</li>
<li><p>基于集合的Label Selector</p>
<p>name in (master, slave): 选择所有包含Label中的key&#x3D;”name”且value&#x3D;”master”或”slave”的对象</p>
<p>name not in (frontend): 选择所有包含Label中的key&#x3D;”name”且value不等于”frontend”的对象</p>
</li>
</ul>
<p>标签的选择条件可以使用多个，此时将多个Label Selector进行组合，使用逗号”,”进行分隔即可。例如：</p>
<p>name&#x3D;slave，env!&#x3D;production</p>
<p>name not in (frontend)，env!&#x3D;production</p>
<h5 id="4-3-1-命令方式"><a href="#4-3-1-命令方式" class="headerlink" title="4.3.1 命令方式"></a>4.3.1 命令方式</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为pod资源打标签</span></span><br><span class="line">[root@master ~]# kubectl label pod nginx-pod version=1.0 -n dev</span><br><span class="line">pod/nginx-pod labeled</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为pod资源更新标签</span></span><br><span class="line">[root@master ~]# kubectl label pod nginx-pod version=2.0 -n dev --overwrite</span><br><span class="line">pod/nginx-pod labeled</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看标签</span></span><br><span class="line">[root@master ~]# kubectl get pod nginx-pod  -n dev --show-labels</span><br><span class="line">NAME        READY   STATUS    RESTARTS   AGE   LABELS</span><br><span class="line">nginx-pod   1/1     Running   0          10m   version=2.0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">筛选标签</span></span><br><span class="line">[root@master ~]# kubectl get pod -n dev -l version=2.0  --show-labels</span><br><span class="line">NAME        READY   STATUS    RESTARTS   AGE   LABELS</span><br><span class="line">nginx-pod   1/1     Running   0          17m   version=2.0</span><br><span class="line">[root@master ~]# kubectl get pod -n dev -l version!=2.0 --show-labels</span><br><span class="line">No resources found in dev namespace.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除标签</span></span><br><span class="line">[root@master ~]# kubectl label pod nginx-pod version- -n dev</span><br><span class="line">pod/nginx-pod labeled</span><br></pre></td></tr></table></figure>

<h5 id="4-3-2-配置方式"><a href="#4-3-2-配置方式" class="headerlink" title="4.3.2 配置方式"></a>4.3.2 配置方式</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">&quot;3.0&quot;</span> </span><br><span class="line">    <span class="attr">env:</span> <span class="string">&quot;test&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">pod</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>

<p>然后就可以执行对应的更新命令了：kubectl apply -f pod-nginx.yaml</p>
<h4 id="4-4-Deployment"><a href="#4-4-Deployment" class="headerlink" title="4.4 Deployment"></a>4.4 Deployment</h4><p>在kubernetes中，Pod是最小的控制单元，但是kubernetes很少直接控制Pod，一般都是通过Pod控制器来完成的。Pod控制器用于pod的管理，确保pod资源符合预期的状态，当pod的资源出现故障时，会尝试进行重启或重建pod。</p>
<p>在kubernetes中Pod控制器的种类有很多，本章节只介绍一种：Deployment。</p>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200408193950807-165356431070871.png" alt="image-20200408193950807"></p>
<h5 id="4-4-1-命令操作"><a href="#4-4-1-命令操作" class="headerlink" title="4.4.1 命令操作"></a>4.4.1 命令操作</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令格式: kubectl create deployment 名称  [参数]</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--image  指定pod的镜像</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--port   指定端口</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--replicas  指定创建pod数量</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--namespace  指定namespace</span></span><br><span class="line">[root@master ~]# kubectl run nginx --image=nginx:latest --port=80 --replicas=3 -n dev</span><br><span class="line">deployment.apps/nginx created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看创建的Pod</span></span><br><span class="line">[root@master ~]# kubectl get pods -n dev</span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-5ff7956ff6-6k8cb   1/1     Running   0          19s</span><br><span class="line">nginx-5ff7956ff6-jxfjt   1/1     Running   0          19s</span><br><span class="line">nginx-5ff7956ff6-v6jqw   1/1     Running   0          19s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看deployment的信息</span></span><br><span class="line">[root@master ~]# kubectl get deploy -n dev</span><br><span class="line">NAME    READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx   3/3     3            3           2m42s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">UP-TO-DATE：成功升级的副本数量</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">AVAILABLE：可用副本的数量</span></span><br><span class="line">[root@master ~]# kubectl get deploy -n dev -o wide</span><br><span class="line">NAME    READY UP-TO-DATE  AVAILABLE   AGE     CONTAINERS   IMAGES              SELECTOR</span><br><span class="line">nginx   3/3     3         3           2m51s   nginx        nginx:latest        run=nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看deployment的详细信息</span></span><br><span class="line">[root@master ~]# kubectl describe deploy nginx -n dev</span><br><span class="line">Name:                   nginx</span><br><span class="line">Namespace:              dev</span><br><span class="line">CreationTimestamp:      Wed, 08 May 2021 11:14:14 +0800</span><br><span class="line">Labels:                 run=nginx</span><br><span class="line">Annotations:            deployment.kubernetes.io/revision: 1</span><br><span class="line">Selector:               run=nginx</span><br><span class="line">Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable</span><br><span class="line">StrategyType:           RollingUpdate</span><br><span class="line">MinReadySeconds:        0</span><br><span class="line">RollingUpdateStrategy:  25% max unavailable, 25% max surge</span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:  run=nginx</span><br><span class="line">  Containers:</span><br><span class="line">   nginx:</span><br><span class="line">    Image:        nginx:latest</span><br><span class="line">    Port:         80/TCP</span><br><span class="line">    Host Port:    0/TCP</span><br><span class="line">    Environment:  &lt;none&gt;</span><br><span class="line">    Mounts:       &lt;none&gt;</span><br><span class="line">  Volumes:        &lt;none&gt;</span><br><span class="line">Conditions:</span><br><span class="line">  Type           Status  Reason</span><br><span class="line">  ----           ------  ------</span><br><span class="line">  Available      True    MinimumReplicasAvailable</span><br><span class="line">  Progressing    True    NewReplicaSetAvailable</span><br><span class="line">OldReplicaSets:  &lt;none&gt;</span><br><span class="line">NewReplicaSet:   nginx-5ff7956ff6 (3/3 replicas created)</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason             Age    From                   Message</span><br><span class="line">  ----    ------             ----   ----                   -------</span><br><span class="line">  Normal  ScalingReplicaSet  5m43s  deployment-controller  Scaled up replicaset nginx-5ff7956ff6 to 3</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除</span> </span><br><span class="line">[root@master ~]# kubectl delete deploy nginx -n dev</span><br><span class="line">deployment.apps &quot;nginx&quot; deleted</span><br></pre></td></tr></table></figure>

<h5 id="4-4-2-配置操作"><a href="#4-4-2-配置操作" class="headerlink" title="4.4.2 配置操作"></a>4.4.2 配置操作</h5><p>创建一个deploy-nginx.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>

<p>然后就可以执行对应的创建和删除命令了：</p>
<p>创建：kubectl create -f deploy-nginx.yaml</p>
<p>删除：kubectl delete -f deploy-nginx.yaml</p>
<h4 id="4-5-Service"><a href="#4-5-Service" class="headerlink" title="4.5 Service"></a>4.5 Service</h4><p>通过上节课的学习，已经能够利用Deployment来创建一组Pod来提供具有高可用性的服务。</p>
<p>虽然每个Pod都会分配一个单独的Pod IP，然而却存在如下两问题：</p>
<ul>
<li>Pod IP 会随着Pod的重建产生变化</li>
<li>Pod IP 仅仅是集群内可见的虚拟IP，外部无法访问</li>
</ul>
<p>这样对于访问这个服务带来了难度。因此，kubernetes设计了Service来解决这个问题。</p>
<p>Service可以看作是一组同类Pod<strong>对外的访问接口</strong>。借助Service，应用可以方便地实现服务发现和负载均衡。</p>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200408194716912-165356431070872.png" alt="image-20200408194716912"></p>
<h5 id="4-5-1-创建集群内部可访问的Service"><a href="#4-5-1-创建集群内部可访问的Service" class="headerlink" title="4.5.1 创建集群内部可访问的Service"></a>4.5.1 创建集群内部可访问的Service</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">暴露Service</span></span><br><span class="line">[root@master ~]# kubectl expose deploy nginx --name=svc-nginx1 --type=ClusterIP --port=80 --target-port=80 -n dev</span><br><span class="line">service/svc-nginx1 exposed</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看service</span></span><br><span class="line">[root@master ~]# kubectl get svc svc-nginx1 -n dev -o wide</span><br><span class="line">NAME         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE     SELECTOR</span><br><span class="line">svc-nginx1   ClusterIP   10.109.179.231   &lt;none&gt;        80/TCP    3m51s   run=nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里产生了一个CLUSTER-IP，这就是service的IP，在Service的生命周期中，这个地址是不会变动的</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以通过这个IP访问当前service对应的POD</span></span><br><span class="line">[root@master ~]# curl 10.109.179.231:80</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">.......</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h5 id="4-5-2-创建集群外部也可访问的Service"><a href="#4-5-2-创建集群外部也可访问的Service" class="headerlink" title="4.5.2 创建集群外部也可访问的Service"></a>4.5.2 创建集群外部也可访问的Service</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上面创建的Service的<span class="built_in">type</span>类型为ClusterIP，这个ip地址只用集群内部可访问</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果需要创建外部也可以访问的Service，需要修改<span class="built_in">type</span>为NodePort</span></span><br><span class="line">[root@master ~]# kubectl expose deploy nginx --name=svc-nginx2 --type=NodePort --port=80 --target-port=80 -n dev</span><br><span class="line">service/svc-nginx2 exposed</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此时查看，会发现出现了NodePort类型的Service，而且有一对Port（80:31928/TC）</span></span><br><span class="line">[root@master ~]# kubectl get svc  svc-nginx2  -n dev -o wide</span><br><span class="line">NAME          TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE    SELECTOR</span><br><span class="line">svc-nginx2    NodePort    10.100.94.0      &lt;none&gt;        80:31928/TCP   9s     run=nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">接下来就可以通过集群外的主机访问 节点IP:31928访问服务了</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例如在的电脑主机上通过浏览器访问下面的地址</span></span><br><span class="line">http://192.168.90.100:31928/</span><br></pre></td></tr></table></figure>

<h5 id="4-5-3-删除Service"><a href="#4-5-3-删除Service" class="headerlink" title="4.5.3 删除Service"></a>4.5.3 删除Service</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# kubectl delete svc svc-nginx-1 -n dev </span><br><span class="line">service &quot;svc-nginx-1&quot; deleted</span><br></pre></td></tr></table></figure>

<h5 id="4-5-4-配置方式"><a href="#4-5-4-配置方式" class="headerlink" title="4.5.4 配置方式"></a>4.5.4 配置方式</h5><p>创建一个svc-nginx.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">svc-nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="number">10.109</span><span class="number">.179</span><span class="number">.231</span> <span class="comment">#固定svc的内网ip</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br></pre></td></tr></table></figure>

<p>然后就可以执行对应的创建和删除命令了：</p>
<p>创建：kubectl create -f svc-nginx.yaml</p>
<p>删除：kubectl delete -f svc-nginx.yaml</p>
<blockquote>
<p><strong>小结</strong></p>
<p>至此，已经掌握了Namespace、Pod、Deployment、Service资源的基本操作，有了这些操作，就可以在kubernetes集群中实现一个服务的简单部署和访问了，但是如果想要更好的使用kubernetes，就需要深入学习这几种资源的细节和原理。</p>
</blockquote>
<h3 id="5-Pod详解"><a href="#5-Pod详解" class="headerlink" title="5. Pod详解"></a>5. Pod详解</h3><h4 id="5-1-Pod介绍"><a href="#5-1-Pod介绍" class="headerlink" title="5.1 Pod介绍"></a>5.1 Pod介绍</h4><h5 id="5-1-1-Pod结构"><a href="#5-1-1-Pod结构" class="headerlink" title="5.1.1 Pod结构"></a>5.1.1 Pod结构</h5><p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200407121501907-1626781151898-165356431070873.png" alt="image-20200407121501907"></p>
<p>每个Pod中都可以包含一个或者多个容器，这些容器可以分为两类：</p>
<ul>
<li><p>用户程序所在的容器，数量可多可少</p>
</li>
<li><p>Pause容器，这是每个Pod都会有的一个<strong>根容器</strong>，它的作用有两个：</p>
<ul>
<li><p>可以以它为依据，评估整个Pod的健康状态</p>
</li>
<li><p>可以在根容器上设置Ip地址，其它容器都此Ip（Pod IP），以实现Pod内部的网路通信</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这里是Pod内部的通讯，Pod的之间的通讯采用虚拟二层网络技术来实现，我们当前环境用的是Flannel</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h5 id="5-1-2-Pod定义"><a href="#5-1-2-Pod定义" class="headerlink" title="5.1.2 Pod定义"></a>5.1.2 Pod定义</h5><p>下面是Pod的资源清单：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1     #必选，版本号，例如v1</span><br><span class="line">kind: Pod       　 #必选，资源类型，例如 Pod</span><br><span class="line">metadata:       　 #必选，元数据</span><br><span class="line">  name: string     #必选，Pod名称</span><br><span class="line">  namespace: string  #Pod所属的命名空间,默认为&quot;default&quot;</span><br><span class="line">  labels:       　　  #自定义标签列表</span><br><span class="line">    - name: string      　          </span><br><span class="line">spec:  #必选，Pod中容器的详细定义</span><br><span class="line">  containers:  #必选，Pod中容器列表</span><br><span class="line">  - name: string   #必选，容器名称</span><br><span class="line">    image: string  #必选，容器的镜像名称</span><br><span class="line">    imagePullPolicy: [ Always|Never|IfNotPresent ]  #获取镜像的策略 </span><br><span class="line">    command: [string]   #容器的启动命令列表，如不指定，使用打包时使用的启动命令</span><br><span class="line">    args: [string]      #容器的启动命令参数列表</span><br><span class="line">    workingDir: string  #容器的工作目录</span><br><span class="line">    volumeMounts:       #挂载到容器内部的存储卷配置</span><br><span class="line">    - name: string      #引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名</span><br><span class="line">      mountPath: string #存储卷在容器内mount的绝对路径，应少于512字符</span><br><span class="line">      readOnly: boolean #是否为只读模式</span><br><span class="line">    ports: #需要暴露的端口库号列表</span><br><span class="line">    - name: string        #端口的名称</span><br><span class="line">      containerPort: int  #容器需要监听的端口号</span><br><span class="line">      hostPort: int       #容器所在主机需要监听的端口号，默认与Container相同</span><br><span class="line">      protocol: string    #端口协议，支持TCP和UDP，默认TCP</span><br><span class="line">    env:   #容器运行前需设置的环境变量列表</span><br><span class="line">    - name: string  #环境变量名称</span><br><span class="line">      value: string #环境变量的值</span><br><span class="line">    resources: #资源限制和请求的设置</span><br><span class="line">      limits:  #资源限制的设置</span><br><span class="line">        cpu: string     #Cpu的限制，单位为core数，将用于docker run --cpu-shares参数</span><br><span class="line">        memory: string  #内存限制，单位可以为Mib/Gib，将用于docker run --memory参数</span><br><span class="line">      requests: #资源请求的设置</span><br><span class="line">        cpu: string    #Cpu请求，容器启动的初始可用数量</span><br><span class="line">        memory: string #内存请求,容器启动的初始可用数量</span><br><span class="line">    lifecycle: #生命周期钩子</span><br><span class="line">        postStart: #容器启动后立即执行此钩子,如果执行失败,会根据重启策略进行重启</span><br><span class="line">        preStop: #容器终止前执行此钩子,无论结果如何,容器都会终止</span><br><span class="line">    livenessProbe:  #对Pod内各容器健康检查的设置，当探测无响应几次后将自动重启该容器</span><br><span class="line">      exec:       　 #对Pod容器内检查方式设置为exec方式</span><br><span class="line">        command: [string]  #exec方式需要制定的命令或脚本</span><br><span class="line">      httpGet:       #对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port</span><br><span class="line">        path: string</span><br><span class="line">        port: number</span><br><span class="line">        host: string</span><br><span class="line">        scheme: string</span><br><span class="line">        HttpHeaders:</span><br><span class="line">        - name: string</span><br><span class="line">          value: string</span><br><span class="line">      tcpSocket:     #对Pod内个容器健康检查方式设置为tcpSocket方式</span><br><span class="line">         port: number</span><br><span class="line">       initialDelaySeconds: 0       #容器启动完成后首次探测的时间，单位为秒</span><br><span class="line">       timeoutSeconds: 0    　　    #对容器健康检查探测等待响应的超时时间，单位秒，默认1秒</span><br><span class="line">       periodSeconds: 0     　　    #对容器监控检查的定期探测时间设置，单位秒，默认10秒一次</span><br><span class="line">       successThreshold: 0</span><br><span class="line">       failureThreshold: 0</span><br><span class="line">       securityContext:</span><br><span class="line">         privileged: false</span><br><span class="line">  restartPolicy: [Always | Never | OnFailure]  #Pod的重启策略</span><br><span class="line">  nodeName: &lt;string&gt; #设置NodeName表示将该Pod调度到指定到名称的node节点上</span><br><span class="line">  nodeSelector: obeject #设置NodeSelector表示将该Pod调度到包含这个label的node上</span><br><span class="line">  imagePullSecrets: #Pull镜像时使用的secret名称，以key：secretkey格式指定</span><br><span class="line">  - name: string</span><br><span class="line">  hostNetwork: false   #是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络</span><br><span class="line">  volumes:   #在该pod上定义共享存储卷列表</span><br><span class="line">  - name: string    #共享存储卷名称 （volumes类型有很多种）</span><br><span class="line">    emptyDir: &#123;&#125;       #类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值</span><br><span class="line">    hostPath: string   #类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录</span><br><span class="line">      path: string      　　        #Pod所在宿主机的目录，将被用于同期中mount的目录</span><br><span class="line">    secret:       　　　#类型为secret的存储卷，挂载集群与定义的secret对象到容器内部</span><br><span class="line">      scretname: string  </span><br><span class="line">      items:     </span><br><span class="line">      - key: string</span><br><span class="line">        path: string</span><br><span class="line">    configMap:         #类型为configMap的存储卷，挂载预定义的configMap对象到容器内部</span><br><span class="line">      name: string</span><br><span class="line">      items:</span><br><span class="line">      - key: string</span><br><span class="line">        path: string</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">小提示：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  在这里，可通过一个命令来查看每种资源的可配置项</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  kubectl explain 资源类型         查看某种资源可以配置的一级属性</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  kubectl explain 资源类型.属性     查看属性的子属性</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl explain pod</span><br><span class="line">KIND:     Pod</span><br><span class="line">VERSION:  v1</span><br><span class="line">FIELDS:</span><br><span class="line">   apiVersion   &lt;string&gt;</span><br><span class="line">   kind &lt;string&gt;</span><br><span class="line">   metadata     &lt;Object&gt;</span><br><span class="line">   spec &lt;Object&gt;</span><br><span class="line">   status       &lt;Object&gt;</span><br><span class="line"></span><br><span class="line">[root@k8s-master01 ~]# kubectl explain pod.metadata</span><br><span class="line">KIND:     Pod</span><br><span class="line">VERSION:  v1</span><br><span class="line">RESOURCE: metadata &lt;Object&gt;</span><br><span class="line">FIELDS:</span><br><span class="line">   annotations  &lt;map[string]string&gt;</span><br><span class="line">   clusterName  &lt;string&gt;</span><br><span class="line">   creationTimestamp    &lt;string&gt;</span><br><span class="line">   deletionGracePeriodSeconds   &lt;integer&gt;</span><br><span class="line">   deletionTimestamp    &lt;string&gt;</span><br><span class="line">   finalizers   &lt;[]string&gt;</span><br><span class="line">   generateName &lt;string&gt;</span><br><span class="line">   generation   &lt;integer&gt;</span><br><span class="line">   labels       &lt;map[string]string&gt;</span><br><span class="line">   managedFields        &lt;[]Object&gt;</span><br><span class="line">   name &lt;string&gt;</span><br><span class="line">   namespace    &lt;string&gt;</span><br><span class="line">   ownerReferences      &lt;[]Object&gt;</span><br><span class="line">   resourceVersion      &lt;string&gt;</span><br><span class="line">   selfLink     &lt;string&gt;</span><br><span class="line">   uid  &lt;string&gt;</span><br></pre></td></tr></table></figure>

<p>在kubernetes中基本所有资源的一级属性都是一样的，主要包含5部分：</p>
<ul>
<li>apiVersion <string> 版本，由kubernetes内部定义，版本号必须可以用 kubectl api-versions 查询到</li>
<li>kind <string> 类型，由kubernetes内部定义，版本号必须可以用 kubectl api-resources 查询到</li>
<li>metadata <Object> 元数据，主要是资源标识和说明，常用的有name、namespace、labels等</li>
<li>spec <Object> 描述，这是配置中最重要的一部分，里面是对各种资源配置的详细描述</li>
<li>status <Object> 状态信息，里面的内容不需要定义，由kubernetes自动生成</li>
</ul>
<p>在上面的属性中，spec是接下来研究的重点，继续看下它的常见子属性:</p>
<ul>
<li>containers &lt;[]Object&gt; 容器列表，用于定义容器的详细信息</li>
<li>nodeName <String> 根据nodeName的值将pod调度到指定的Node节点上</li>
<li>nodeSelector &lt;map[]&gt; 根据NodeSelector中定义的信息选择将该Pod调度到包含这些label的Node 上</li>
<li>hostNetwork <boolean> 是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络</li>
<li>volumes &lt;[]Object&gt; 存储卷，用于定义Pod上面挂在的存储信息</li>
<li>restartPolicy <string> 重启策略，表示Pod在遇到故障的时候的处理策略</li>
</ul>
<h4 id="5-2-Pod配置"><a href="#5-2-Pod配置" class="headerlink" title="5.2 Pod配置"></a>5.2 Pod配置</h4><p>本小节主要来研究<code>pod.spec.containers</code>属性，这也是pod配置中最为关键的一项配置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-master01 ~]# kubectl explain pod.spec.containers</span><br><span class="line">KIND:     Pod</span><br><span class="line">VERSION:  v1</span><br><span class="line">RESOURCE: containers &lt;[]Object&gt;   # 数组，代表可以有多个容器</span><br><span class="line">FIELDS:</span><br><span class="line">   name  &lt;string&gt;     # 容器名称</span><br><span class="line">   image &lt;string&gt;     # 容器需要的镜像地址</span><br><span class="line">   imagePullPolicy  &lt;string&gt; # 镜像拉取策略 </span><br><span class="line">   command  &lt;[]string&gt; # 容器的启动命令列表，如不指定，使用打包时使用的启动命令</span><br><span class="line">   args     &lt;[]string&gt; # 容器的启动命令需要的参数列表</span><br><span class="line">   env      &lt;[]Object&gt; # 容器环境变量的配置</span><br><span class="line">   ports    &lt;[]Object&gt;     # 容器需要暴露的端口号列表</span><br><span class="line">   resources &lt;Object&gt;      # 资源限制和资源请求的设置</span><br></pre></td></tr></table></figure>

<h5 id="5-2-1-基本配置"><a href="#5-2-1-基本配置" class="headerlink" title="5.2.1 基本配置"></a>5.2.1 基本配置</h5><p>创建pod-base.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-base</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">heima</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br></pre></td></tr></table></figure>

<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20210617223823675-1626781695411-165356431070874.png" alt="image-20210617223823675"></p>
<p>上面定义了一个比较简单Pod的配置，里面有两个容器：</p>
<ul>
<li>nginx：用1.17.1版本的nginx镜像创建，（nginx是一个轻量级web容器）</li>
<li>busybox：用1.30版本的busybox镜像创建，（busybox是一个小巧的linux命令集合）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建Pod</span></span><br><span class="line">[root@k8s-master01 pod]# kubectl apply -f pod-base.yaml</span><br><span class="line">pod/pod-base created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Pod状况</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">READY 1/2 : 表示当前Pod中有2个容器，其中1个准备就绪，1个未就绪</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">RESTARTS  : 重启次数，因为有1个容器故障了，Pod一直在重启试图恢复它</span></span><br><span class="line">[root@k8s-master01 pod]# kubectl get pod -n dev</span><br><span class="line">NAME       READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod-base   1/2     Running   4          95s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以通过describe查看内部的详情</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此时已经运行起来了一个基本的Pod，虽然它暂时有问题</span></span><br><span class="line">[root@k8s-master01 pod]# kubectl describe pod pod-base -n dev</span><br></pre></td></tr></table></figure>

<h5 id="5-2-2-镜像拉取"><a href="#5-2-2-镜像拉取" class="headerlink" title="5.2.2 镜像拉取"></a>5.2.2 镜像拉取</h5><p>创建pod-imagepullpolicy.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-imagepullpolicy</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">Never</span> <span class="comment"># 用于设置镜像拉取策略</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br></pre></td></tr></table></figure>

<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20210617223923659-165356431070877.png" alt="image-20210617223923659"></p>
<p>imagePullPolicy，用于设置镜像拉取策略，kubernetes支持配置三种拉取策略：</p>
<ul>
<li>Always：总是从远程仓库拉取镜像（一直远程下载）</li>
<li>IfNotPresent：本地有则使用本地镜像，本地没有则从远程仓库拉取镜像（本地有就本地 本地没远程下载）</li>
<li>Never：只使用本地镜像，从不去远程仓库拉取，本地没有就报错 （一直使用本地）</li>
</ul>
<blockquote>
<p>默认值说明：</p>
<p>如果镜像tag为具体版本号， 默认策略是：IfNotPresent</p>
<p>如果镜像tag为：latest（最终版本） ，默认策略是always</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建Pod</span></span><br><span class="line">[root@k8s-master01 pod]# kubectl create -f pod-imagepullpolicy.yaml</span><br><span class="line">pod/pod-imagepullpolicy created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Pod详情</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此时明显可以看到nginx镜像有一步Pulling image <span class="string">&quot;nginx:1.17.1&quot;</span>的过程</span></span><br><span class="line">[root@k8s-master01 pod]# kubectl describe pod pod-imagepullpolicy -n dev</span><br><span class="line">......</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason     Age               From               Message</span><br><span class="line">  ----     ------     ----              ----               -------</span><br><span class="line">  Normal   Scheduled  &lt;unknown&gt;         default-scheduler  Successfully assigned dev/pod-imagePullPolicy to node1</span><br><span class="line">  Normal   Pulling    32s               kubelet, node1     Pulling image &quot;nginx:1.17.1&quot;</span><br><span class="line">  Normal   Pulled     26s               kubelet, node1     Successfully pulled image &quot;nginx:1.17.1&quot;</span><br><span class="line">  Normal   Created    26s               kubelet, node1     Created container nginx</span><br><span class="line">  Normal   Started    25s               kubelet, node1     Started container nginx</span><br><span class="line">  Normal   Pulled     7s (x3 over 25s)  kubelet, node1     Container image &quot;busybox:1.30&quot; already present on machine</span><br><span class="line">  Normal   Created    7s (x3 over 25s)  kubelet, node1     Created container busybox</span><br><span class="line">  Normal   Started    7s (x3 over 25s)  kubelet, node1     Started container busybox</span><br></pre></td></tr></table></figure>

<h5 id="5-2-3-启动命令"><a href="#5-2-3-启动命令" class="headerlink" title="5.2.3 启动命令"></a>5.2.3 启动命令</h5><p>在前面的案例中，一直有一个问题没有解决，就是的busybox容器一直没有成功运行，那么到底是什么原因导致这个容器的故障呢？</p>
<p>原来busybox并不是一个程序，而是类似于一个工具类的集合，kubernetes集群启动管理后，它会自动关闭。解决方法就是让其一直在运行，这就用到了command配置。</p>
<p>创建pod-command.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-command</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;touch /tmp/hello.txt;while true;do /bin/echo $(date +%T) &gt;&gt; /tmp/hello.txt; sleep 3; done;&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20210617224457945-165356431070875.png" alt="image-20210617224457945"></p>
<p>command，用于在pod中的容器初始化完毕之后运行一个命令。</p>
<blockquote>
<p>稍微解释下上面命令的意思：</p>
<p>“&#x2F;bin&#x2F;sh”,”-c”, 使用sh执行命令</p>
<p>touch &#x2F;tmp&#x2F;hello.txt; 创建一个&#x2F;tmp&#x2F;hello.txt 文件</p>
<p>while true;do &#x2F;bin&#x2F;echo $(date +%T) &gt;&gt; &#x2F;tmp&#x2F;hello.txt; sleep 3; done; 每隔3秒向文件中写入当前时间</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建Pod</span></span><br><span class="line">[root@k8s-master01 pod]# kubectl create  -f pod-command.yaml</span><br><span class="line">pod/pod-command created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Pod状态</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此时发现两个pod都正常运行了</span></span><br><span class="line">[root@k8s-master01 pod]# kubectl get pods pod-command -n dev</span><br><span class="line">NAME          READY   STATUS   RESTARTS   AGE</span><br><span class="line">pod-command   2/2     Runing   0          2s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入pod中的busybox容器，查看文件内容</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">补充一个命令: kubectl <span class="built_in">exec</span>  pod名称 -n 命名空间 -it -c 容器名称 /bin/sh  在容器内部执行命令</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用这个命令就可以进入某个容器的内部，然后进行相关操作了</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比如，可以查看txt文件的内容</span></span><br><span class="line">[root@k8s-master01 pod]# kubectl exec pod-command -n dev -it -c busybox /bin/sh</span><br><span class="line">/ # tail -f /tmp/hello.txt</span><br><span class="line">14:44:19</span><br><span class="line">14:44:22</span><br><span class="line">14:44:25</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">特别说明：</span><br><span class="line">    通过上面发现command已经可以完成启动命令和传递参数的功能，为什么这里还要提供一个args选项，用于传递参数呢?这其实跟docker有点关系，kubernetes中的command、args两项其实是实现覆盖Dockerfile中ENTRYPOINT的功能。</span><br><span class="line"> 1 如果command和args均没有写，那么用Dockerfile的配置。</span><br><span class="line"> 2 如果command写了，但args没有写，那么Dockerfile默认的配置会被忽略，执行输入的command</span><br><span class="line"> 3 如果command没写，但args写了，那么Dockerfile中配置的ENTRYPOINT的命令会被执行，使用当前args的参数</span><br><span class="line"> 4 如果command和args都写了，那么Dockerfile的配置被忽略，执行command并追加上args参数</span><br></pre></td></tr></table></figure>

<h5 id="5-2-4-环境变量"><a href="#5-2-4-环境变量" class="headerlink" title="5.2.4 环境变量"></a>5.2.4 环境变量</h5><p>创建pod-env.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-env</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;while true;do /bin/echo $(date +%T);sleep 60; done;&quot;</span>]</span><br><span class="line">    <span class="attr">env:</span> <span class="comment"># 设置环境变量列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;username&quot;</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">&quot;admin&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;password&quot;</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">&quot;123456&quot;</span></span><br></pre></td></tr></table></figure>

<p>env，环境变量，用于在pod中的容器设置环境变量。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建Pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-env.yaml</span><br><span class="line">pod/pod-env created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入容器，输出环境变量</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl exec pod-env -n dev -c busybox -it /bin/sh</span><br><span class="line">/ # echo $username</span><br><span class="line">admin</span><br><span class="line">/ # echo $password</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>

<p>这种方式不是很推荐，推荐将这些配置单独存储在配置文件中，这种方式将在后面介绍。</p>
<h5 id="5-2-5-端口设置"><a href="#5-2-5-端口设置" class="headerlink" title="5.2.5 端口设置"></a>5.2.5 端口设置</h5><p>本小节来介绍容器的端口设置，也就是containers的ports选项。</p>
<p>首先看下ports支持的子选项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-master01 ~]# kubectl explain pod.spec.containers.ports</span><br><span class="line">KIND:     Pod</span><br><span class="line">VERSION:  v1</span><br><span class="line">RESOURCE: ports &lt;[]Object&gt;</span><br><span class="line">FIELDS:</span><br><span class="line">   name         &lt;string&gt;  # 端口名称，如果指定，必须保证name在pod中是唯一的		</span><br><span class="line">   containerPort&lt;integer&gt; # 容器要监听的端口(0&lt;x&lt;65536)</span><br><span class="line">   hostPort     &lt;integer&gt; # 容器要在主机上公开的端口，如果设置，主机上只能运行容器的一个副本(一般省略) </span><br><span class="line">   hostIP       &lt;string&gt;  # 要将外部端口绑定到的主机IP(一般省略)</span><br><span class="line">   protocol     &lt;string&gt;  # 端口协议。必须是UDP、TCP或SCTP。默认为“TCP”。</span><br></pre></td></tr></table></figure>

<p>接下来，编写一个测试案例，创建pod-ports.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-ports</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span> <span class="comment"># 设置容器暴露的端口列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建Pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-ports.yaml</span><br><span class="line">pod/pod-ports created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看pod</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在下面可以明显看到配置信息</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pod pod-ports -n dev -o yaml</span><br><span class="line">......</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: nginx:1.17.1</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    name: nginx</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 80</span><br><span class="line">      name: nginx-port</span><br><span class="line">      protocol: TCP</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>访问容器中的程序需要使用的是<code>Podip:containerPort</code></p>
<h5 id="5-2-6-资源配额"><a href="#5-2-6-资源配额" class="headerlink" title="5.2.6 资源配额"></a>5.2.6 资源配额</h5><p>容器中的程序要运行，肯定是要占用一定资源的，比如cpu和内存等，如果不对某个容器的资源做限制，那么它就可能吃掉大量资源，导致其它容器无法运行。针对这种情况，kubernetes提供了对内存和cpu的资源进行配额的机制，这种机制主要通过resources选项实现，他有两个子选项：</p>
<ul>
<li>limits：用于限制运行时容器的最大占用资源，当容器占用资源超过limits时会被终止，并进行重启</li>
<li>requests ：用于设置容器需要的最小资源，如果环境资源不够，容器将无法启动</li>
</ul>
<p>可以通过上面两个选项设置资源的上下限。</p>
<p>接下来，编写一个测试案例，创建pod-resources.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-resources</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">resources:</span> <span class="comment"># 资源配额</span></span><br><span class="line">      <span class="attr">limits:</span>  <span class="comment"># 限制资源（上限）</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;2&quot;</span> <span class="comment"># CPU限制，单位是core数</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;10Gi&quot;</span> <span class="comment"># 内存限制</span></span><br><span class="line">      <span class="attr">requests:</span> <span class="comment"># 请求资源（下限）</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span>  <span class="comment"># CPU限制，单位是core数</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;10Mi&quot;</span>  <span class="comment"># 内存限制</span></span><br></pre></td></tr></table></figure>

<p>在这对cpu和memory的单位做一个说明：</p>
<ul>
<li>cpu：core数，可以为整数或小数</li>
<li>memory： 内存大小，可以使用Gi、Mi、G、M等形式</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行Pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create  -f pod-resources.yaml</span><br><span class="line">pod/pod-resources created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看发现pod运行正常</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pod pod-resources -n dev</span><br><span class="line">NAME            READY   STATUS    RESTARTS   AGE  </span><br><span class="line">pod-resources   1/1     Running   0          39s   </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">接下来，停止Pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl delete  -f pod-resources.yaml</span><br><span class="line">pod &quot;pod-resources&quot; deleted</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑pod，修改resources.requests.memory的值为10Gi</span></span><br><span class="line">[root@k8s-master01 ~]# vim pod-resources.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再次启动pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create  -f pod-resources.yaml</span><br><span class="line">pod/pod-resources created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Pod状态，发现Pod启动失败</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pod pod-resources -n dev -o wide</span><br><span class="line">NAME            READY   STATUS    RESTARTS   AGE          </span><br><span class="line">pod-resources   0/1     Pending   0          20s    </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看pod详情会发现，如下提示</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl describe pod pod-resources -n dev</span><br><span class="line">......</span><br><span class="line">Warning  FailedScheduling  35s   default-scheduler  0/3 nodes are available: 1 node(s) had taint &#123;node-role.kubernetes.io/master: &#125;, that the pod didn&#x27;t tolerate, 2 Insufficient memory.(内存不足)</span><br></pre></td></tr></table></figure>

<h4 id="5-3-Pod生命周期"><a href="#5-3-Pod生命周期" class="headerlink" title="5.3 Pod生命周期"></a>5.3 Pod生命周期</h4><p>我们一般将pod对象从创建至终的这段时间范围称为pod的生命周期，它主要包含下面的过程：</p>
<ul>
<li>pod创建过程</li>
<li>运行初始化容器（init container）过程</li>
<li>运行主容器（main container）<ul>
<li>容器启动后钩子（post start）、容器终止前钩子（pre stop）</li>
<li>容器的存活性探测（liveness probe）、就绪性探测（readiness probe）</li>
</ul>
</li>
<li>pod终止过程</li>
</ul>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200412111402706-1626782188724-165356431070876.png" alt="image-20200412111402706"></p>
<p>在整个生命周期中，Pod会出现5种<strong>状态</strong>（<strong>相位</strong>），分别如下：</p>
<ul>
<li>挂起（Pending）：apiserver已经创建了pod资源对象，但它尚未被调度完成或者仍处于下载镜像的过程中</li>
<li>运行中（Running）：pod已经被调度至某节点，并且所有容器都已经被kubelet创建完成</li>
<li>成功（Succeeded）：pod中的所有容器都已经成功终止并且不会被重启</li>
<li>失败（Failed）：所有容器都已经终止，但至少有一个容器终止失败，即容器返回了非0值的退出状态</li>
<li>未知（Unknown）：apiserver无法正常获取到pod对象的状态信息，通常由网络通信失败所导致</li>
</ul>
<h5 id="5-3-1-创建和终止"><a href="#5-3-1-创建和终止" class="headerlink" title="5.3.1 创建和终止"></a>5.3.1 创建和终止</h5><p><strong>pod的创建过程</strong></p>
<ol>
<li><p>用户通过kubectl或其他api客户端提交需要创建的pod信息给apiServer</p>
</li>
<li><p>apiServer开始生成pod对象的信息，并将信息存入etcd，然后返回确认信息至客户端</p>
</li>
<li><p>apiServer开始反映etcd中的pod对象的变化，其它组件使用watch机制来跟踪检查apiServer上的变动</p>
</li>
<li><p>scheduler发现有新的pod对象要创建，开始为Pod分配主机并将结果信息更新至apiServer</p>
</li>
<li><p>node节点上的kubelet发现有pod调度过来，尝试调用docker启动容器，并将结果回送至apiServer</p>
</li>
<li><p>apiServer将接收到的pod状态信息存入etcd中</p>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200406184656917-1626782168787-165356431070878.png" alt="image-20200406184656917"></p>
</li>
</ol>
<p><strong>pod的终止过程</strong></p>
<ol>
<li>用户向apiServer发送删除pod对象的命令</li>
<li>apiServcer中的pod对象信息会随着时间的推移而更新，在宽限期内（默认30s），pod被视为dead</li>
<li>将pod标记为terminating状态</li>
<li>kubelet在监控到pod对象转为terminating状态的同时启动pod关闭过程</li>
<li>端点控制器监控到pod对象的关闭行为时将其从所有匹配到此端点的service资源的端点列表中移除</li>
<li>如果当前pod对象定义了preStop钩子处理器，则在其标记为terminating后即会以同步的方式启动执行</li>
<li>pod对象中的容器进程收到停止信号</li>
<li>宽限期结束后，若pod中还存在仍在运行的进程，那么pod对象会收到立即终止的信号</li>
<li>kubelet请求apiServer将此pod资源的宽限期设置为0从而完成删除操作，此时pod对于用户已不可见</li>
</ol>
<h5 id="5-3-2-初始化容器"><a href="#5-3-2-初始化容器" class="headerlink" title="5.3.2 初始化容器"></a>5.3.2 初始化容器</h5><p>初始化容器是在pod的主容器启动之前要运行的容器，主要是做一些主容器的前置工作，它具有两大特征：</p>
<ol>
<li>初始化容器必须运行完成直至结束，若某初始化容器运行失败，那么kubernetes需要重启它直到成功完成</li>
<li>初始化容器必须按照定义的顺序执行，当且仅当前一个成功之后，后面的一个才能运行</li>
</ol>
<p>初始化容器有很多的应用场景，下面列出的是最常见的几个：</p>
<ul>
<li>提供主容器镜像中不具备的工具程序或自定义代码</li>
<li>初始化容器要先于应用容器串行启动并运行完成，因此可用于延后应用容器的启动直至其依赖的条件得到满足</li>
</ul>
<p>接下来做一个案例，模拟下面这个需求：</p>
<p>假设要以主容器来运行nginx，但是要求在运行nginx之前先要能够连接上mysql和redis所在服务器</p>
<p>为了简化测试，事先规定好mysql<code>(192.168.90.14)</code>和redis<code>(192.168.90.15)</code>服务器的地址</p>
<p>创建pod-initcontainer.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-initcontainer</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">main-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">initContainers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-mysql</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;until ping 192.168.90.14 -c 1 ; do echo waiting for mysql...; sleep 2; done;&#x27;</span>]</span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-redis</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;until ping 192.168.90.15 -c 1 ; do echo waiting for reids...; sleep 2; done;&#x27;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-initcontainer.yaml</span><br><span class="line">pod/pod-initcontainer created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看pod状态</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发现pod卡在启动第一个初始化容器过程中，后面的容器不会运行</span></span><br><span class="line">root@k8s-master01 ~]# kubectl describe pod  pod-initcontainer -n dev</span><br><span class="line">........</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason     Age   From               Message</span><br><span class="line">  ----    ------     ----  ----               -------</span><br><span class="line">  Normal  Scheduled  49s   default-scheduler  Successfully assigned dev/pod-initcontainer to node1</span><br><span class="line">  Normal  Pulled     48s   kubelet, node1     Container image &quot;busybox:1.30&quot; already present on machine</span><br><span class="line">  Normal  Created    48s   kubelet, node1     Created container test-mysql</span><br><span class="line">  Normal  Started    48s   kubelet, node1     Started container test-mysql</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">动态查看pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods pod-initcontainer -n dev -w</span><br><span class="line">NAME                             READY   STATUS     RESTARTS   AGE</span><br><span class="line">pod-initcontainer                0/1     Init:0/2   0          15s</span><br><span class="line">pod-initcontainer                0/1     Init:1/2   0          52s</span><br><span class="line">pod-initcontainer                0/1     Init:1/2   0          53s</span><br><span class="line">pod-initcontainer                0/1     PodInitializing   0          89s</span><br><span class="line">pod-initcontainer                1/1     Running           0          90s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">接下来新开一个shell，为当前服务器新增两个ip，观察pod的变化</span></span><br><span class="line">[root@k8s-master01 ~]# ifconfig ens33:1 192.168.90.14 netmask 255.255.255.0 up</span><br><span class="line">[root@k8s-master01 ~]# ifconfig ens33:2 192.168.90.15 netmask 255.255.255.0 up</span><br></pre></td></tr></table></figure>

<h5 id="5-3-3-钩子函数"><a href="#5-3-3-钩子函数" class="headerlink" title="5.3.3 钩子函数"></a>5.3.3 钩子函数</h5><p>钩子函数能够感知自身生命周期中的事件，并在相应的时刻到来时运行用户指定的程序代码。</p>
<p>kubernetes在主容器的启动之后和停止之前提供了两个钩子函数：</p>
<ul>
<li>post start：容器创建之后执行，如果失败了会重启容器</li>
<li>pre stop ：容器终止之前执行，执行完成之后容器将成功终止，在其完成之前会阻塞删除容器的操作</li>
</ul>
<p>钩子处理器支持使用下面三种方式定义动作：</p>
<ul>
<li><p>Exec命令：在容器内执行一次命令</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">……</span></span><br><span class="line">  <span class="attr">lifecycle:</span></span><br><span class="line">    <span class="attr">postStart:</span> </span><br><span class="line">      <span class="attr">exec:</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/tmp/healthy</span></span><br><span class="line"><span class="string">……</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>TCPSocket：在当前容器尝试访问指定的socket</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">……</span>      </span><br><span class="line">  <span class="attr">lifecycle:</span></span><br><span class="line">    <span class="attr">postStart:</span></span><br><span class="line">      <span class="attr">tcpSocket:</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="string">……</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>HTTPGet：在当前容器中向某url发起http请求</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">……</span></span><br><span class="line">  <span class="attr">lifecycle:</span></span><br><span class="line">    <span class="attr">postStart:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/</span> <span class="comment">#URI地址</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">80</span> <span class="comment">#端口号</span></span><br><span class="line">        <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.5</span><span class="number">.3</span> <span class="comment">#主机地址</span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">HTTP</span> <span class="comment">#支持的协议，http或者https</span></span><br><span class="line"><span class="string">……</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>接下来，以exec方式为例，演示下钩子函数的使用，创建pod-hook-exec.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-hook-exec</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">main-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">lifecycle:</span></span><br><span class="line">      <span class="attr">postStart:</span> </span><br><span class="line">        <span class="attr">exec:</span> <span class="comment"># 在容器启动的时候执行一个命令，修改掉nginx的默认首页内容</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo postStart... &gt; /usr/share/nginx/html/index.html&quot;</span>]</span><br><span class="line">      <span class="attr">preStop:</span></span><br><span class="line">        <span class="attr">exec:</span> <span class="comment"># 在容器停止之前停止nginx服务</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">&quot;/usr/sbin/nginx&quot;</span>,<span class="string">&quot;-s&quot;</span>,<span class="string">&quot;quit&quot;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-hook-exec.yaml</span><br><span class="line">pod/pod-hook-exec created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods  pod-hook-exec -n dev -o wide</span><br><span class="line">NAME           READY   STATUS     RESTARTS   AGE    IP            NODE    </span><br><span class="line">pod-hook-exec  1/1     Running    0          29s    10.244.2.48   node2   </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">访问pod</span></span><br><span class="line">[root@k8s-master01 ~]# curl 10.244.2.48</span><br><span class="line">postStart...</span><br></pre></td></tr></table></figure>

<h5 id="5-3-4-容器探测"><a href="#5-3-4-容器探测" class="headerlink" title="5.3.4 容器探测"></a>5.3.4 容器探测</h5><p>容器探测用于检测容器中的应用实例是否正常工作，是保障业务可用性的一种传统机制。如果经过探测，实例的状态不符合预期，那么kubernetes就会把该问题实例” 摘除 “，不承担业务流量。kubernetes提供了两种探针来实现容器探测，分别是：</p>
<ul>
<li>liveness probes：存活性探针，用于检测应用实例当前是否处于正常运行状态，如果不是，k8s会重启容器</li>
<li>readiness probes：就绪性探针，用于检测应用实例当前是否可以接收请求，如果不能，k8s不会转发流量</li>
</ul>
<blockquote>
<p>livenessProbe 决定是否重启容器，readinessProbe 决定是否将请求转发给容器。</p>
</blockquote>
<p>上面两种探针目前均支持三种探测方式：</p>
<ul>
<li><p>Exec命令：在容器内执行一次命令，如果命令执行的退出码为0，则认为程序正常，否则不正常</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">……</span></span><br><span class="line">  <span class="attr">livenessProbe:</span></span><br><span class="line">    <span class="attr">exec:</span></span><br><span class="line">      <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/tmp/healthy</span></span><br><span class="line"><span class="string">……</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>TCPSocket：将会尝试访问一个用户容器的端口，如果能够建立这条连接，则认为程序正常，否则不正常</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">……</span>      </span><br><span class="line">  <span class="attr">livenessProbe:</span></span><br><span class="line">    <span class="attr">tcpSocket:</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="string">……</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>HTTPGet：调用容器内Web应用的URL，如果返回的状态码在200和399之间，则认为程序正常，否则不正常</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">……</span></span><br><span class="line">  <span class="attr">livenessProbe:</span></span><br><span class="line">    <span class="attr">httpGet:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/</span> <span class="comment">#URI地址</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span> <span class="comment">#端口号</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="comment">#主机地址</span></span><br><span class="line">      <span class="attr">scheme:</span> <span class="string">HTTP</span> <span class="comment">#支持的协议，http或者https</span></span><br><span class="line"><span class="string">……</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>下面以liveness probes为例，做几个演示：</p>
<p><strong>方式一：Exec</strong></p>
<p>创建pod-liveness-exec.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-liveness-exec</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">exec:</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;/bin/cat&quot;</span>,<span class="string">&quot;/tmp/hello.txt&quot;</span>] <span class="comment"># 执行一个查看文件的命令</span></span><br></pre></td></tr></table></figure>

<p>创建pod，观察效果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建Pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-liveness-exec.yaml</span><br><span class="line">pod/pod-liveness-exec created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Pod详情</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl describe pods pod-liveness-exec -n dev</span><br><span class="line">......</span><br><span class="line">  Normal   Created    20s (x2 over 50s)  kubelet, node1     Created container nginx</span><br><span class="line">  Normal   Started    20s (x2 over 50s)  kubelet, node1     Started container nginx</span><br><span class="line">  Normal   Killing    20s                kubelet, node1     Container nginx failed liveness probe, will be restarted</span><br><span class="line">  Warning  Unhealthy  0s (x5 over 40s)   kubelet, node1     Liveness probe failed: cat: can&#x27;t open &#x27;/tmp/hello11.txt&#x27;: No such file or directory</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">观察上面的信息就会发现nginx容器启动之后就进行了健康检查</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查失败之后，容器被<span class="built_in">kill</span>掉，然后尝试进行重启（这是重启策略的作用，后面讲解）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">稍等一会之后，再观察pod信息，就可以看到RESTARTS不再是0，而是一直增长</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods pod-liveness-exec -n dev</span><br><span class="line">NAME                READY   STATUS             RESTARTS   AGE</span><br><span class="line">pod-liveness-exec   0/1     CrashLoopBackOff   2          3m19s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当然接下来，可以修改成一个存在的文件，比如/tmp/hello.txt，再试，结果就正常了......</span></span><br></pre></td></tr></table></figure>

<p><strong>方式二：TCPSocket</strong></p>
<p>创建pod-liveness-tcpsocket.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-liveness-tcpsocket</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">tcpSocket:</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8080</span> <span class="comment"># 尝试访问8080端口</span></span><br></pre></td></tr></table></figure>

<p>创建pod，观察效果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建Pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-liveness-tcpsocket.yaml</span><br><span class="line">pod/pod-liveness-tcpsocket created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Pod详情</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl describe pods pod-liveness-tcpsocket -n dev</span><br><span class="line">......</span><br><span class="line">  Normal   Scheduled  31s                            default-scheduler  Successfully assigned dev/pod-liveness-tcpsocket to node2</span><br><span class="line">  Normal   Pulled     &lt;invalid&gt;                      kubelet, node2     Container image &quot;nginx:1.17.1&quot; already present on machine</span><br><span class="line">  Normal   Created    &lt;invalid&gt;                      kubelet, node2     Created container nginx</span><br><span class="line">  Normal   Started    &lt;invalid&gt;                      kubelet, node2     Started container nginx</span><br><span class="line">  Warning  Unhealthy  &lt;invalid&gt; (x2 over &lt;invalid&gt;)  kubelet, node2     Liveness probe failed: dial tcp 10.244.2.44:8080: connect: connection refused</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">观察上面的信息，发现尝试访问8080端口,但是失败了</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">稍等一会之后，再观察pod信息，就可以看到RESTARTS不再是0，而是一直增长</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods pod-liveness-tcpsocket  -n dev</span><br><span class="line">NAME                     READY   STATUS             RESTARTS   AGE</span><br><span class="line">pod-liveness-tcpsocket   0/1     CrashLoopBackOff   2          3m19s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当然接下来，可以修改成一个可以访问的端口，比如80，再试，结果就正常了......</span></span><br></pre></td></tr></table></figure>

<p><strong>方式三：HTTPGet</strong></p>
<p>创建pod-liveness-httpget.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-liveness-httpget</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span>  <span class="comment"># 其实就是访问http://127.0.0.1:80/hello  </span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">HTTP</span> <span class="comment">#支持的协议，http或者https</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">80</span> <span class="comment">#端口号</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/hello</span> <span class="comment">#URI地址</span></span><br></pre></td></tr></table></figure>

<p>创建pod，观察效果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建Pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-liveness-httpget.yaml</span><br><span class="line">pod/pod-liveness-httpget created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Pod详情</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl describe pod pod-liveness-httpget -n dev</span><br><span class="line">.......</span><br><span class="line">  Normal   Pulled     6s (x3 over 64s)  kubelet, node1     Container image &quot;nginx:1.17.1&quot; already present on machine</span><br><span class="line">  Normal   Created    6s (x3 over 64s)  kubelet, node1     Created container nginx</span><br><span class="line">  Normal   Started    6s (x3 over 63s)  kubelet, node1     Started container nginx</span><br><span class="line">  Warning  Unhealthy  6s (x6 over 56s)  kubelet, node1     Liveness probe failed: HTTP probe failed with statuscode: 404</span><br><span class="line">  Normal   Killing    6s (x2 over 36s)  kubelet, node1     Container nginx failed liveness probe, will be restarted</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">观察上面信息，尝试访问路径，但是未找到,出现404错误</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">稍等一会之后，再观察pod信息，就可以看到RESTARTS不再是0，而是一直增长</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pod pod-liveness-httpget -n dev</span><br><span class="line">NAME                   READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod-liveness-httpget   1/1     Running   5          3m17s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当然接下来，可以修改成一个可以访问的路径path，比如/，再试，结果就正常了......</span></span><br></pre></td></tr></table></figure>

<p>至此，已经使用liveness Probe演示了三种探测方式，但是查看livenessProbe的子属性，会发现除了这三种方式，还有一些其他的配置，在这里一并解释下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-master01 ~]# kubectl explain pod.spec.containers.livenessProbe</span><br><span class="line">FIELDS:</span><br><span class="line">   exec &lt;Object&gt;  </span><br><span class="line">   tcpSocket    &lt;Object&gt;</span><br><span class="line">   httpGet      &lt;Object&gt;</span><br><span class="line">   initialDelaySeconds  &lt;integer&gt;  # 容器启动后等待多少秒执行第一次探测</span><br><span class="line">   timeoutSeconds       &lt;integer&gt;  # 探测超时时间。默认1秒，最小1秒</span><br><span class="line">   periodSeconds        &lt;integer&gt;  # 执行探测的频率。默认是10秒，最小1秒</span><br><span class="line">   failureThreshold     &lt;integer&gt;  # 连续探测失败多少次才被认定为失败。默认是3。最小值是1</span><br><span class="line">   successThreshold     &lt;integer&gt;  # 连续探测成功多少次才被认定为成功。默认是1</span><br></pre></td></tr></table></figure>

<p>下面稍微配置两个，演示下效果即可：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">[<span class="string">root@k8s-master01</span> <span class="string">~</span>]<span class="comment"># more pod-liveness-httpget.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-liveness-httpget</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">80</span> </span><br><span class="line">        <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">30</span> <span class="comment"># 容器启动后30s开始探测</span></span><br><span class="line">      <span class="attr">timeoutSeconds:</span> <span class="number">5</span> <span class="comment"># 探测超时时间为5s</span></span><br></pre></td></tr></table></figure>

<h5 id="5-3-5-重启策略"><a href="#5-3-5-重启策略" class="headerlink" title="5.3.5 重启策略"></a>5.3.5 重启策略</h5><p>在上一节中，一旦容器探测出现了问题，kubernetes就会对容器所在的Pod进行重启，其实这是由pod的重启策略决定的，pod的重启策略有 3 种，分别如下：</p>
<ul>
<li>Always ：容器失效时，自动重启该容器，这也是默认值。</li>
<li>OnFailure ： 容器终止运行且退出码不为0时重启</li>
<li>Never ： 不论状态为何，都不重启该容器</li>
</ul>
<p>重启策略适用于pod对象中的所有容器，首次需要重启的容器，将在其需要时立即进行重启，随后再次需要重启的操作将由kubelet延迟一段时间后进行，且反复的重启操作的延迟时长以此为10s、20s、40s、80s、160s和300s，300s是最大延迟时长。</p>
<p>创建pod-restartpolicy.yaml：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-restartpolicy</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/hello</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Never</span> <span class="comment"># 设置重启策略为Never</span></span><br></pre></td></tr></table></figure>

<p>运行Pod测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建Pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-restartpolicy.yaml</span><br><span class="line">pod/pod-restartpolicy created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Pod详情，发现nginx容器失败</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl  describe pods pod-restartpolicy  -n dev</span><br><span class="line">......</span><br><span class="line">  Warning  Unhealthy  15s (x3 over 35s)  kubelet, node1     Liveness probe failed: HTTP probe failed with statuscode: 404</span><br><span class="line">  Normal   Killing    15s                kubelet, node1     Container nginx failed liveness probe</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">多等一会，再观察pod的重启次数，发现一直是0，并未重启</span>   </span><br><span class="line">[root@k8s-master01 ~]# kubectl  get pods pod-restartpolicy -n dev</span><br><span class="line">NAME                   READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod-restartpolicy      0/1     Running   0          5min42s</span><br></pre></td></tr></table></figure>

<h4 id="5-4-Pod调度"><a href="#5-4-Pod调度" class="headerlink" title="5.4 Pod调度"></a>5.4 Pod调度</h4><p>在默认情况下，一个Pod在哪个Node节点上运行，是由Scheduler组件采用相应的算法计算出来的，这个过程是不受人工控制的。但是在实际使用中，这并不满足的需求，因为很多情况下，我们想控制某些Pod到达某些节点上，那么应该怎么做呢？这就要求了解kubernetes对Pod的调度规则，kubernetes提供了四大类调度方式：</p>
<ul>
<li>自动调度：运行在哪个节点上完全由Scheduler经过一系列的算法计算得出</li>
<li>定向调度：NodeName、NodeSelector</li>
<li>亲和性调度：NodeAffinity、PodAffinity、PodAntiAffinity</li>
<li>污点（容忍）调度：Taints、Toleration</li>
</ul>
<h5 id="5-4-1-定向调度"><a href="#5-4-1-定向调度" class="headerlink" title="5.4.1 定向调度"></a>5.4.1 定向调度</h5><p>定向调度，指的是利用在pod上声明nodeName或者nodeSelector，以此将Pod调度到期望的node节点上。注意，这里的调度是强制的，这就意味着即使要调度的目标Node不存在，也会向上面进行调度，只不过pod运行失败而已。</p>
<p><strong>NodeName</strong></p>
<p>NodeName用于强制约束将Pod调度到指定的Name的Node节点上。这种方式，其实是直接跳过Scheduler的调度逻辑，直接将Pod调度到指定名称的节点。</p>
<p>接下来，实验一下：创建一个pod-nodename.yaml文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-nodename</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="attr">nodeName:</span> <span class="string">node1</span> <span class="comment"># 指定调度到node1节点上</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建Pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-nodename.yaml</span><br><span class="line">pod/pod-nodename created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看Pod调度到NODE属性，确实是调度到了node1节点上</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods pod-nodename -n dev -o wide</span><br><span class="line">NAME           READY   STATUS    RESTARTS   AGE   IP            NODE      ......</span><br><span class="line">pod-nodename   1/1     Running   0          56s   10.244.1.87   node1     ......   </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">接下来，删除pod，修改nodeName的值为node3（并没有node3节点）</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl delete -f pod-nodename.yaml</span><br><span class="line">pod &quot;pod-nodename&quot; deleted</span><br><span class="line">[root@k8s-master01 ~]# vim pod-nodename.yaml</span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-nodename.yaml</span><br><span class="line">pod/pod-nodename created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">再次查看，发现已经向Node3节点调度，但是由于不存在node3节点，所以pod无法正常运行</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods pod-nodename -n dev -o wide</span><br><span class="line">NAME           READY   STATUS    RESTARTS   AGE   IP       NODE    ......</span><br><span class="line">pod-nodename   0/1     Pending   0          6s    &lt;none&gt;   node3   ......           </span><br></pre></td></tr></table></figure>

<p><strong>NodeSelector</strong></p>
<p>NodeSelector用于将pod调度到添加了指定标签的node节点上。它是通过kubernetes的label-selector机制实现的，也就是说，在pod创建之前，会由scheduler使用MatchNodeSelector调度策略进行label匹配，找出目标node，然后将pod调度到目标节点，该匹配规则是强制约束。</p>
<p>接下来，实验一下：</p>
<p>1 首先分别为node节点添加标签</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-master01 ~]# kubectl label nodes node1 nodeenv=pro</span><br><span class="line">node/node2 labeled</span><br><span class="line">[root@k8s-master01 ~]# kubectl label nodes node2 nodeenv=test</span><br><span class="line">node/node2 labeled</span><br></pre></td></tr></table></figure>

<p>2 创建一个pod-nodeselector.yaml文件，并使用它创建Pod</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-nodeselector</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="attr">nodeSelector:</span> </span><br><span class="line">    <span class="attr">nodeenv:</span> <span class="string">pro</span> <span class="comment"># 指定调度到具有nodeenv=pro标签的节点上</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建Pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-nodeselector.yaml</span><br><span class="line">pod/pod-nodeselector created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看Pod调度到NODE属性，确实是调度到了node1节点上</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods pod-nodeselector -n dev -o wide</span><br><span class="line">NAME               READY   STATUS    RESTARTS   AGE     IP          NODE    ......</span><br><span class="line">pod-nodeselector   1/1     Running   0          47s   10.244.1.87   node1   ......</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">接下来，删除pod，修改nodeSelector的值为nodeenv: xxxx（不存在打有此标签的节点）</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl delete -f pod-nodeselector.yaml</span><br><span class="line">pod &quot;pod-nodeselector&quot; deleted</span><br><span class="line">[root@k8s-master01 ~]# vim pod-nodeselector.yaml</span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-nodeselector.yaml</span><br><span class="line">pod/pod-nodeselector created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">再次查看，发现pod无法正常运行,Node的值为none</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev -o wide</span><br><span class="line">NAME               READY   STATUS    RESTARTS   AGE     IP       NODE    </span><br><span class="line">pod-nodeselector   0/1     Pending   0          2m20s   &lt;none&gt;   &lt;none&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看详情,发现node selector匹配失败的提示</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl describe pods pod-nodeselector -n dev</span><br><span class="line">.......</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason            Age        From               Message</span><br><span class="line">  ----     ------            ----       ----               -------</span><br><span class="line">  Warning  FailedScheduling  &lt;unknown&gt;  default-scheduler  0/3 nodes are available: 3 node(s) didn&#x27;t match node selector.</span><br></pre></td></tr></table></figure>

<h5 id="5-4-2-亲和性调度"><a href="#5-4-2-亲和性调度" class="headerlink" title="5.4.2 亲和性调度"></a>5.4.2 亲和性调度</h5><p>上一节，介绍了两种定向调度的方式，使用起来非常方便，但是也有一定的问题，那就是如果没有满足条件的Node，那么Pod将不会被运行，即使在集群中还有可用Node列表也不行，这就限制了它的使用场景。</p>
<p>基于上面的问题，kubernetes还提供了一种亲和性调度（Affinity）。它在NodeSelector的基础之上的进行了扩展，可以通过配置的形式，实现优先选择满足条件的Node进行调度，如果没有，也可以调度到不满足条件的节点上，使调度更加灵活。</p>
<p>Affinity主要分为三类：</p>
<ul>
<li>nodeAffinity(node亲和性）: 以node为目标，解决pod可以调度到哪些node的问题</li>
<li>podAffinity(pod亲和性) : 以pod为目标，解决pod可以和哪些已存在的pod部署在同一个拓扑域中的问题</li>
<li>podAntiAffinity(pod反亲和性) : 以pod为目标，解决pod不能和哪些已存在pod部署在同一个拓扑域中的问题</li>
</ul>
<blockquote>
<p>关于亲和性(反亲和性)使用场景的说明：</p>
<p><strong>亲和性</strong>：如果两个应用频繁交互，那就有必要利用亲和性让两个应用的尽可能的靠近，这样可以减少因网络通信而带来的性能损耗。</p>
<p><strong>反亲和性</strong>：当应用的采用多副本部署时，有必要采用反亲和性让各个应用实例打散分布在各个node上，这样可以提高服务的高可用性。</p>
</blockquote>
<p><strong>NodeAffinity</strong></p>
<p>首先来看一下<code>NodeAffinity</code>的可配置项：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">pod.spec.affinity.nodeAffinity</span><br><span class="line">  requiredDuringSchedulingIgnoredDuringExecution  Node节点必须满足指定的所有规则才可以，相当于硬限制</span><br><span class="line"><span class="code">    nodeSelectorTerms  节点选择列表</span></span><br><span class="line"><span class="code">      matchFields   按节点字段列出的节点选择器要求列表</span></span><br><span class="line"><span class="code">      matchExpressions   按节点标签列出的节点选择器要求列表(推荐)</span></span><br><span class="line"><span class="code">        key    键</span></span><br><span class="line"><span class="code">        values 值</span></span><br><span class="line"><span class="code">        operat or 关系符 支持Exists, DoesNotExist, In, NotIn, Gt, Lt</span></span><br><span class="line"><span class="code">  preferredDuringSchedulingIgnoredDuringExecution 优先调度到满足指定的规则的Node，相当于软限制 (倾向)</span></span><br><span class="line"><span class="code">    preference   一个节点选择器项，与相应的权重相关联</span></span><br><span class="line"><span class="code">      matchFields   按节点字段列出的节点选择器要求列表</span></span><br><span class="line"><span class="code">      matchExpressions   按节点标签列出的节点选择器要求列表(推荐)</span></span><br><span class="line"><span class="code">        key    键</span></span><br><span class="line"><span class="code">        values 值</span></span><br><span class="line"><span class="code">        operator 关系符 支持In, NotIn, Exists, DoesNotExist, Gt, Lt</span></span><br><span class="line"><span class="code">	weight 倾向权重，在范围1-100。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">关系符的使用说明:</span><br><span class="line"></span><br><span class="line">- matchExpressions:</span><br><span class="line">  - key: nodeenv              # 匹配存在标签的key为nodeenv的节点</span><br><span class="line">    operator: Exists</span><br><span class="line">  - key: nodeenv              # 匹配标签的key为nodeenv,且value是&quot;xxx&quot;或&quot;yyy&quot;的节点</span><br><span class="line">    operator: In</span><br><span class="line">    values: [&quot;xxx&quot;,&quot;yyy&quot;]</span><br><span class="line">  - key: nodeenv              # 匹配标签的key为nodeenv,且value大于&quot;xxx&quot;的节点</span><br><span class="line">    operator: Gt</span><br><span class="line">    values: &quot;xxx&quot;</span><br></pre></td></tr></table></figure>

<p>接下来首先演示一下<code>requiredDuringSchedulingIgnoredDuringExecution</code> ,</p>
<p>创建pod-nodeaffinity-required.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-nodeaffinity-required</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="attr">affinity:</span>  <span class="comment">#亲和性设置</span></span><br><span class="line">    <span class="attr">nodeAffinity:</span> <span class="comment">#设置node亲和性</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span> <span class="comment"># 硬限制</span></span><br><span class="line">        <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">matchExpressions:</span> <span class="comment"># 匹配env的值在[&quot;xxx&quot;,&quot;yyy&quot;]中的标签</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">nodeenv</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span> [<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;yyy&quot;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-nodeaffinity-required.yaml</span><br><span class="line">pod/pod-nodeaffinity-required created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看pod状态 （运行失败）</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods pod-nodeaffinity-required -n dev -o wide</span><br><span class="line">NAME                        READY   STATUS    RESTARTS   AGE   IP       NODE    ...... </span><br><span class="line">pod-nodeaffinity-required   0/1     Pending   0          16s   &lt;none&gt;   &lt;none&gt;  ......</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Pod的详情</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发现调度失败，提示node选择失败</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl describe pod pod-nodeaffinity-required -n dev</span><br><span class="line">......</span><br><span class="line">  Warning  FailedScheduling  &lt;unknown&gt;  default-scheduler  0/3 nodes are available: 3 node(s) didn&#x27;t match node selector.</span><br><span class="line">  Warning  FailedScheduling  &lt;unknown&gt;  default-scheduler  0/3 nodes are available: 3 node(s) didn&#x27;t match node selector.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">接下来，停止pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl delete -f pod-nodeaffinity-required.yaml</span><br><span class="line">pod &quot;pod-nodeaffinity-required&quot; deleted</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改文件，将values: [<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;yyy&quot;</span>]------&gt; [<span class="string">&quot;pro&quot;</span>,<span class="string">&quot;yyy&quot;</span>]</span></span><br><span class="line">[root@k8s-master01 ~]# vim pod-nodeaffinity-required.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再次启动</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-nodeaffinity-required.yaml</span><br><span class="line">pod/pod-nodeaffinity-required created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此时查看，发现调度成功，已经将pod调度到了node1上</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods pod-nodeaffinity-required -n dev -o wide</span><br><span class="line">NAME                        READY   STATUS    RESTARTS   AGE   IP            NODE  ...... </span><br><span class="line">pod-nodeaffinity-required   1/1     Running   0          11s   10.244.1.89   node1 ......</span><br></pre></td></tr></table></figure>

<p>接下来再演示一下<code>requiredDuringSchedulingIgnoredDuringExecution</code> ,</p>
<p>创建pod-nodeaffinity-preferred.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-nodeaffinity-preferred</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="attr">affinity:</span>  <span class="comment">#亲和性设置</span></span><br><span class="line">    <span class="attr">nodeAffinity:</span> <span class="comment">#设置node亲和性</span></span><br><span class="line">      <span class="attr">preferredDuringSchedulingIgnoredDuringExecution:</span> <span class="comment"># 软限制</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">preference:</span></span><br><span class="line">          <span class="attr">matchExpressions:</span> <span class="comment"># 匹配env的值在[&quot;xxx&quot;,&quot;yyy&quot;]中的标签(当前环境没有)</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">nodeenv</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span> [<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;yyy&quot;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-nodeaffinity-preferred.yaml</span><br><span class="line">pod/pod-nodeaffinity-preferred created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看pod状态 （运行成功）</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pod pod-nodeaffinity-preferred -n dev</span><br><span class="line">NAME                         READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod-nodeaffinity-preferred   1/1     Running   0          40s</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NodeAffinity规则设置的注意事项：</span><br><span class="line">    1 如果同时定义了nodeSelector和nodeAffinity，那么必须两个条件都得到满足，Pod才能运行在指定的Node上</span><br><span class="line">    2 如果nodeAffinity指定了多个nodeSelectorTerms，那么只需要其中一个能够匹配成功即可</span><br><span class="line">    3 如果一个nodeSelectorTerms中有多个matchExpressions ，则一个节点必须满足所有的才能匹配成功</span><br><span class="line">    4 如果一个pod所在的Node在Pod运行期间其标签发生了改变，不再符合该Pod的节点亲和性需求，则系统将忽略此变化</span><br></pre></td></tr></table></figure>

<p><strong>PodAffinity</strong></p>
<p>PodAffinity主要实现以运行的Pod为参照，实现让新创建的Pod跟参照pod在一个区域的功能。</p>
<p>首先来看一下<code>PodAffinity</code>的可配置项：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">pod.spec.affinity.podAffinity</span><br><span class="line">  requiredDuringSchedulingIgnoredDuringExecution  硬限制</span><br><span class="line"><span class="code">    namespaces       指定参照pod的namespace</span></span><br><span class="line"><span class="code">    topologyKey      指定调度作用域</span></span><br><span class="line"><span class="code">    labelSelector    标签选择器</span></span><br><span class="line"><span class="code">      matchExpressions  按节点标签列出的节点选择器要求列表(推荐)</span></span><br><span class="line"><span class="code">        key    键</span></span><br><span class="line"><span class="code">        values 值</span></span><br><span class="line"><span class="code">        operator 关系符 支持In, NotIn, Exists, DoesNotExist.</span></span><br><span class="line"><span class="code">      matchLabels    指多个matchExpressions映射的内容</span></span><br><span class="line"><span class="code">  preferredDuringSchedulingIgnoredDuringExecution 软限制</span></span><br><span class="line"><span class="code">    podAffinityTerm  选项</span></span><br><span class="line"><span class="code">      namespaces      </span></span><br><span class="line"><span class="code">      topologyKey</span></span><br><span class="line"><span class="code">      labelSelector</span></span><br><span class="line"><span class="code">        matchExpressions  </span></span><br><span class="line"><span class="code">          key    键</span></span><br><span class="line"><span class="code">          values 值</span></span><br><span class="line"><span class="code">          operator</span></span><br><span class="line"><span class="code">        matchLabels </span></span><br><span class="line"><span class="code">    weight 倾向权重，在范围1-100</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">topologyKey用于指定调度时作用域,例如:</span><br><span class="line"><span class="code">    如果指定为kubernetes.io/hostname，那就是以Node节点为区分范围</span></span><br><span class="line"><span class="code">	如果指定为beta.kubernetes.io/os,则以Node节点的操作系统类型来区分</span></span><br></pre></td></tr></table></figure>

<p>接下来，演示下<code>requiredDuringSchedulingIgnoredDuringExecution</code>,</p>
<p>1）首先创建一个参照Pod，pod-podaffinity-target.yaml：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-podaffinity-target</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">podenv:</span> <span class="string">pro</span> <span class="comment">#设置标签</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="attr">nodeName:</span> <span class="string">node1</span> <span class="comment"># 将目标pod名确指定到node1上</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动目标pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-podaffinity-target.yaml</span><br><span class="line">pod/pod-podaffinity-target created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看pod状况</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods  pod-podaffinity-target -n dev</span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod-podaffinity-target   1/1     Running   0          4s</span><br></pre></td></tr></table></figure>

<p>2）创建pod-podaffinity-required.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-podaffinity-required</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="attr">affinity:</span>  <span class="comment">#亲和性设置</span></span><br><span class="line">    <span class="attr">podAffinity:</span> <span class="comment">#设置pod亲和性</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span> <span class="comment"># 硬限制</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">          <span class="attr">matchExpressions:</span> <span class="comment"># 匹配env的值在[&quot;xxx&quot;,&quot;yyy&quot;]中的标签</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">podenv</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span> [<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;yyy&quot;</span>]</span><br><span class="line">        <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br></pre></td></tr></table></figure>

<p>上面配置表达的意思是：新Pod必须要与拥有标签nodeenv&#x3D;xxx或者nodeenv&#x3D;yyy的pod在同一Node上，显然现在没有这样pod，接下来，运行测试一下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-podaffinity-required.yaml</span><br><span class="line">pod/pod-podaffinity-required created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看pod状态，发现未运行</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods pod-podaffinity-required -n dev</span><br><span class="line">NAME                       READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod-podaffinity-required   0/1     Pending   0          9s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看详细信息</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl describe pods pod-podaffinity-required  -n dev</span><br><span class="line">......</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason            Age        From               Message</span><br><span class="line">  ----     ------            ----       ----               -------</span><br><span class="line">  Warning  FailedScheduling  &lt;unknown&gt;  default-scheduler  0/3 nodes are available: 2 node(s) didn&#x27;t match pod affinity rules, 1 node(s) had taints that the pod didn&#x27;t tolerate.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">接下来修改  values: [<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;yyy&quot;</span>]-----&gt;values:[<span class="string">&quot;pro&quot;</span>,<span class="string">&quot;yyy&quot;</span>]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">意思是：新Pod必须要与拥有标签nodeenv=xxx或者nodeenv=yyy的pod在同一Node上</span></span><br><span class="line">[root@k8s-master01 ~]# vim pod-podaffinity-required.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后重新创建pod，查看效果</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl delete -f  pod-podaffinity-required.yaml</span><br><span class="line">pod &quot;pod-podaffinity-required&quot; de leted</span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-podaffinity-required.yaml</span><br><span class="line">pod/pod-podaffinity-required created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发现此时Pod运行正常</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods pod-podaffinity-required -n dev</span><br><span class="line">NAME                       READY   STATUS    RESTARTS   AGE   LABELS</span><br><span class="line">pod-podaffinity-required   1/1     Running   0          6s    &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>关于<code>PodAffinity</code>的 <code>preferredDuringSchedulingIgnoredDuringExecution</code>，这里不再演示。</p>
<p><strong>PodAntiAffinity</strong></p>
<p>PodAntiAffinity主要实现以运行的Pod为参照，让新创建的Pod跟参照pod不在一个区域中的功能。</p>
<p>它的配置方式和选项跟PodAffinty是一样的，这里不再做详细解释，直接做一个测试案例。</p>
<p>1）继续使用上个案例中目标pod</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev -o wide --show-labels</span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE     IP            NODE    LABELS</span><br><span class="line">pod-podaffinity-required 1/1     Running   0          3m29s   10.244.1.38   node1   &lt;none&gt;     </span><br><span class="line">pod-podaffinity-target   1/1     Running   0          9m25s   10.244.1.37   node1   podenv=pro</span><br></pre></td></tr></table></figure>

<p>2）创建pod-podantiaffinity-required.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-podantiaffinity-required</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="attr">affinity:</span>  <span class="comment">#亲和性设置</span></span><br><span class="line">    <span class="attr">podAntiAffinity:</span> <span class="comment">#设置pod亲和性</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span> <span class="comment"># 硬限制</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">          <span class="attr">matchExpressions:</span> <span class="comment"># 匹配podenv的值在[&quot;pro&quot;]中的标签</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">podenv</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span> [<span class="string">&quot;pro&quot;</span>]</span><br><span class="line">        <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br></pre></td></tr></table></figure>

<p>上面配置表达的意思是：新Pod必须要与拥有标签nodeenv&#x3D;pro的pod不在同一Node上，运行测试一下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-podantiaffinity-required.yaml</span><br><span class="line">pod/pod-podantiaffinity-required created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看pod</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发现调度到了node2上</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods pod-podantiaffinity-required -n dev -o wide</span><br><span class="line">NAME                           READY   STATUS    RESTARTS   AGE   IP            NODE   .. </span><br><span class="line">pod-podantiaffinity-required   1/1     Running   0          30s   10.244.1.96   node2  ..</span><br></pre></td></tr></table></figure>

<h5 id="5-4-3-污点和容忍"><a href="#5-4-3-污点和容忍" class="headerlink" title="5.4.3 污点和容忍"></a>5.4.3 污点和容忍</h5><p><strong>污点（Taints）</strong></p>
<p>前面的调度方式都是站在Pod的角度上，通过在Pod上添加属性，来确定Pod是否要调度到指定的Node上，其实我们也可以站在Node的角度上，通过在Node上添加<strong>污点</strong>属性，来决定是否允许Pod调度过来。</p>
<p>Node被设置上污点之后就和Pod之间存在了一种相斥的关系，进而拒绝Pod调度进来，甚至可以将已经存在的Pod驱逐出去。</p>
<p>污点的格式为：<code>key=value:effect</code>, key和value是污点的标签，effect描述污点的作用，支持如下三个选项：</p>
<ul>
<li>PreferNoSchedule：kubernetes将尽量避免把Pod调度到具有该污点的Node上，除非没有其他节点可调度</li>
<li>NoSchedule：kubernetes将不会把Pod调度到具有该污点的Node上，但不会影响当前Node上已存在的Pod</li>
<li>NoExecute：kubernetes将不会把Pod调度到具有该污点的Node上，同时也会将Node上已存在的Pod驱离</li>
</ul>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200605021831545-165356431070879.png" alt="image-20200605021606508"></p>
<p>使用kubectl设置和去除污点的命令示例如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置污点</span></span><br><span class="line">kubectl taint nodes node1 key=value:effect</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">去除污点</span></span><br><span class="line">kubectl taint nodes node1 key:effect-</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">去除所有污点</span></span><br><span class="line">kubectl taint nodes node1 key-</span><br></pre></td></tr></table></figure>

<p>接下来，演示下污点的效果：</p>
<ol>
<li>准备节点node1（为了演示效果更加明显，暂时停止node2节点）</li>
<li>为node1节点设置一个污点: <code>tag=heima:PreferNoSchedule</code>；然后创建pod1( pod1 可以 )</li>
<li>修改为node1节点设置一个污点: <code>tag=heima:NoSchedule</code>；然后创建pod2( pod1 正常 pod2 失败 )</li>
<li>修改为node1节点设置一个污点: <code>tag=heima:NoExecute</code>；然后创建pod3 ( 3个pod都失败 )</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为node1设置污点(PreferNoSchedule)</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl taint nodes node1 tag=heima:PreferNoSchedule</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建pod1</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl run taint1 --image=nginx:1.17.1 -n dev</span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev -o wide</span><br><span class="line">NAME                      READY   STATUS    RESTARTS   AGE     IP           NODE   </span><br><span class="line">taint1-7665f7fd85-574h4   1/1     Running   0          2m24s   10.244.1.59   node1    </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为node1设置污点(取消PreferNoSchedule，设置NoSchedule)</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl taint nodes node1 tag:PreferNoSchedule-</span><br><span class="line">[root@k8s-master01 ~]# kubectl taint nodes node1 tag=heima:NoSchedule</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建pod2</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl run taint2 --image=nginx:1.17.1 -n dev</span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods taint2 -n dev -o wide</span><br><span class="line">NAME                      READY   STATUS    RESTARTS   AGE     IP            NODE</span><br><span class="line">taint1-7665f7fd85-574h4   1/1     Running   0          2m24s   10.244.1.59   node1 </span><br><span class="line">taint2-544694789-6zmlf    0/1     Pending   0          21s     &lt;none&gt;        &lt;none&gt;   </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为node1设置污点(取消NoSchedule，设置NoExecute)</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl taint nodes node1 tag:NoSchedule-</span><br><span class="line">[root@k8s-master01 ~]# kubectl taint nodes node1 tag=heima:NoExecute</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建pod3</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl run taint3 --image=nginx:1.17.1 -n dev</span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev -o wide</span><br><span class="line">NAME                      READY   STATUS    RESTARTS   AGE   IP       NODE     NOMINATED </span><br><span class="line">taint1-7665f7fd85-htkmp   0/1     Pending   0          35s   &lt;none&gt;   &lt;none&gt;   &lt;none&gt;    </span><br><span class="line">taint2-544694789-bn7wb    0/1     Pending   0          35s   &lt;none&gt;   &lt;none&gt;   &lt;none&gt;     </span><br><span class="line">taint3-6d78dbd749-tktkq   0/1     Pending   0          6s    &lt;none&gt;   &lt;none&gt;   &lt;none&gt;     </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">小提示：</span><br><span class="line">    使用kubeadm搭建的集群，默认就会给master节点添加一个污点标记,所以pod就不会调度到master节点上.</span><br></pre></td></tr></table></figure>

<p><strong>容忍（Toleration）</strong></p>
<p>上面介绍了污点的作用，我们可以在node上添加污点用于拒绝pod调度上来，但是如果就是想将一个pod调度到一个有污点的node上去，这时候应该怎么做呢？这就要使用到<strong>容忍</strong>。</p>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200514095913741-165356431070880.png" alt="image-20200514095913741"></p>
<blockquote>
<p>污点就是拒绝，容忍就是忽略，Node通过污点拒绝pod调度上去，Pod通过容忍忽略拒绝</p>
</blockquote>
<p>下面先通过一个案例看下效果：</p>
<ol>
<li>上一小节，已经在node1节点上打上了<code>NoExecute</code>的污点，此时pod是调度不上去的</li>
<li>本小节，可以通过给pod添加容忍，然后将其调度上去</li>
</ol>
<p>创建pod-toleration.yaml,内容如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-toleration</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="attr">tolerations:</span>      <span class="comment"># 添加容忍</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&quot;tag&quot;</span>        <span class="comment"># 要容忍的污点的key</span></span><br><span class="line">    <span class="attr">operator:</span> <span class="string">&quot;Equal&quot;</span> <span class="comment"># 操作符</span></span><br><span class="line">    <span class="attr">value:</span> <span class="string">&quot;heima&quot;</span>    <span class="comment"># 容忍的污点的value</span></span><br><span class="line">    <span class="attr">effect:</span> <span class="string">&quot;NoExecute&quot;</span>   <span class="comment"># 添加容忍的规则，这里必须和标记的污点规则相同</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加容忍之前的pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev -o wide</span><br><span class="line">NAME             READY   STATUS    RESTARTS   AGE   IP       NODE     NOMINATED </span><br><span class="line">pod-toleration   0/1     Pending   0          3s    &lt;none&gt;   &lt;none&gt;   &lt;none&gt;           </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加容忍之后的pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev -o wide</span><br><span class="line">NAME             READY   STATUS    RESTARTS   AGE   IP            NODE    NOMINATED</span><br><span class="line">pod-toleration   1/1     Running   0          3s    10.244.1.62   node1   &lt;none&gt;        </span><br></pre></td></tr></table></figure>

<p>下面看一下容忍的详细配置:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-master01 ~]# kubectl explain pod.spec.tolerations</span><br><span class="line">......</span><br><span class="line">FIELDS:</span><br><span class="line">   key       # 对应着要容忍的污点的键，空意味着匹配所有的键</span><br><span class="line">   value     # 对应着要容忍的污点的值</span><br><span class="line">   operator  # key-value的运算符，支持Equal和Exists（默认）</span><br><span class="line">   effect    # 对应污点的effect，空意味着匹配所有影响</span><br><span class="line">   tolerationSeconds   # 容忍时间, 当effect为NoExecute时生效，表示pod在Node上的停留时间</span><br></pre></td></tr></table></figure>

<h3 id="6-Pod控制器详解"><a href="#6-Pod控制器详解" class="headerlink" title="6. Pod控制器详解"></a>6. Pod控制器详解</h3><h4 id="6-1-Pod控制器介绍"><a href="#6-1-Pod控制器介绍" class="headerlink" title="6.1 Pod控制器介绍"></a>6.1 Pod控制器介绍</h4><p>Pod是kubernetes的最小管理单元，在kubernetes中，按照pod的创建方式可以将其分为两类：</p>
<ul>
<li>自主式pod：kubernetes直接创建出来的Pod，这种pod删除后就没有了，也不会重建</li>
<li>控制器创建的pod：kubernetes通过控制器创建的pod，这种pod删除了之后还会自动重建</li>
</ul>
<blockquote>
<p><strong><code>什么是Pod控制器</code></strong></p>
<p>Pod控制器是管理pod的中间层，使用Pod控制器之后，只需要告诉Pod控制器，想要多少个什么样的Pod就可以了，它会创建出满足条件的Pod并确保每一个Pod资源处于用户期望的目标状态。如果Pod资源在运行中出现故障，它会基于指定策略重新编排Pod。</p>
</blockquote>
<p>在kubernetes中，有很多类型的pod控制器，每种都有自己的适合的场景，常见的有下面这些：</p>
<ul>
<li>ReplicationController：比较原始的pod控制器，已经被废弃，由ReplicaSet替代</li>
<li>ReplicaSet：保证副本数量一直维持在期望值，并支持pod数量扩缩容，镜像版本升级</li>
<li>Deployment：通过控制ReplicaSet来控制Pod，并支持滚动升级、回退版本</li>
<li>Horizontal Pod Autoscaler：可以根据集群负载自动水平调整Pod的数量，实现削峰填谷</li>
<li>DaemonSet：在集群中的指定Node上运行且仅运行一个副本，一般用于守护进程类的任务</li>
<li>Job：它创建出来的pod只要完成任务就立即退出，不需要重启或重建，用于执行一次性任务</li>
<li>Cronjob：它创建的Pod负责周期性任务控制，不需要持续后台运行</li>
<li>StatefulSet：管理有状态应用</li>
</ul>
<h4 id="6-2-ReplicaSet-RS"><a href="#6-2-ReplicaSet-RS" class="headerlink" title="6.2 ReplicaSet(RS)"></a>6.2 ReplicaSet(RS)</h4><p>ReplicaSet的主要作用是<strong>保证一定数量的pod正常运行</strong>，它会持续监听这些Pod的运行状态，一旦Pod发生故障，就会重启或重建。同时它还支持对pod数量的扩缩容和镜像版本的升降级。</p>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200612005334159-165356431070882.png" alt="img"></p>
<p>ReplicaSet的资源清单文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span> <span class="comment"># 类型       </span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="comment"># rs名称 </span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="comment"># 所属命名空间 </span></span><br><span class="line">  <span class="attr">labels:</span> <span class="comment">#标签</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="string">rs</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 详情描述</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span> <span class="comment"># 副本数量</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 选择器，通过它指定该控制器管理哪些pod</span></span><br><span class="line">    <span class="attr">matchLabels:</span>      <span class="comment"># Labels匹配规则</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">matchExpressions:</span> <span class="comment"># Expressions匹配规则</span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">key:</span> <span class="string">app</span>, <span class="attr">operator:</span> <span class="string">In</span>, <span class="attr">values:</span> [<span class="string">nginx-pod</span>]&#125;</span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># 模板，当副本数量不足时，会根据下面的模板创建pod副本</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>在这里面，需要新了解的配置项就是<code>spec</code>下面几个选项：</p>
<ul>
<li><p>replicas：指定副本数量，其实就是当前rs创建出来的pod的数量，默认为1</p>
</li>
<li><p>selector：选择器，它的作用是建立pod控制器和pod之间的关联关系，采用的Label Selector机制</p>
<p>在pod模板上定义label，在控制器上定义选择器，就可以表明当前控制器能管理哪些pod了</p>
</li>
<li><p>template：模板，就是当前控制器创建pod所使用的模板板，里面其实就是前一章学过的pod的定义</p>
</li>
</ul>
<p><strong>创建ReplicaSet</strong></p>
<p>创建pc-replicaset.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span>   </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-replicaset</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span> </span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建rs</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pc-replicaset.yaml</span><br><span class="line">replicaset.apps/pc-replicaset created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看rs</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">DESIRED:期望副本数量</span>  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CURRENT:当前副本数量</span>  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">READY:已经准备好提供服务的副本数量</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get rs pc-replicaset -n dev -o wide</span><br><span class="line">NAME          DESIRED   CURRENT READY AGE   CONTAINERS   IMAGES             SELECTOR</span><br><span class="line">pc-replicaset 3         3       3     22s   nginx        nginx:1.17.1       app=nginx-pod</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前控制器创建出来的pod</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里发现控制器创建出来的pod的名称是在控制器名称后面拼接了-xxxxx随机码</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pod -n dev</span><br><span class="line">NAME                          READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc-replicaset-6vmvt   1/1     Running   0          54s</span><br><span class="line">pc-replicaset-fmb8f   1/1     Running   0          54s</span><br><span class="line">pc-replicaset-snrk2   1/1     Running   0          54s</span><br></pre></td></tr></table></figure>

<p><strong>扩缩容</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑rs的副本数量，修改spec:replicas: 6即可</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl edit rs pc-replicaset -n dev</span><br><span class="line">replicaset.apps/pc-replicaset edited</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev</span><br><span class="line">NAME                          READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc-replicaset-6vmvt   1/1     Running   0          114m</span><br><span class="line">pc-replicaset-cftnp   1/1     Running   0          10s</span><br><span class="line">pc-replicaset-fjlm6   1/1     Running   0          10s</span><br><span class="line">pc-replicaset-fmb8f   1/1     Running   0          114m</span><br><span class="line">pc-replicaset-s2whj   1/1     Running   0          10s</span><br><span class="line">pc-replicaset-snrk2   1/1     Running   0          114m</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当然也可以直接使用命令实现</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用scale命令实现扩缩容， 后面--replicas=n直接指定目标数量即可</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl scale rs pc-replicaset --replicas=2 -n dev</span><br><span class="line">replicaset.apps/pc-replicaset scaled</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令运行完毕，立即查看，发现已经有4个开始准备退出了</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev</span><br><span class="line">NAME                       READY   STATUS        RESTARTS   AGE</span><br><span class="line">pc-replicaset-6vmvt   0/1     Terminating   0          118m</span><br><span class="line">pc-replicaset-cftnp   0/1     Terminating   0          4m17s</span><br><span class="line">pc-replicaset-fjlm6   0/1     Terminating   0          4m17s</span><br><span class="line">pc-replicaset-fmb8f   1/1     Running       0          118m</span><br><span class="line">pc-replicaset-s2whj   0/1     Terminating   0          4m17s</span><br><span class="line">pc-replicaset-snrk2   1/1     Running       0          118m</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">稍等片刻，就只剩下2个了</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev</span><br><span class="line">NAME                       READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc-replicaset-fmb8f   1/1     Running   0          119m</span><br><span class="line">pc-replicaset-snrk2   1/1     Running   0          119m</span><br></pre></td></tr></table></figure>

<p><strong>镜像升级</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑rs的容器镜像 - image: nginx:1.17.2</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl edit rs pc-replicaset -n dev</span><br><span class="line">replicaset.apps/pc-replicaset edited</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再次查看，发现镜像版本已经变更了</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get rs -n dev -o wide</span><br><span class="line">NAME                DESIRED  CURRENT   READY   AGE    CONTAINERS   IMAGES        ...</span><br><span class="line">pc-replicaset       2        2         2       140m   nginx         nginx:1.17.2  ...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同样的道理，也可以使用命令完成这个工作</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kubectl <span class="built_in">set</span> image rs rs名称 容器=镜像版本 -n namespace</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl set image rs pc-replicaset nginx=nginx:1.17.1  -n dev</span><br><span class="line">replicaset.apps/pc-replicaset image updated</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再次查看，发现镜像版本已经变更了</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get rs -n dev -o wide</span><br><span class="line">NAME                 DESIRED  CURRENT   READY   AGE    CONTAINERS   IMAGES            ...</span><br><span class="line">pc-replicaset        2        2         2       145m   nginx        nginx:1.17.1 ... </span><br></pre></td></tr></table></figure>

<p><strong>删除ReplicaSet</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用kubectl delete命令会删除此RS以及它管理的Pod</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在kubernetes删除RS前，会将RS的replicasclear调整为0，等待所有的Pod被删除后，在执行RS对象的删除</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl delete rs pc-replicaset -n dev</span><br><span class="line">replicaset.apps &quot;pc-replicaset&quot; deleted</span><br><span class="line">[root@k8s-master01 ~]# kubectl get pod -n dev -o wide</span><br><span class="line">No resources found in dev namespace.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果希望仅仅删除RS对象（保留Pod），可以使用kubectl delete命令时添加--cascade=<span class="literal">false</span>选项（不推荐）。</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl delete rs pc-replicaset -n dev --cascade=false</span><br><span class="line">replicaset.apps &quot;pc-replicaset&quot; deleted</span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev</span><br><span class="line">NAME                  READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc-replicaset-cl82j   1/1     Running   0          75s</span><br><span class="line">pc-replicaset-dslhb   1/1     Running   0          75s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以使用yaml直接删除(推荐)</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl delete -f pc-replicaset.yaml</span><br><span class="line">replicaset.apps &quot;pc-replicaset&quot; deleted</span><br></pre></td></tr></table></figure>

<h4 id="6-3-Deployment-Deploy"><a href="#6-3-Deployment-Deploy" class="headerlink" title="6.3 Deployment(Deploy)"></a>6.3 Deployment(Deploy)</h4><p>为了更好的解决服务编排的问题，kubernetes在V1.2版本开始，引入了Deployment控制器。值得一提的是，这种控制器并不直接管理pod，而是通过管理ReplicaSet来简介管理Pod，即：Deployment管理ReplicaSet，ReplicaSet管理Pod。所以Deployment比ReplicaSet功能更加强大。</p>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200612005524778-165356431070881.png" alt="img"></p>
<p>Deployment主要功能有下面几个：</p>
<ul>
<li>支持ReplicaSet的所有功能</li>
<li>支持发布的停止、继续</li>
<li>支持滚动升级和回滚版本</li>
</ul>
<p>Deployment的资源清单文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span> <span class="comment"># 类型       </span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="comment"># rs名称 </span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="comment"># 所属命名空间 </span></span><br><span class="line">  <span class="attr">labels:</span> <span class="comment">#标签</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="string">deploy</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 详情描述</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span> <span class="comment"># 副本数量</span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">3</span> <span class="comment"># 保留历史版本</span></span><br><span class="line">  <span class="attr">paused:</span> <span class="literal">false</span> <span class="comment"># 暂停部署，默认是false</span></span><br><span class="line">  <span class="attr">progressDeadlineSeconds:</span> <span class="number">600</span> <span class="comment"># 部署超时时间（s），默认是600</span></span><br><span class="line">  <span class="attr">strategy:</span> <span class="comment"># 策略</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span> <span class="comment"># 滚动更新策略</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span> <span class="comment"># 滚动更新</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">30</span><span class="string">%</span> <span class="comment"># 最大额外可以存在的副本数，可以为百分比，也可以为整数</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">30</span><span class="string">%</span> <span class="comment"># 最大不可用状态的 Pod 的最大值，可以为百分比，也可以为整数</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 选择器，通过它指定该控制器管理哪些pod</span></span><br><span class="line">    <span class="attr">matchLabels:</span>      <span class="comment"># Labels匹配规则</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">matchExpressions:</span> <span class="comment"># Expressions匹配规则</span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">key:</span> <span class="string">app</span>, <span class="attr">operator:</span> <span class="string">In</span>, <span class="attr">values:</span> [<span class="string">nginx-pod</span>]&#125;</span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># 模板，当副本数量不足时，会根据下面的模板创建pod副本</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<h5 id="6-3-1-创建deployment"><a href="#6-3-1-创建deployment" class="headerlink" title="6.3.1 创建deployment"></a>6.3.1 创建deployment</h5><p>创建pc-deployment.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>      </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-deployment</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建deployment</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pc-deployment.yaml --record=true</span><br><span class="line">deployment.apps/pc-deployment created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看deployment</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">UP-TO-DATE 最新版本的pod的数量</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">AVAILABLE  当前可用的pod的数量</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get deploy pc-deployment -n dev</span><br><span class="line">NAME            READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">pc-deployment   3/3     3            3           15s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看rs</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发现rs的名称是在原来deployment的名字后面添加了一个10位数的随机串</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get rs -n dev</span><br><span class="line">NAME                       DESIRED   CURRENT   READY   AGE</span><br><span class="line">pc-deployment-6696798b78   3         3         3       23s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev</span><br><span class="line">NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc-deployment-6696798b78-d2c8n   1/1     Running   0          107s</span><br><span class="line">pc-deployment-6696798b78-smpvp   1/1     Running   0          107s</span><br><span class="line">pc-deployment-6696798b78-wvjd8   1/1     Running   0          107s</span><br></pre></td></tr></table></figure>

<h5 id="6-3-2-扩缩容"><a href="#6-3-2-扩缩容" class="headerlink" title="6.3.2 扩缩容"></a>6.3.2 扩缩容</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">变更副本数量为5个</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl scale deploy pc-deployment --replicas=5  -n dev</span><br><span class="line">deployment.apps/pc-deployment scaled</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看deployment</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get deploy pc-deployment -n dev</span><br><span class="line">NAME            READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">pc-deployment   5/5     5            5           2m</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看pod</span></span><br><span class="line">[root@k8s-master01 ~]#  kubectl get pods -n dev</span><br><span class="line">NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc-deployment-6696798b78-d2c8n   1/1     Running   0          4m19s</span><br><span class="line">pc-deployment-6696798b78-jxmdq   1/1     Running   0          94s</span><br><span class="line">pc-deployment-6696798b78-mktqv   1/1     Running   0          93s</span><br><span class="line">pc-deployment-6696798b78-smpvp   1/1     Running   0          4m19s</span><br><span class="line">pc-deployment-6696798b78-wvjd8   1/1     Running   0          4m19s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑deployment的副本数量，修改spec:replicas: 4即可</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl edit deploy pc-deployment -n dev</span><br><span class="line">deployment.apps/pc-deployment edited</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev</span><br><span class="line">NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc-deployment-6696798b78-d2c8n   1/1     Running   0          5m23s</span><br><span class="line">pc-deployment-6696798b78-jxmdq   1/1     Running   0          2m38s</span><br><span class="line">pc-deployment-6696798b78-smpvp   1/1     Running   0          5m23s</span><br><span class="line">pc-deployment-6696798b78-wvjd8   1/1     Running   0          5m23s</span><br></pre></td></tr></table></figure>

<p><strong>镜像更新</strong></p>
<p>deployment支持两种更新策略:<code>重建更新</code>和<code>滚动更新</code>,可以通过<code>strategy</code>指定策略类型,支持两个属性:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">strategy：指定新的Pod替换旧的Pod的策略， 支持两个属性：</span><br><span class="line">  type：指定策略类型，支持两种策略</span><br><span class="line"><span class="code">    Recreate：在创建出新的Pod之前会先杀掉所有已存在的Pod</span></span><br><span class="line"><span class="code">    RollingUpdate：滚动更新，就是杀死一部分，就启动一部分，在更新过程中，存在两个版本Pod</span></span><br><span class="line"><span class="code">  rollingUpdate：当type为RollingUpdate时生效，用于为RollingUpdate设置参数，支持两个属性：</span></span><br><span class="line"><span class="code">    maxUnavailable：用来指定在升级过程中不可用Pod的最大数量，默认为25%。</span></span><br><span class="line"><span class="code">    maxSurge： 用来指定在升级过程中可以超过期望的Pod的最大数量，默认为25%。</span></span><br></pre></td></tr></table></figure>

<p>重建更新</p>
<ol>
<li>编辑pc-deployment.yaml,在spec节点下添加更新策略</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">strategy:</span> <span class="comment"># 策略</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Recreate</span> <span class="comment"># 重建更新</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建deploy进行验证</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">变更镜像</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl set image deployment pc-deployment nginx=nginx:1.17.2 -n dev</span><br><span class="line">deployment.apps/pc-deployment image updated</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">观察升级过程</span></span><br><span class="line">[root@k8s-master01 ~]#  kubectl get pods -n dev -w</span><br><span class="line">NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc-deployment-5d89bdfbf9-65qcw   1/1     Running   0          31s</span><br><span class="line">pc-deployment-5d89bdfbf9-w5nzv   1/1     Running   0          31s</span><br><span class="line">pc-deployment-5d89bdfbf9-xpt7w   1/1     Running   0          31s</span><br><span class="line"></span><br><span class="line">pc-deployment-5d89bdfbf9-xpt7w   1/1     Terminating   0          41s</span><br><span class="line">pc-deployment-5d89bdfbf9-65qcw   1/1     Terminating   0          41s</span><br><span class="line">pc-deployment-5d89bdfbf9-w5nzv   1/1     Terminating   0          41s</span><br><span class="line"></span><br><span class="line">pc-deployment-675d469f8b-grn8z   0/1     Pending       0          0s</span><br><span class="line">pc-deployment-675d469f8b-hbl4v   0/1     Pending       0          0s</span><br><span class="line">pc-deployment-675d469f8b-67nz2   0/1     Pending       0          0s</span><br><span class="line"></span><br><span class="line">pc-deployment-675d469f8b-grn8z   0/1     ContainerCreating   0          0s</span><br><span class="line">pc-deployment-675d469f8b-hbl4v   0/1     ContainerCreating   0          0s</span><br><span class="line">pc-deployment-675d469f8b-67nz2   0/1     ContainerCreating   0          0s</span><br><span class="line"></span><br><span class="line">pc-deployment-675d469f8b-grn8z   1/1     Running             0          1s</span><br><span class="line">pc-deployment-675d469f8b-67nz2   1/1     Running             0          1s</span><br><span class="line">pc-deployment-675d469f8b-hbl4v   1/1     Running             0          2s</span><br></pre></td></tr></table></figure>

<p>滚动更新</p>
<ol>
<li>编辑pc-deployment.yaml,在spec节点下添加更新策略</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">strategy:</span> <span class="comment"># 策略</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span> <span class="comment"># 滚动更新策略</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">25</span><span class="string">%</span> </span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">25</span><span class="string">%</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建deploy进行验证</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">变更镜像</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl set image deployment pc-deployment nginx=nginx:1.17.3 -n dev </span><br><span class="line">deployment.apps/pc-deployment image updated</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">观察升级过程</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev -w</span><br><span class="line">NAME                           READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc-deployment-c848d767-8rbzt   1/1     Running   0          31m</span><br><span class="line">pc-deployment-c848d767-h4p68   1/1     Running   0          31m</span><br><span class="line">pc-deployment-c848d767-hlmz4   1/1     Running   0          31m</span><br><span class="line">pc-deployment-c848d767-rrqcn   1/1     Running   0          31m</span><br><span class="line"></span><br><span class="line">pc-deployment-966bf7f44-226rx   0/1     Pending             0          0s</span><br><span class="line">pc-deployment-966bf7f44-226rx   0/1     ContainerCreating   0          0s</span><br><span class="line">pc-deployment-966bf7f44-226rx   1/1     Running             0          1s</span><br><span class="line">pc-deployment-c848d767-h4p68    0/1     Terminating         0          34m</span><br><span class="line"></span><br><span class="line">pc-deployment-966bf7f44-cnd44   0/1     Pending             0          0s</span><br><span class="line">pc-deployment-966bf7f44-cnd44   0/1     ContainerCreating   0          0s</span><br><span class="line">pc-deployment-966bf7f44-cnd44   1/1     Running             0          2s</span><br><span class="line">pc-deployment-c848d767-hlmz4    0/1     Terminating         0          34m</span><br><span class="line"></span><br><span class="line">pc-deployment-966bf7f44-px48p   0/1     Pending             0          0s</span><br><span class="line">pc-deployment-966bf7f44-px48p   0/1     ContainerCreating   0          0s</span><br><span class="line">pc-deployment-966bf7f44-px48p   1/1     Running             0          0s</span><br><span class="line">pc-deployment-c848d767-8rbzt    0/1     Terminating         0          34m</span><br><span class="line"></span><br><span class="line">pc-deployment-966bf7f44-dkmqp   0/1     Pending             0          0s</span><br><span class="line">pc-deployment-966bf7f44-dkmqp   0/1     ContainerCreating   0          0s</span><br><span class="line">pc-deployment-966bf7f44-dkmqp   1/1     Running             0          2s</span><br><span class="line">pc-deployment-c848d767-rrqcn    0/1     Terminating         0          34m</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">至此，新版本的pod创建完毕，就版本的pod销毁完毕</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">中间过程是滚动进行的，也就是边销毁边创建</span></span><br></pre></td></tr></table></figure>

<p>滚动更新的过程：</p>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200416140251491-165356431070883.png" alt="img"></p>
<p>镜像更新中rs的变化</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看rs,发现原来的rs的依旧存在，只是pod数量变为了0，而后又新产生了一个rs，pod数量为4</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其实这就是deployment能够进行版本回退的奥妙所在，后面会详细解释</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get rs -n dev</span><br><span class="line">NAME                       DESIRED   CURRENT   READY   AGE</span><br><span class="line">pc-deployment-6696798b78   0         0         0       7m37s</span><br><span class="line">pc-deployment-6696798b11   0         0         0       5m37s</span><br><span class="line">pc-deployment-c848d76789   4         4         4       72s</span><br></pre></td></tr></table></figure>

<h5 id="6-3-3-版本回退"><a href="#6-3-3-版本回退" class="headerlink" title="6.3.3 版本回退"></a>6.3.3 版本回退</h5><p>deployment支持版本升级过程中的暂停、继续功能以及版本回退等诸多功能，下面具体来看.</p>
<p>kubectl rollout： 版本升级相关功能，支持下面的选项：</p>
<ul>
<li>status	显示当前升级状态</li>
<li>history   显示 升级历史记录</li>
<li>pause    暂停版本升级过程</li>
<li>resume   继续已经暂停的版本升级过程</li>
<li>restart    重启版本升级过程</li>
<li>undo 回滚到上一级版本（可以使用–to-revision回滚到指定版本）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前升级版本的状态</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl rollout status deploy pc-deployment -n dev</span><br><span class="line">deployment &quot;pc-deployment&quot; successfully rolled out</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看升级历史记录</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl rollout history deploy pc-deployment -n dev</span><br><span class="line">deployment.apps/pc-deployment</span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line">1         kubectl create --filename=pc-deployment.yaml --record=true</span><br><span class="line">2         kubectl create --filename=pc-deployment.yaml --record=true</span><br><span class="line">3         kubectl create --filename=pc-deployment.yaml --record=true</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以发现有三次版本记录，说明完成过两次升级</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">版本回滚</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里直接使用--to-revision=1回滚到了1版本， 如果省略这个选项，就是回退到上个版本，就是2版本</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl rollout undo deployment pc-deployment --to-revision=1 -n dev</span><br><span class="line">deployment.apps/pc-deployment rolled back</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看发现，通过nginx镜像版本可以发现到了第一版</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get deploy -n dev -o wide</span><br><span class="line">NAME            READY   UP-TO-DATE   AVAILABLE   AGE   CONTAINERS   IMAGES         </span><br><span class="line">pc-deployment   4/4     4            4           74m   nginx        nginx:1.17.1   </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看rs，发现第一个rs中有4个pod运行，后面两个版本的rs中pod为运行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其实deployment之所以可是实现版本的回滚，就是通过记录下历史rs来实现的，</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一旦想回滚到哪个版本，只需要将当前版本pod数量降为0，然后将回滚版本的pod提升为目标数量就可以了</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get rs -n dev</span><br><span class="line">NAME                       DESIRED   CURRENT   READY   AGE</span><br><span class="line">pc-deployment-6696798b78   4         4         4       78m</span><br><span class="line">pc-deployment-966bf7f44    0         0         0       37m</span><br><span class="line">pc-deployment-c848d767     0         0         0       71m</span><br></pre></td></tr></table></figure>

<h5 id="6-3-4-金丝雀发布"><a href="#6-3-4-金丝雀发布" class="headerlink" title="6.3.4 金丝雀发布"></a>6.3.4 金丝雀发布</h5><p>Deployment控制器支持控制更新过程中的控制，如“暂停(pause)”或“继续(resume)”更新操作。</p>
<p>比如有一批新的Pod资源创建完成后立即暂停更新过程，此时，仅存在一部分新版本的应用，主体部分还是旧的版本。然后，再筛选一小部分的用户请求路由到新版本的Pod应用，继续观察能否稳定地按期望的方式运行。确定没问题之后再继续完成余下的Pod资源滚动更新，否则立即回滚更新操作。这就是所谓的金丝雀发布。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新deployment的版本，并配置暂停deployment</span></span><br><span class="line">[root@k8s-master01 ~]#  kubectl set image deploy pc-deployment nginx=nginx:1.17.4 -n dev &amp;&amp; kubectl rollout pause deployment pc-deployment  -n dev</span><br><span class="line">deployment.apps/pc-deployment image updated</span><br><span class="line">deployment.apps/pc-deployment paused</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">观察更新状态</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl rollout status deploy pc-deployment -n dev　</span><br><span class="line">Waiting for deployment &quot;pc-deployment&quot; rollout to finish: 2 out of 4 new replicas have been updated...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">监控更新的过程，可以看到已经新增了一个资源，但是并未按照预期的状态去删除一个旧的资源，就是因为使用了pause暂停命令</span></span><br><span class="line"></span><br><span class="line">[root@k8s-master01 ~]# kubectl get rs -n dev -o wide</span><br><span class="line">NAME                       DESIRED   CURRENT   READY   AGE     CONTAINERS   IMAGES         </span><br><span class="line">pc-deployment-5d89bdfbf9   3         3         3       19m     nginx        nginx:1.17.1   </span><br><span class="line">pc-deployment-675d469f8b   0         0         0       14m     nginx        nginx:1.17.2   </span><br><span class="line">pc-deployment-6c9f56fcfb   2         2         2       3m16s   nginx        nginx:1.17.4   </span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev</span><br><span class="line">NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc-deployment-5d89bdfbf9-rj8sq   1/1     Running   0          7m33s</span><br><span class="line">pc-deployment-5d89bdfbf9-ttwgg   1/1     Running   0          7m35s</span><br><span class="line">pc-deployment-5d89bdfbf9-v4wvc   1/1     Running   0          7m34s</span><br><span class="line">pc-deployment-6c9f56fcfb-996rt   1/1     Running   0          3m31s</span><br><span class="line">pc-deployment-6c9f56fcfb-j2gtj   1/1     Running   0          3m31s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">确保更新的pod没问题了，继续更新</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl rollout resume deploy pc-deployment -n dev</span><br><span class="line">deployment.apps/pc-deployment resumed</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看最后的更新情况</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get rs -n dev -o wide</span><br><span class="line">NAME                       DESIRED   CURRENT   READY   AGE     CONTAINERS   IMAGES         </span><br><span class="line">pc-deployment-5d89bdfbf9   0         0         0       21m     nginx        nginx:1.17.1   </span><br><span class="line">pc-deployment-675d469f8b   0         0         0       16m     nginx        nginx:1.17.2   </span><br><span class="line">pc-deployment-6c9f56fcfb   4         4         4       5m11s   nginx        nginx:1.17.4   </span><br><span class="line"></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev</span><br><span class="line">NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc-deployment-6c9f56fcfb-7bfwh   1/1     Running   0          37s</span><br><span class="line">pc-deployment-6c9f56fcfb-996rt   1/1     Running   0          5m27s</span><br><span class="line">pc-deployment-6c9f56fcfb-j2gtj   1/1     Running   0          5m27s</span><br><span class="line">pc-deployment-6c9f56fcfb-rf84v   1/1     Running   0          37s</span><br></pre></td></tr></table></figure>

<p><strong>删除Deployment</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除deployment，其下的rs和pod也将被删除</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl delete -f pc-deployment.yaml</span><br><span class="line">deployment.apps &quot;pc-deployment&quot; deleted</span><br></pre></td></tr></table></figure>

<h4 id="6-4-Horizontal-Pod-Autoscaler-HPA"><a href="#6-4-Horizontal-Pod-Autoscaler-HPA" class="headerlink" title="6.4 Horizontal Pod Autoscaler(HPA)"></a>6.4 Horizontal Pod Autoscaler(HPA)</h4><p>在前面的课程中，我们已经可以实现通过手工执行<code>kubectl scale</code>命令实现Pod扩容或缩容，但是这显然不符合Kubernetes的定位目标–自动化、智能化。 Kubernetes期望可以实现通过监测Pod的使用情况，实现pod数量的自动调整，于是就产生了Horizontal Pod Autoscaler（HPA）这种控制器。</p>
<p>HPA可以获取每个Pod利用率，然后和HPA中定义的指标进行对比，同时计算出需要伸缩的具体值，最后实现Pod的数量的调整。其实HPA与之前的Deployment一样，也属于一种Kubernetes资源对象，它通过追踪分析RC控制的所有目标Pod的负载变化情况，来确定是否需要针对性地调整目标Pod的副本数，这是HPA的实现原理。</p>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200608155858271-165356431070884.png" alt="img"></p>
<p>接下来，我们来做一个实验</p>
<h5 id="6-4-1-安装metrics-server"><a href="#6-4-1-安装metrics-server" class="headerlink" title="6.4.1 安装metrics-server"></a>6.4.1 安装metrics-server</h5><p>metrics-server可以用来收集集群中的资源使用情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装git</span></span><br><span class="line">[root@k8s-master01 ~]# yum install git -y</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取metrics-server, 注意使用的版本</span></span><br><span class="line">[root@k8s-master01 ~]# git clone -b v0.3.6 https://github.com/kubernetes-incubator/metrics-server</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改deployment, 注意修改的是镜像和初始化参数</span></span><br><span class="line">[root@k8s-master01 ~]# cd /root/metrics-server/deploy/1.8+/</span><br><span class="line">[root@k8s-master01 1.8+]# vim metrics-server-deployment.yaml</span><br><span class="line">按图中添加下面选项</span><br><span class="line">hostNetwork: true</span><br><span class="line">image: registry.cn-hangzhou.aliyuncs.com/google_containers/metrics-server-amd64:v0.3.6</span><br><span class="line">args:</span><br><span class="line">- --kubelet-insecure-tls</span><br><span class="line">- --kubelet-preferred-address-types=InternalIP,Hostname,InternalDNS,ExternalDNS,ExternalIP</span><br></pre></td></tr></table></figure>

<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200608163326496-165356431070885.png" alt="image-20200608163326496"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装metrics-server</span></span><br><span class="line">[root@k8s-master01 1.8+]# kubectl apply -f ./</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看pod运行情况</span></span><br><span class="line">[root@k8s-master01 1.8+]# kubectl get pod -n kube-system</span><br><span class="line">metrics-server-6b976979db-2xwbj   1/1     Running   0          90s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用kubectl top node 查看资源使用情况</span></span><br><span class="line">[root@k8s-master01 1.8+]# kubectl top node</span><br><span class="line">NAME           CPU(cores)   CPU%   MEMORY(bytes)   MEMORY%</span><br><span class="line">k8s-master01   289m         14%    1582Mi          54%       </span><br><span class="line">k8s-node01     81m          4%     1195Mi          40%       </span><br><span class="line">k8s-node02     72m          3%     1211Mi          41%  </span><br><span class="line">[root@k8s-master01 1.8+]# kubectl top pod -n kube-system</span><br><span class="line">NAME                              CPU(cores)   MEMORY(bytes)</span><br><span class="line">coredns-6955765f44-7ptsb          3m           9Mi</span><br><span class="line">coredns-6955765f44-vcwr5          3m           8Mi</span><br><span class="line">etcd-master                       14m          145Mi</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">至此,metrics-server安装完成</span></span><br></pre></td></tr></table></figure>

<h5 id="6-4-2-准备deployment和servie"><a href="#6-4-2-准备deployment和servie" class="headerlink" title="6.4.2 准备deployment和servie"></a>6.4.2 准备deployment和servie</h5><p>创建pc-hpa-pod.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">strategy:</span> <span class="comment"># 策略</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span> <span class="comment"># 滚动更新策略</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">        <span class="attr">resources:</span> <span class="comment"># 资源配额</span></span><br><span class="line">          <span class="attr">limits:</span>  <span class="comment"># 限制资源（上限）</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span> <span class="comment"># CPU限制，单位是core数</span></span><br><span class="line">          <span class="attr">requests:</span> <span class="comment"># 请求资源（下限）</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">&quot;100m&quot;</span>  <span class="comment"># CPU限制，单位是core数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建deployment</span></span><br><span class="line">[root@k8s-master01 1.8+]# kubectl run nginx --image=nginx:1.17.1 --requests=cpu=100m -n dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建service</span></span><br><span class="line">[root@k8s-master01 1.8+]# kubectl expose deployment nginx --type=NodePort --port=80 -n dev</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span></span><br><span class="line">[root@k8s-master01 1.8+]# kubectl get deployment,pod,svc -n dev</span><br><span class="line">NAME                    READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">deployment.apps/nginx   1/1     1            1           47s</span><br><span class="line"></span><br><span class="line">NAME                         READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/nginx-7df9756ccc-bh8dr   1/1     Running   0          47s</span><br><span class="line"></span><br><span class="line">NAME            TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">service/nginx   NodePort   10.101.18.29   &lt;none&gt;        80:31830/TCP   35s</span><br></pre></td></tr></table></figure>

<h5 id="6-4-3-部署HPA"><a href="#6-4-3-部署HPA" class="headerlink" title="6.4.3 部署HPA"></a>6.4.3 部署HPA</h5><p>创建pc-hpa.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-hpa</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">1</span>  <span class="comment">#最小pod数量</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span> <span class="comment">#最大pod数量</span></span><br><span class="line">  <span class="attr">targetCPUUtilizationPercentage:</span> <span class="number">3</span> <span class="comment"># CPU使用率指标</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span>   <span class="comment"># 指定要控制的nginx信息</span></span><br><span class="line">    <span class="attr">apiVersion:</span>  <span class="string">/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建hpa</span></span><br><span class="line">[root@k8s-master01 1.8+]# kubectl create -f pc-hpa.yaml</span><br><span class="line">horizontalpodautoscaler.autoscaling/pc-hpa created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看hpa</span></span><br><span class="line">    [root@k8s-master01 1.8+]# kubectl get hpa -n dev</span><br><span class="line">NAME     REFERENCE          TARGETS   MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">pc-hpa   Deployment/nginx   0%/3%     1         10        1          62s</span><br></pre></td></tr></table></figure>

<h5 id="6-4-4-测试"><a href="#6-4-4-测试" class="headerlink" title="6.4.4 测试"></a>6.4.4 测试</h5><p>使用压测工具对service地址<code>192.168.5.4:31830</code>进行压测，然后通过控制台查看hpa和pod的变化</p>
<p>hpa变化</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-master01 ~]# kubectl get hpa -n dev -w</span><br><span class="line">NAME   REFERENCE      TARGETS  MINPODS  MAXPODS  REPLICAS  AGE</span><br><span class="line">pc-hpa  Deployment/nginx  0%/3%   1     10     1      4m11s</span><br><span class="line">pc-hpa  Deployment/nginx  0%/3%   1     10     1      5m19s</span><br><span class="line">pc-hpa  Deployment/nginx  22%/3%   1     10     1      6m50s</span><br><span class="line">pc-hpa  Deployment/nginx  22%/3%   1     10     4      7m5s</span><br><span class="line">pc-hpa  Deployment/nginx  22%/3%   1     10     8      7m21s</span><br><span class="line">pc-hpa  Deployment/nginx  6%/3%   1     10     8      7m51s</span><br><span class="line">pc-hpa  Deployment/nginx  0%/3%   1     10     8      9m6s</span><br><span class="line">pc-hpa  Deployment/nginx  0%/3%   1     10     8      13m</span><br><span class="line">pc-hpa  Deployment/nginx  0%/3%   1     10     1      14m</span><br></pre></td></tr></table></figure>

<p>deployment变化</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-master01 ~]# kubectl get deployment -n dev -w</span><br><span class="line">NAME    READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx   1/1     1            1           11m</span><br><span class="line">nginx   1/4     1            1           13m</span><br><span class="line">nginx   1/4     1            1           13m</span><br><span class="line">nginx   1/4     1            1           13m</span><br><span class="line">nginx   1/4     4            1           13m</span><br><span class="line">nginx   1/8     4            1           14m</span><br><span class="line">nginx   1/8     4            1           14m</span><br><span class="line">nginx   1/8     4            1           14m</span><br><span class="line">nginx   1/8     8            1           14m</span><br><span class="line">nginx   2/8     8            2           14m</span><br><span class="line">nginx   3/8     8            3           14m</span><br><span class="line">nginx   4/8     8            4           14m</span><br><span class="line">nginx   5/8     8            5           14m</span><br><span class="line">nginx   6/8     8            6           14m</span><br><span class="line">nginx   7/8     8            7           14m</span><br><span class="line">nginx   8/8     8            8           15m</span><br><span class="line">nginx   8/1     8            8           20m</span><br><span class="line">nginx   8/1     8            8           20m</span><br><span class="line">nginx   1/1     1            1           20m</span><br></pre></td></tr></table></figure>

<p>pod变化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev -w</span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-7df9756ccc-bh8dr   1/1     Running   0          11m</span><br><span class="line">nginx-7df9756ccc-cpgrv   0/1     Pending   0          0s</span><br><span class="line">nginx-7df9756ccc-8zhwk   0/1     Pending   0          0s</span><br><span class="line">nginx-7df9756ccc-rr9bn   0/1     Pending   0          0s</span><br><span class="line">nginx-7df9756ccc-cpgrv   0/1     ContainerCreating   0          0s</span><br><span class="line">nginx-7df9756ccc-8zhwk   0/1     ContainerCreating   0          0s</span><br><span class="line">nginx-7df9756ccc-rr9bn   0/1     ContainerCreating   0          0s</span><br><span class="line">nginx-7df9756ccc-m9gsj   0/1     Pending             0          0s</span><br><span class="line">nginx-7df9756ccc-g56qb   0/1     Pending             0          0s</span><br><span class="line">nginx-7df9756ccc-sl9c6   0/1     Pending             0          0s</span><br><span class="line">nginx-7df9756ccc-fgst7   0/1     Pending             0          0s</span><br><span class="line">nginx-7df9756ccc-g56qb   0/1     ContainerCreating   0          0s</span><br><span class="line">nginx-7df9756ccc-m9gsj   0/1     ContainerCreating   0          0s</span><br><span class="line">nginx-7df9756ccc-sl9c6   0/1     ContainerCreating   0          0s</span><br><span class="line">nginx-7df9756ccc-fgst7   0/1     ContainerCreating   0          0s</span><br><span class="line">nginx-7df9756ccc-8zhwk   1/1     Running             0          19s</span><br><span class="line">nginx-7df9756ccc-rr9bn   1/1     Running             0          30s</span><br><span class="line">nginx-7df9756ccc-m9gsj   1/1     Running             0          21s</span><br><span class="line">nginx-7df9756ccc-cpgrv   1/1     Running             0          47s</span><br><span class="line">nginx-7df9756ccc-sl9c6   1/1     Running             0          33s</span><br><span class="line">nginx-7df9756ccc-g56qb   1/1     Running             0          48s</span><br><span class="line">nginx-7df9756ccc-fgst7   1/1     Running             0          66s</span><br><span class="line">nginx-7df9756ccc-fgst7   1/1     Terminating         0          6m50s</span><br><span class="line">nginx-7df9756ccc-8zhwk   1/1     Terminating         0          7m5s</span><br><span class="line">nginx-7df9756ccc-cpgrv   1/1     Terminating         0          7m5s</span><br><span class="line">nginx-7df9756ccc-g56qb   1/1     Terminating         0          6m50s</span><br><span class="line">nginx-7df9756ccc-rr9bn   1/1     Terminating         0          7m5s</span><br><span class="line">nginx-7df9756ccc-m9gsj   1/1     Terminating         0          6m50s</span><br><span class="line">nginx-7df9756ccc-sl9c6   1/1     Terminating         0          6m50s</span><br></pre></td></tr></table></figure>

<h4 id="6-5-DaemonSet-DS"><a href="#6-5-DaemonSet-DS" class="headerlink" title="6.5 DaemonSet(DS)"></a>6.5 DaemonSet(DS)</h4><p>DaemonSet类型的控制器可以保证在集群中的每一台（或指定）节点上都运行一个副本。一般适用于日志收集、节点监控等场景。也就是说，如果一个Pod提供的功能是节点级别的（每个节点都需要且只需要一个），那么这类Pod就适合使用DaemonSet类型的控制器创建。</p>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200612010223537-165356431070886.png" alt="img"></p>
<p>DaemonSet控制器的特点：</p>
<ul>
<li>每当向集群中添加一个节点时，指定的 Pod 副本也将添加到该节点上</li>
<li>当节点从集群中移除时，Pod 也就被垃圾回收了</li>
</ul>
<p>下面先来看下DaemonSet的资源清单文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span> <span class="comment"># 类型       </span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="comment"># rs名称 </span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="comment"># 所属命名空间 </span></span><br><span class="line">  <span class="attr">labels:</span> <span class="comment">#标签</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="string">daemonset</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 详情描述</span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">3</span> <span class="comment"># 保留历史版本</span></span><br><span class="line">  <span class="attr">updateStrategy:</span> <span class="comment"># 更新策略</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span> <span class="comment"># 滚动更新策略</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span> <span class="comment"># 滚动更新</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">1</span> <span class="comment"># 最大不可用状态的 Pod 的最大值，可以为百分比，也可以为整数</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 选择器，通过它指定该控制器管理哪些pod</span></span><br><span class="line">    <span class="attr">matchLabels:</span>      <span class="comment"># Labels匹配规则</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">matchExpressions:</span> <span class="comment"># Expressions匹配规则</span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">key:</span> <span class="string">app</span>, <span class="attr">operator:</span> <span class="string">In</span>, <span class="attr">values:</span> [<span class="string">nginx-pod</span>]&#125;</span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># 模板，当副本数量不足时，会根据下面的模板创建pod副本</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>创建pc-daemonset.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span>      </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-daemonset</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建daemonset</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f  pc-daemonset.yaml</span><br><span class="line">daemonset.apps/pc-daemonset created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看daemonset</span></span><br><span class="line">[root@k8s-master01 ~]#  kubectl get ds -n dev -o wide</span><br><span class="line">NAME        DESIRED  CURRENT  READY  UP-TO-DATE  AVAILABLE   AGE   CONTAINERS   IMAGES         </span><br><span class="line">pc-daemonset   2        2        2      2           2        24s   nginx        nginx:1.17.1   </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看pod,发现在每个Node上都运行一个pod</span></span><br><span class="line">[root@k8s-master01 ~]#  kubectl get pods -n dev -o wide</span><br><span class="line">NAME                 READY   STATUS    RESTARTS   AGE   IP            NODE    </span><br><span class="line">pc-daemonset-9bck8   1/1     Running   0          37s   10.244.1.43   node1     </span><br><span class="line">pc-daemonset-k224w   1/1     Running   0          37s   10.244.2.74   node2      </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除daemonset</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl delete -f pc-daemonset.yaml</span><br><span class="line">daemonset.apps &quot;pc-daemonset&quot; deleted</span><br></pre></td></tr></table></figure>

<h4 id="6-6-Job"><a href="#6-6-Job" class="headerlink" title="6.6 Job"></a>6.6 Job</h4><p>Job，主要用于负责**批量处理(一次要处理指定数量任务)<strong>短暂的</strong>一次性(每个任务仅运行一次就结束)**任务。Job特点如下：</p>
<ul>
<li>当Job创建的pod执行成功结束时，Job将记录成功结束的pod数量</li>
<li>当成功结束的pod达到指定的数量时，Job将完成执行</li>
</ul>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200618213054113-165356431070887.png" alt="img"></p>
<p>Job的资源清单文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span> <span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span> <span class="comment"># 类型       </span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="comment"># rs名称 </span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="comment"># 所属命名空间 </span></span><br><span class="line">  <span class="attr">labels:</span> <span class="comment">#标签</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="string">job</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 详情描述</span></span><br><span class="line">  <span class="attr">completions:</span> <span class="number">1</span> <span class="comment"># 指定job需要成功运行Pods的次数。默认值: 1</span></span><br><span class="line">  <span class="attr">parallelism:</span> <span class="number">1</span> <span class="comment"># 指定job在任一时刻应该并发运行Pods的数量。默认值: 1</span></span><br><span class="line">  <span class="attr">activeDeadlineSeconds:</span> <span class="number">30</span> <span class="comment"># 指定job可运行的时间期限，超过时间还未结束，系统将会尝试进行终止。</span></span><br><span class="line">  <span class="attr">backoffLimit:</span> <span class="number">6</span> <span class="comment"># 指定job失败后进行重试的次数。默认是6</span></span><br><span class="line">  <span class="attr">manualSelector:</span> <span class="literal">true</span> <span class="comment"># 是否可以使用selector选择器选择pod，默认是false</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 选择器，通过它指定该控制器管理哪些pod</span></span><br><span class="line">    <span class="attr">matchLabels:</span>      <span class="comment"># Labels匹配规则</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">counter-pod</span></span><br><span class="line">    <span class="attr">matchExpressions:</span> <span class="comment"># Expressions匹配规则</span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">key:</span> <span class="string">app</span>, <span class="attr">operator:</span> <span class="string">In</span>, <span class="attr">values:</span> [<span class="string">counter-pod</span>]&#125;</span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># 模板，当副本数量不足时，会根据下面的模板创建pod副本</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">counter-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Never</span> <span class="comment"># 重启策略只能设置为Never或者OnFailure</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">counter</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 2;done&quot;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">关于重启策略设置的说明：</span><br><span class="line"><span class="code">    如果指定为OnFailure，则job会在pod出现故障时重启容器，而不是创建pod，failed次数不变</span></span><br><span class="line"><span class="code">    如果指定为Never，则job会在pod出现故障时创建新的pod，并且故障pod不会消失，也不会重启，failed次数加1</span></span><br><span class="line"><span class="code">    如果指定为Always的话，就意味着一直重启，意味着job任务会重复去执行了，当然不对，所以不能设置为Always</span></span><br></pre></td></tr></table></figure>

<p>创建pc-job.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span>      </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-job</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">manualSelector:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">counter-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">counter-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">counter</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 3;done&quot;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建job</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pc-job.yaml</span><br><span class="line">job.batch/pc-job created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看job</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get job -n dev -o wide  -w</span><br><span class="line">NAME     COMPLETIONS   DURATION   AGE   CONTAINERS   IMAGES         SELECTOR</span><br><span class="line">pc-job   0/1           21s        21s   counter      busybox:1.30   app=counter-pod</span><br><span class="line">pc-job   1/1           31s        79s   counter      busybox:1.30   app=counter-pod</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过观察pod状态可以看到，pod在运行完毕任务后，就会变成Completed状态</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev -w</span><br><span class="line">NAME           READY   STATUS     RESTARTS      AGE</span><br><span class="line">pc-job-rxg96   1/1     Running     0            29s</span><br><span class="line">pc-job-rxg96   0/1     Completed   0            33s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">接下来，调整下pod运行的总数量和并行数量 即：在spec下设置下面两个选项</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> completions: 6 <span class="comment"># 指定job需要成功运行Pods的次数为6</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> parallelism: 3 <span class="comment"># 指定job并发运行Pods的数量为3</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> 然后重新运行job，观察效果，此时会发现，job会每次运行3个pod，总共执行了6个pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev -w</span><br><span class="line">NAME           READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc-job-684ft   1/1     Running   0          5s</span><br><span class="line">pc-job-jhj49   1/1     Running   0          5s</span><br><span class="line">pc-job-pfcvh   1/1     Running   0          5s</span><br><span class="line">pc-job-684ft   0/1     Completed   0          11s</span><br><span class="line">pc-job-v7rhr   0/1     Pending     0          0s</span><br><span class="line">pc-job-v7rhr   0/1     Pending     0          0s</span><br><span class="line">pc-job-v7rhr   0/1     ContainerCreating   0          0s</span><br><span class="line">pc-job-jhj49   0/1     Completed           0          11s</span><br><span class="line">pc-job-fhwf7   0/1     Pending             0          0s</span><br><span class="line">pc-job-fhwf7   0/1     Pending             0          0s</span><br><span class="line">pc-job-pfcvh   0/1     Completed           0          11s</span><br><span class="line">pc-job-5vg2j   0/1     Pending             0          0s</span><br><span class="line">pc-job-fhwf7   0/1     ContainerCreating   0          0s</span><br><span class="line">pc-job-5vg2j   0/1     Pending             0          0s</span><br><span class="line">pc-job-5vg2j   0/1     ContainerCreating   0          0s</span><br><span class="line">pc-job-fhwf7   1/1     Running             0          2s</span><br><span class="line">pc-job-v7rhr   1/1     Running             0          2s</span><br><span class="line">pc-job-5vg2j   1/1     Running             0          3s</span><br><span class="line">pc-job-fhwf7   0/1     Completed           0          12s</span><br><span class="line">pc-job-v7rhr   0/1     Completed           0          12s</span><br><span class="line">pc-job-5vg2j   0/1     Completed           0          12s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除job</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl delete -f pc-job.yaml</span><br><span class="line">job.batch &quot;pc-job&quot; deleted</span><br></pre></td></tr></table></figure>

<h4 id="6-7-CronJob-CJ"><a href="#6-7-CronJob-CJ" class="headerlink" title="6.7 CronJob(CJ)"></a>6.7 CronJob(CJ)</h4><p>CronJob控制器以 Job控制器资源为其管控对象，并借助它管理pod资源对象，Job控制器定义的作业任务在其控制器资源创建之后便会立即执行，但CronJob可以以类似于Linux操作系统的周期性任务作业计划的方式控制其运行<strong>时间点</strong>及<strong>重复运行</strong>的方式。也就是说，<strong>CronJob可以在特定的时间点(反复的)去运行job任务</strong>。</p>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200618213149531-165356431070888.png" alt="img"></p>
<p>CronJob的资源清单文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1beta1</span> <span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span> <span class="comment"># 类型       </span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="comment"># rs名称 </span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="comment"># 所属命名空间 </span></span><br><span class="line">  <span class="attr">labels:</span> <span class="comment">#标签</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="string">cronjob</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 详情描述</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="comment"># cron格式的作业调度运行时间点,用于控制任务在什么时间执行</span></span><br><span class="line">  <span class="attr">concurrencyPolicy:</span> <span class="comment"># 并发执行策略，用于定义前一次作业运行尚未完成时是否以及如何运行后一次的作业</span></span><br><span class="line">  <span class="attr">failedJobHistoryLimit:</span> <span class="comment"># 为失败的任务执行保留的历史记录数，默认为1</span></span><br><span class="line">  <span class="attr">successfulJobHistoryLimit:</span> <span class="comment"># 为成功的任务执行保留的历史记录数，默认为3</span></span><br><span class="line">  <span class="attr">startingDeadlineSeconds:</span> <span class="comment"># 启动作业错误的超时时长</span></span><br><span class="line">  <span class="attr">jobTemplate:</span> <span class="comment"># job控制器模板，用于为cronjob控制器生成job对象;下面其实就是job的定义</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">completions:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">parallelism:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">activeDeadlineSeconds:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">backoffLimit:</span> <span class="number">6</span></span><br><span class="line">      <span class="attr">manualSelector:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">selector:</span></span><br><span class="line">        <span class="attr">matchLabels:</span></span><br><span class="line">          <span class="attr">app:</span> <span class="string">counter-pod</span></span><br><span class="line">        <span class="attr">matchExpressions:</span> <span class="string">规则</span></span><br><span class="line">          <span class="bullet">-</span> &#123;<span class="attr">key:</span> <span class="string">app</span>, <span class="attr">operator:</span> <span class="string">In</span>, <span class="attr">values:</span> [<span class="string">counter-pod</span>]&#125;</span><br><span class="line">      <span class="attr">template:</span></span><br><span class="line">        <span class="attr">metadata:</span></span><br><span class="line">          <span class="attr">labels:</span></span><br><span class="line">            <span class="attr">app:</span> <span class="string">counter-pod</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">restartPolicy:</span> <span class="string">Never</span> </span><br><span class="line">          <span class="attr">containers:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">counter</span></span><br><span class="line">            <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">            <span class="attr">command:</span> [<span class="string">&quot;bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 20;done&quot;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">需要重点解释的几个选项：</span><br><span class="line">schedule: cron表达式，用于指定任务的执行时间</span><br><span class="line"><span class="code">    */1    *      *    *     *</span></span><br><span class="line"><span class="code">    &lt;分钟&gt; &lt;小时&gt; &lt;日&gt; &lt;月份&gt; &lt;星期&gt;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    分钟 值从 0 到 59.</span></span><br><span class="line"><span class="code">    小时 值从 0 到 23.</span></span><br><span class="line"><span class="code">    日 值从 1 到 31.</span></span><br><span class="line"><span class="code">    月 值从 1 到 12.</span></span><br><span class="line"><span class="code">    星期 值从 0 到 6, 0 代表星期日</span></span><br><span class="line"><span class="code">    多个时间可以用逗号隔开； 范围可以用连字符给出；*可以作为通配符； /表示每...</span></span><br><span class="line"><span class="code">concurrencyPolicy:</span></span><br><span class="line"><span class="code">    Allow:   允许Jobs并发运行(默认)</span></span><br><span class="line"><span class="code">    Forbid:  禁止并发运行，如果上一次运行尚未完成，则跳过下一次运行</span></span><br><span class="line"><span class="code">    Replace: 替换，取消当前正在运行的作业并用新作业替换它</span></span><br></pre></td></tr></table></figure>

<p>创建pc-cronjob.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-cronjob</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="string">cronjob</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">&quot;*/1 * * * *&quot;</span></span><br><span class="line">  <span class="attr">jobTemplate:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">template:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line">          <span class="attr">containers:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">counter</span></span><br><span class="line">            <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">            <span class="attr">command:</span> [<span class="string">&quot;bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 3;done&quot;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建cronjob</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pc-cronjob.yaml</span><br><span class="line">cronjob.batch/pc-cronjob created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看cronjob</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get cronjobs -n dev</span><br><span class="line">NAME         SCHEDULE      SUSPEND   ACTIVE   LAST SCHEDULE   AGE</span><br><span class="line">pc-cronjob   */1 * * * *   False     0        &lt;none&gt;          6s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看job</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get jobs -n dev</span><br><span class="line">NAME                    COMPLETIONS   DURATION   AGE</span><br><span class="line">pc-cronjob-1592587800   1/1           28s        3m26s</span><br><span class="line">pc-cronjob-1592587860   1/1           28s        2m26s</span><br><span class="line">pc-cronjob-1592587920   1/1           28s        86s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev</span><br><span class="line">pc-cronjob-1592587800-x4tsm   0/1     Completed   0          2m24s</span><br><span class="line">pc-cronjob-1592587860-r5gv4   0/1     Completed   0          84s</span><br><span class="line">pc-cronjob-1592587920-9dxxq   1/1     Running     0          24s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除cronjob</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl  delete -f pc-cronjob.yaml</span><br><span class="line">cronjob.batch &quot;pc-cronjob&quot; deleted</span><br></pre></td></tr></table></figure>

<h3 id="7-Service详解"><a href="#7-Service详解" class="headerlink" title="7. Service详解"></a>7. Service详解</h3><h4 id="7-1-Service介绍"><a href="#7-1-Service介绍" class="headerlink" title="7.1 Service介绍"></a>7.1 Service介绍</h4><p>在kubernetes中，pod是应用程序的载体，我们可以通过pod的ip来访问应用程序，但是pod的ip地址不是固定的，这也就意味着不方便直接采用pod的ip对服务进行访问。</p>
<p>为了解决这个问题，kubernetes提供了Service资源，Service会对提供同一个服务的多个pod进行聚合，并且提供一个统一的入口地址。通过访问Service的入口地址就能访问到后面的pod服务。</p>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200408194716912-1626783758946-165356431070889.png" alt="img"></p>
<p>Service在很多情况下只是一个概念，真正起作用的其实是kube-proxy服务进程，每个Node节点上都运行着一个kube-proxy服务进程。当创建Service的时候会通过api-server向etcd写入创建的service的信息，而kube-proxy会基于监听的机制发现这种Service的变动，然后<strong>它会将最新的Service信息转换成对应的访问规则</strong>。</p>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200509121254425-165356431070890.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 10.97.97.97:80 是service提供的访问入口</span><br><span class="line"># 当访问这个入口的时候，可以发现后面有三个pod的服务在等待调用，</span><br><span class="line"># kube-proxy会基于rr（轮询）的策略，将请求分发到其中一个pod上去</span><br><span class="line"># 这个规则会同时在集群内的所有节点上都生成，所以在任何一个节点上访问都可以。</span><br><span class="line">[root@node1 ~]# ipvsadm -Ln</span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br><span class="line">TCP  10.97.97.97:80 rr</span><br><span class="line">  -&gt; 10.244.1.39:80               Masq    1      0          0</span><br><span class="line">  -&gt; 10.244.1.40:80               Masq    1      0          0</span><br><span class="line">  -&gt; 10.244.2.33:80               Masq    1      0          0</span><br></pre></td></tr></table></figure>

<p>kube-proxy目前支持三种工作模式:</p>
<h5 id="7-1-1-userspace-模式"><a href="#7-1-1-userspace-模式" class="headerlink" title="7.1.1 userspace 模式"></a>7.1.1 userspace 模式</h5><p>userspace模式下，kube-proxy会为每一个Service创建一个监听端口，发向Cluster IP的请求被Iptables规则重定向到kube-proxy监听的端口上，kube-proxy根据LB算法选择一个提供服务的Pod并和其建立链接，以将请求转发到Pod上。  该模式下，kube-proxy充当了一个四层负责均衡器的角色。由于kube-proxy运行在userspace中，在进行转发处理时会增加内核和用户空间之间的数据拷贝，虽然比较稳定，但是效率比较低。</p>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200509151424280-165356431070891.png" alt="img"></p>
<h5 id="7-1-2-iptables-模式"><a href="#7-1-2-iptables-模式" class="headerlink" title="7.1.2 iptables 模式"></a>7.1.2 iptables 模式</h5><p>iptables模式下，kube-proxy为service后端的每个Pod创建对应的iptables规则，直接将发向Cluster IP的请求重定向到一个Pod IP。  该模式下kube-proxy不承担四层负责均衡器的角色，只负责创建iptables规则。该模式的优点是较userspace模式效率更高，但不能提供灵活的LB策略，当后端Pod不可用时也无法进行重试。</p>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200509152947714-165356431070893.png" alt="img"></p>
<h5 id="7-1-3-ipvs-模式"><a href="#7-1-3-ipvs-模式" class="headerlink" title="7.1.3 ipvs 模式"></a>7.1.3 ipvs 模式</h5><p>ipvs模式和iptables类似，kube-proxy监控Pod的变化并创建相应的ipvs规则。ipvs相对iptables转发效率更高。除此以外，ipvs支持更多的LB算法。</p>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200509153731363-165356431070892.png" alt="img"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此模式必须安装ipvs内核模块，否则会降级为iptables</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启ipvs</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl edit cm kube-proxy -n kube-system</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改mode: <span class="string">&quot;ipvs&quot;</span></span></span><br><span class="line">[root@k8s-master01 ~]# kubectl delete pod -l k8s-app=kube-proxy -n kube-system</span><br><span class="line">[root@node1 ~]# ipvsadm -Ln</span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash">RemoteAddress:Port           Forward Weight ActiveConn InActConn</span></span><br><span class="line">TCP  10.97.97.97:80 rr</span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash">10.244.1.39:80               Masq    1      0          0</span></span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash">10.244.1.40:80               Masq    1      0          0</span></span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash">10.244.2.33:80               Masq    1      0          0</span></span><br></pre></td></tr></table></figure>

<h4 id="7-2-Service类型"><a href="#7-2-Service类型" class="headerlink" title="7.2 Service类型"></a>7.2 Service类型</h4><p>Service的资源清单文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span>  <span class="comment"># 资源类型</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  <span class="comment"># 资源版本</span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">service</span> <span class="comment"># 资源名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span> <span class="comment"># 命名空间</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 描述</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 标签选择器，用于确定当前service代理哪些pod</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">type:</span> <span class="comment"># Service类型，指定service的访问方式</span></span><br><span class="line">  <span class="attr">clusterIP:</span>  <span class="comment"># 虚拟服务的ip地址</span></span><br><span class="line">  <span class="attr">sessionAffinity:</span> <span class="comment"># session亲和性，支持ClientIP、None两个选项</span></span><br><span class="line">  <span class="attr">ports:</span> <span class="comment"># 端口信息</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span> </span><br><span class="line">      <span class="attr">port:</span> <span class="number">3017</span>  <span class="comment"># service端口</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">5003</span> <span class="comment"># pod端口</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">31122</span> <span class="comment"># 主机端口</span></span><br></pre></td></tr></table></figure>

<ul>
<li>ClusterIP：默认值，它是Kubernetes系统自动分配的虚拟IP，只能在集群内部访问</li>
<li>NodePort：将Service通过指定的Node上的端口暴露给外部，通过此方法，就可以在集群外部访问服务</li>
<li>LoadBalancer：使用外接负载均衡器完成到服务的负载分发，注意此模式需要外部云环境支持</li>
<li>ExternalName： 把集群外部的服务引入集群内部，直接使用</li>
</ul>
<h4 id="7-3-Service使用"><a href="#7-3-Service使用" class="headerlink" title="7.3 Service使用"></a>7.3 Service使用</h4><h5 id="7-3-1-实验环境准备"><a href="#7-3-1-实验环境准备" class="headerlink" title="7.3.1 实验环境准备"></a>7.3.1 实验环境准备</h5><p>在使用service之前，首先利用Deployment创建出3个pod，注意要为pod设置<code>app=nginx-pod</code>的标签</p>
<p>创建deployment.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>      </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-deployment</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-master01 ~]# kubectl create -f deployment.yaml</span><br><span class="line">deployment.apps/pc-deployment created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看pod详情</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev -o wide --show-labels</span><br><span class="line">NAME                             READY   STATUS     IP            NODE     LABELS</span><br><span class="line">pc-deployment-66cb59b984-8p84h   1/1     Running    10.244.1.39   node1    app=nginx-pod</span><br><span class="line">pc-deployment-66cb59b984-vx8vx   1/1     Running    10.244.2.33   node2    app=nginx-pod</span><br><span class="line">pc-deployment-66cb59b984-wnncx   1/1     Running    10.244.1.40   node1    app=nginx-pod</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为了方便后面的测试，修改下三台nginx的index.html页面（三台修改的IP地址不一致）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kubectl <span class="built_in">exec</span> -it pc-deployment-66cb59b984-8p84h -n dev /bin/sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;10.244.1.39&quot;</span> &gt; /usr/share/nginx/html/index.html</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改完毕之后，访问测试</span></span><br><span class="line">[root@k8s-master01 ~]# curl 10.244.1.39</span><br><span class="line">10.244.1.39</span><br><span class="line">[root@k8s-master01 ~]# curl 10.244.2.33</span><br><span class="line">10.244.2.33</span><br><span class="line">[root@k8s-master01 ~]# curl 10.244.1.40</span><br><span class="line">10.244.1.40</span><br></pre></td></tr></table></figure>

<h5 id="7-3-2-ClusterIP类型的Service"><a href="#7-3-2-ClusterIP类型的Service" class="headerlink" title="7.3.2 ClusterIP类型的Service"></a>7.3.2 ClusterIP类型的Service</h5><p>创建service-clusterip.yaml文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">service-clusterip</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="number">10.97</span><span class="number">.97</span><span class="number">.97</span> <span class="comment"># service的ip地址，如果不写，默认会生成一个</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span>  <span class="comment"># Service端口       </span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span> <span class="comment"># pod端口</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建service</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f service-clusterip.yaml</span><br><span class="line">service/service-clusterip created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看service</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get svc -n dev -o wide</span><br><span class="line">NAME                TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)   AGE   SELECTOR</span><br><span class="line">service-clusterip   ClusterIP   10.97.97.97   &lt;none&gt;        80/TCP    13s   app=nginx-pod</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看service的详细信息</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在这里有一个Endpoints列表，里面就是当前service可以负载到的服务入口</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl describe svc service-clusterip -n dev</span><br><span class="line">Name:              service-clusterip</span><br><span class="line">Namespace:         dev</span><br><span class="line">Labels:            &lt;none&gt;</span><br><span class="line">Annotations:       &lt;none&gt;</span><br><span class="line">Selector:          app=nginx-pod</span><br><span class="line">Type:              ClusterIP</span><br><span class="line">IP:                10.97.97.97</span><br><span class="line">Port:              &lt;unset&gt;  80/TCP</span><br><span class="line">TargetPort:        80/TCP</span><br><span class="line">Endpoints:         10.244.1.39:80,10.244.1.40:80,10.244.2.33:80</span><br><span class="line">Session Affinity:  None</span><br><span class="line">Events:            &lt;none&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看ipvs的映射规则</span></span><br><span class="line">[root@k8s-master01 ~]# ipvsadm -Ln</span><br><span class="line">TCP  10.97.97.97:80 rr</span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash">10.244.1.39:80               Masq    1      0          0</span></span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash">10.244.1.40:80               Masq    1      0          0</span></span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash">10.244.2.33:80               Masq    1      0          0</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">访问10.97.97.97:80观察效果</span></span><br><span class="line">[root@k8s-master01 ~]# curl 10.97.97.97:80</span><br><span class="line">10.244.2.33</span><br></pre></td></tr></table></figure>

<h5 id="7-3-3-Endpoint"><a href="#7-3-3-Endpoint" class="headerlink" title="7.3.3 Endpoint"></a>7.3.3 Endpoint</h5><p>Endpoint是kubernetes中的一个资源对象，存储在etcd中，用来记录一个service对应的所有pod的访问地址，它是根据service配置文件中selector描述产生的。</p>
<p>一个Service由一组Pod组成，这些Pod通过Endpoints暴露出来，<strong>Endpoints是实现实际服务的端点集合</strong>。换句话说，service和pod之间的联系是通过endpoints实现的。</p>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200509191917069-165356431070894.png" alt="image-20200509191917069"></p>
<p><strong>负载分发策略</strong></p>
<p>对Service的访问被分发到了后端的Pod上去，目前kubernetes提供了两种负载分发策略：</p>
<ul>
<li><p>如果不定义，默认使用kube-proxy的策略，比如随机、轮询</p>
</li>
<li><p>基于客户端地址的会话保持模式，即来自同一个客户端发起的所有请求都会转发到固定的一个Pod上</p>
<p>此模式可以使在spec中添加<code>sessionAffinity:ClientIP</code>选项</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看ipvs的映射规则【rr 轮询】</span></span><br><span class="line">[root@k8s-master01 ~]# ipvsadm -Ln</span><br><span class="line">TCP  10.97.97.97:80 rr</span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash">10.244.1.39:80               Masq    1      0          0</span></span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash">10.244.1.40:80               Masq    1      0          0</span></span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash">10.244.2.33:80               Masq    1      0          0</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">循环访问测试</span></span><br><span class="line">[root@k8s-master01 ~]# while true;do curl 10.97.97.97:80; sleep 5; done;</span><br><span class="line">10.244.1.40</span><br><span class="line">10.244.1.39</span><br><span class="line">10.244.2.33</span><br><span class="line">10.244.1.40</span><br><span class="line">10.244.1.39</span><br><span class="line">10.244.2.33</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改分发策略----sessionAffinity:ClientIP</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看ipvs规则【persistent 代表持久】</span></span><br><span class="line">[root@k8s-master01 ~]# ipvsadm -Ln</span><br><span class="line">TCP  10.97.97.97:80 rr persistent 10800</span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash">10.244.1.39:80               Masq    1      0          0</span></span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash">10.244.1.40:80               Masq    1      0          0</span></span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash">10.244.2.33:80               Masq    1      0          0</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">循环访问测试</span></span><br><span class="line">[root@k8s-master01 ~]# while true;do curl 10.97.97.97; sleep 5; done;</span><br><span class="line">10.244.2.33</span><br><span class="line">10.244.2.33</span><br><span class="line">10.244.2.33</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除service</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl delete -f service-clusterip.yaml</span><br><span class="line">service &quot;service-clusterip&quot; deleted</span><br></pre></td></tr></table></figure>

<h5 id="7-3-4-HeadLiness类型的Service"><a href="#7-3-4-HeadLiness类型的Service" class="headerlink" title="7.3.4 HeadLiness类型的Service"></a>7.3.4 HeadLiness类型的Service</h5><p>在某些场景中，开发人员可能不想使用Service提供的负载均衡功能，而希望自己来控制负载均衡策略，针对这种情况，kubernetes提供了HeadLiness Service，这类Service不会分配Cluster IP，如果想要访问service，只能通过service的域名进行查询。</p>
<p>创建service-headliness.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">service-headliness</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span> <span class="comment"># 将clusterIP设置为None，即可创建headliness Service</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span>    </span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建service</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f service-headliness.yaml</span><br><span class="line">service/service-headliness created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取service， 发现CLUSTER-IP未分配</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get svc service-headliness -n dev -o wide</span><br><span class="line">NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE   SELECTOR</span><br><span class="line">service-headliness   ClusterIP   None         &lt;none&gt;        80/TCP    11s   app=nginx-pod</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看service详情</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl describe svc service-headliness  -n dev</span><br><span class="line">Name:              service-headliness</span><br><span class="line">Namespace:         dev</span><br><span class="line">Labels:            &lt;none&gt;</span><br><span class="line">Annotations:       &lt;none&gt;</span><br><span class="line">Selector:          app=nginx-pod</span><br><span class="line">Type:              ClusterIP</span><br><span class="line">IP:                None</span><br><span class="line">Port:              &lt;unset&gt;  80/TCP</span><br><span class="line">TargetPort:        80/TCP</span><br><span class="line">Endpoints:         10.244.1.39:80,10.244.1.40:80,10.244.2.33:80</span><br><span class="line">Session Affinity:  None</span><br><span class="line">Events:            &lt;none&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看域名的解析情况</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl exec -it pc-deployment-66cb59b984-8p84h -n dev /bin/sh</span><br><span class="line">/ # cat /etc/resolv.conf</span><br><span class="line">nameserver 10.96.0.10</span><br><span class="line">search dev.svc.cluster.local svc.cluster.local cluster.local</span><br><span class="line"></span><br><span class="line">[root@k8s-master01 ~]# dig @10.96.0.10 service-headliness.dev.svc.cluster.local</span><br><span class="line">service-headliness.dev.svc.cluster.local. 30 IN A 10.244.1.40</span><br><span class="line">service-headliness.dev.svc.cluster.local. 30 IN A 10.244.1.39</span><br><span class="line">service-headliness.dev.svc.cluster.local. 30 IN A 10.244.2.33</span><br></pre></td></tr></table></figure>

<h5 id="7-3-5-NodePort类型的Service"><a href="#7-3-5-NodePort类型的Service" class="headerlink" title="7.3.5 NodePort类型的Service"></a>7.3.5 NodePort类型的Service</h5><p>在之前的样例中，创建的Service的ip地址只有集群内部才可以访问，如果希望将Service暴露给集群外部使用，那么就要使用到另外一种类型的Service，称为NodePort类型。NodePort的工作原理其实就是<strong>将service的端口映射到Node的一个端口上</strong>，然后就可以通过<code>NodeIp:NodePort</code>来访问service了。</p>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200620175731338-165356431070995.png" alt="img"></p>
<p>创建service-nodeport.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">service-nodeport</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span> <span class="comment"># service类型</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30002</span> <span class="comment"># 指定绑定的node的端口(默认的取值范围是：30000-32767), 如果不指定，会默认分配</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建service</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f service-nodeport.yaml</span><br><span class="line">service/service-nodeport created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看service</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get svc -n dev -o wide</span><br><span class="line">NAME               TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)       SELECTOR</span><br><span class="line">service-nodeport   NodePort   10.105.64.191   &lt;none&gt;        80:30002/TCP  app=nginx-pod</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">接下来可以通过电脑主机的浏览器去访问集群中任意一个nodeip的30002端口，即可访问到pod</span></span><br></pre></td></tr></table></figure>

<h5 id="7-3-6-LoadBalancer类型的Service"><a href="#7-3-6-LoadBalancer类型的Service" class="headerlink" title="7.3.6 LoadBalancer类型的Service"></a>7.3.6 LoadBalancer类型的Service</h5><p>LoadBalancer和NodePort很相似，目的都是向外部暴露一个端口，区别在于LoadBalancer会在集群的外部再来做一个负载均衡设备，而这个设备需要外部环境支持的，外部服务发送到这个设备上的请求，会被设备负载之后转发到集群中。</p>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200510103945494-165356431070996.png" alt="img"></p>
<h5 id="7-3-7-ExternalName类型的Service"><a href="#7-3-7-ExternalName类型的Service" class="headerlink" title="7.3.7 ExternalName类型的Service"></a>7.3.7 ExternalName类型的Service</h5><p>ExternalName类型的Service用于引入集群外部的服务，它通过<code>externalName</code>属性指定外部一个服务的地址，然后在集群内部访问此service就可以访问到外部的服务了。</p>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200510113311209-165356431070997.png" alt="img"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: service-externalname</span><br><span class="line">  namespace: dev</span><br><span class="line">spec:</span><br><span class="line">  type: ExternalName # service类型</span><br><span class="line">  externalName: www.baidu.com  #改成ip地址也可以</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建service</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl  create -f service-externalname.yaml</span><br><span class="line">service/service-externalname created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">域名解析</span></span><br><span class="line">[root@k8s-master01 ~]# dig @10.96.0.10 service-externalname.dev.svc.cluster.local</span><br><span class="line">service-externalname.dev.svc.cluster.local. 30 IN CNAME www.baidu.com.</span><br><span class="line">www.baidu.com.          30      IN      CNAME   www.a.shifen.com.</span><br><span class="line">www.a.shifen.com.       30      IN      A       39.156.66.18</span><br><span class="line">www.a.shifen.com.       30      IN      A       39.156.66.14</span><br></pre></td></tr></table></figure>

<h4 id="7-4-Ingress介绍"><a href="#7-4-Ingress介绍" class="headerlink" title="7.4 Ingress介绍"></a>7.4 Ingress介绍</h4><p>在前面课程中已经提到，Service对集群之外暴露服务的主要方式有两种：NotePort和LoadBalancer，但是这两种方式，都有一定的缺点：</p>
<ul>
<li>NodePort方式的缺点是会占用很多集群机器的端口，那么当集群服务变多的时候，这个缺点就愈发明显</li>
<li>LB方式的缺点是每个service需要一个LB，浪费、麻烦，并且需要kubernetes之外设备的支持</li>
</ul>
<p>基于这种现状，kubernetes提供了Ingress资源对象，Ingress只需要一个NodePort或者一个LB就可以满足暴露多个Service的需求。工作机制大致如下图表示：</p>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200623092808049-165356431070998.png" alt="img"></p>
<p>实际上，Ingress相当于一个7层的负载均衡器，是kubernetes对反向代理的一个抽象，它的工作原理类似于Nginx，可以理解成在<strong>Ingress里建立诸多映射规则，Ingress Controller通过监听这些配置规则并转化成Nginx的反向代理配置 , 然后对外部提供服务</strong>。在这里有两个核心概念：</p>
<ul>
<li>ingress：kubernetes中的一个对象，作用是定义请求如何转发到service的规则</li>
<li>ingress controller：具体实现反向代理及负载均衡的程序，对ingress定义的规则进行解析，根据配置的规则来实现请求转发，实现方式有很多，比如Nginx, Contour, Haproxy等等</li>
</ul>
<p>Ingress（以Nginx为例）的工作原理如下：</p>
<ol>
<li>用户编写Ingress规则，说明哪个域名对应kubernetes集群中的哪个Service</li>
<li>Ingress控制器动态感知Ingress服务规则的变化，然后生成一段对应的Nginx反向代理配置</li>
<li>Ingress控制器会将生成的Nginx配置写入到一个运行着的Nginx服务中，并动态更新</li>
<li>到此为止，其实真正在工作的就是一个Nginx了，内部配置了用户定义的请求转发规则</li>
</ol>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200516112704764-165356431070999.png" alt="img"></p>
<h4 id="7-5-Ingress使用"><a href="#7-5-Ingress使用" class="headerlink" title="7.5 Ingress使用"></a>7.5 Ingress使用</h4><h5 id="7-5-1-环境准备-搭建ingress环境"><a href="#7-5-1-环境准备-搭建ingress环境" class="headerlink" title="7.5.1 环境准备 搭建ingress环境"></a>7.5.1 环境准备 搭建ingress环境</h5><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建文件夹</span></span><br><span class="line">[root@k8s-master01 ~]<span class="comment"># mkdir ingress-controller</span></span><br><span class="line">[root@k8s-master01 ~]<span class="comment"># cd ingress-controller/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取ingress-nginx，本次案例使用的是0.30版本</span></span><br><span class="line">[root@k8s-master01 ingress-controller]<span class="comment"># wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.30.0/deploy/static/mandatory.yaml</span></span><br><span class="line">[root@k8s-master01 ingress-controller]<span class="comment"># wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.30.0/deploy/static/provider/baremetal/service-nodeport.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改mandatory.yaml文件中的仓库</span></span><br><span class="line"><span class="comment"># 修改quay.io/kubernetes-ingress-controller/nginx-ingress-controller:0.30.0</span></span><br><span class="line"><span class="comment"># 为quay-mirror.qiniu.com/kubernetes-ingress-controller/nginx-ingress-controller:0.30.0</span></span><br><span class="line"><span class="comment"># 创建ingress-nginx</span></span><br><span class="line">[root@k8s-master01 ingress-controller]<span class="comment"># kubectl apply -f ./</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看ingress-nginx</span></span><br><span class="line">[root@k8s-master01 ingress-controller]<span class="comment"># kubectl get pod -n ingress-nginx</span></span><br><span class="line">NAME                                           READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/nginx-ingress-controller-fbf967dd5-4qpbp   1/1     Running   0          12h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看service</span></span><br><span class="line">[root@k8s-master01 ingress-controller]<span class="comment"># kubectl get svc -n ingress-nginx</span></span><br><span class="line">NAME            TYPE       CLUSTER-IP     EXTERNAL-IP   PORT(S)                      AGE</span><br><span class="line">ingress-nginx   NodePort   10.98.75.163   &lt;none&gt;        80:32240/TCP,443:31335/TCP   11h</span><br></pre></td></tr></table></figure>

<h5 id="7-5-2-准备service和pod"><a href="#7-5-2-准备service和pod" class="headerlink" title="7.5.2 准备service和pod"></a>7.5.2 准备service和pod</h5><p>为了后面的实验比较方便，创建如下图所示的模型</p>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200516102419998-1653564310709100.png" alt="img"></p>
<p>创建tomcat-nginx.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tomcat-deployment</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">tomcat-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">tomcat-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tomcat</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">tomcat:8.5-jre10-slim</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-service</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tomcat-service</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">tomcat-pod</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f tomcat-nginx.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get svc -n dev</span><br><span class="line">NAME             TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE</span><br><span class="line">nginx-service    ClusterIP   None         &lt;none&gt;        80/TCP     48s</span><br><span class="line">tomcat-service   ClusterIP   None         &lt;none&gt;        8080/TCP   48s</span><br></pre></td></tr></table></figure>

<h5 id="7-5-3-Http代理"><a href="#7-5-3-Http代理" class="headerlink" title="7.5.3 Http代理"></a>7.5.3 Http代理</h5><p>创建ingress-http.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-http</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">nginx.itheima.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">nginx-service</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">tomcat.itheima.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">tomcat-service</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f ingress-http.yaml</span><br><span class="line">ingress.extensions/ingress-http created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get ing ingress-http -n dev</span><br><span class="line">NAME           HOSTS                                  ADDRESS   PORTS   AGE</span><br><span class="line">ingress-http   nginx.itheima.com,tomcat.itheima.com             80      22s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看详情</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl describe ing ingress-http  -n dev</span><br><span class="line">...</span><br><span class="line">Rules:</span><br><span class="line">Host                Path  Backends</span><br><span class="line">----                ----  --------</span><br><span class="line">nginx.itheima.com   / nginx-service:80 (10.244.1.96:80,10.244.1.97:80,10.244.2.112:80)</span><br><span class="line">tomcat.itheima.com  / tomcat-service:8080(10.244.1.94:8080,10.244.1.95:8080,10.244.2.111:8080)</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">接下来,在本地电脑上配置host文件,解析上面的两个域名到192.168.109.100(master)上</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后,就可以分别访问tomcat.itheima.com:32240  和  nginx.itheima.com:32240 查看效果了</span></span><br></pre></td></tr></table></figure>

<h5 id="7-5-4-Https代理"><a href="#7-5-4-Https代理" class="headerlink" title="7.5.4 Https代理"></a>7.5.4 Https代理</h5><p>创建证书</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成证书</span></span><br><span class="line">openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj &quot;/C=CN/ST=BJ/L=BJ/O=nginx/CN=itheima.com&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建密钥</span></span><br><span class="line">kubectl create secret tls tls-secret --key tls.key --cert tls.crt</span><br></pre></td></tr></table></figure>

<p>创建ingress-https.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-https</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nginx.itheima.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">tomcat.itheima.com</span></span><br><span class="line">      <span class="attr">secretName:</span> <span class="string">tls-secret</span> <span class="comment"># 指定秘钥</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">nginx.itheima.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">nginx-service</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">tomcat.itheima.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">tomcat-service</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f ingress-https.yaml</span><br><span class="line">ingress.extensions/ingress-https created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get ing ingress-https -n dev</span><br><span class="line">NAME            HOSTS                                  ADDRESS         PORTS     AGE</span><br><span class="line">ingress-https   nginx.itheima.com,tomcat.itheima.com   10.104.184.38   80, 443   2m42s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看详情</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl describe ing ingress-https -n dev</span><br><span class="line">...</span><br><span class="line">TLS:</span><br><span class="line">  tls-secret terminates nginx.itheima.com,tomcat.itheima.com</span><br><span class="line">Rules:</span><br><span class="line">Host              Path Backends</span><br><span class="line">----              ---- --------</span><br><span class="line">nginx.itheima.com  /  nginx-service:80 (10.244.1.97:80,10.244.1.98:80,10.244.2.119:80)</span><br><span class="line">tomcat.itheima.com /  tomcat-service:8080(10.244.1.99:8080,10.244.2.117:8080,10.244.2.120:8080)</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下面可以通过浏览器访问https://nginx.itheima.com:31335 和 https://tomcat.itheima.com:31335来查看了</span></span><br></pre></td></tr></table></figure>

<h3 id="8-数据存储"><a href="#8-数据存储" class="headerlink" title="8. 数据存储"></a>8. 数据存储</h3><p>在前面已经提到，容器的生命周期可能很短，会被频繁地创建和销毁。那么容器在销毁时，保存在容器中的数据也会被清除。这种结果对用户来说，在某些情况下是不乐意看到的。为了持久化保存容器的数据，kubernetes引入了Volume的概念。</p>
<p>Volume是Pod中能够被多个容器访问的共享目录，它被定义在Pod上，然后被一个Pod里的多个容器挂载到具体的文件目录下，kubernetes通过Volume实现同一个Pod中不同容器之间的数据共享以及数据的持久化存储。Volume的生命容器不与Pod中单个容器的生命周期相关，当容器终止或者重启时，Volume中的数据也不会丢失。</p>
<p>kubernetes的Volume支持多种类型，比较常见的有下面几个：</p>
<ul>
<li>简单存储：EmptyDir、HostPath、NFS</li>
<li>高级存储：PV、PVC</li>
<li>配置存储：ConfigMap、Secret</li>
</ul>
<h4 id="8-1-基本存储"><a href="#8-1-基本存储" class="headerlink" title="8.1 基本存储"></a>8.1 基本存储</h4><h5 id="8-1-1-EmptyDir"><a href="#8-1-1-EmptyDir" class="headerlink" title="8.1.1 EmptyDir"></a>8.1.1 EmptyDir</h5><p>EmptyDir是最基础的Volume类型，一个EmptyDir就是Host上的一个空目录。</p>
<p>EmptyDir是在Pod被分配到Node时创建的，它的初始内容为空，并且无须指定宿主机上对应的目录文件，因为kubernetes会自动分配一个目录，当Pod销毁时， EmptyDir中的数据也会被永久删除。 EmptyDir用途如下：</p>
<ul>
<li>临时空间，例如用于某些应用程序运行时所需的临时目录，且无须永久保留</li>
<li>一个容器需要从另一个容器中获取数据的目录（多容器共享目录）</li>
</ul>
<p>接下来，通过一个容器之间文件共享的案例来使用一下EmptyDir。</p>
<p>在一个Pod中准备两个容器nginx和busybox，然后声明一个Volume分别挂在到两个容器的目录中，然后nginx容器负责向Volume中写日志，busybox中通过命令将日志内容读到控制台。</p>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200413174713773-1653564310709101.png" alt="img"></p>
<p>创建一个volume-emptydir.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">volume-emptydir</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">volumeMounts:</span>  <span class="comment"># 将logs-volume挂在到nginx容器中，对应的目录为 /var/log/nginx</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/var/log/nginx</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;tail -f /logs/access.log&quot;</span>] <span class="comment"># 初始命令，动态读取指定文件中内容</span></span><br><span class="line">    <span class="attr">volumeMounts:</span>  <span class="comment"># 将logs-volume 挂在到busybox容器中，对应的目录为 /logs</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/logs</span></span><br><span class="line">  <span class="attr">volumes:</span> <span class="comment"># 声明volume， name为logs-volume，类型为emptyDir</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">    <span class="attr">emptyDir:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建Pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f volume-emptydir.yaml</span><br><span class="line">pod/volume-emptydir created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods volume-emptydir -n dev -o wide</span><br><span class="line">NAME                  READY   STATUS    RESTARTS   AGE      IP       NODE   ...... </span><br><span class="line">volume-emptydir       2/2     Running   0          97s   10.42.2.9   node1  ......</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过podIp访问nginx</span></span><br><span class="line">[root@k8s-master01 ~]# curl 10.42.2.9</span><br><span class="line">......</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过kubectl logs命令查看指定容器的标准输出</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl logs -f volume-emptydir -n dev -c busybox</span><br><span class="line">10.42.1.0 - - [27/Jun/2021:15:08:54 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.29.0&quot; &quot;-&quot;</span><br></pre></td></tr></table></figure>

<h5 id="8-1-2-HostPath"><a href="#8-1-2-HostPath" class="headerlink" title="8.1.2 HostPath"></a>8.1.2 HostPath</h5><p>上节课提到，EmptyDir中数据不会被持久化，它会随着Pod的结束而销毁，如果想简单的将数据持久化到主机中，可以选择HostPath。</p>
<p>HostPath就是将Node主机中一个实际目录挂在到Pod中，以供容器使用，这样的设计就可以保证Pod销毁了，但是数据依据可以存在于Node主机上。</p>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200413214031331-1653564310709102.png" alt="img"></p>
<p>创建一个volume-hostpath.yaml：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">volume-hostpath</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/var/log/nginx</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;tail -f /logs/access.log&quot;</span>]</span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/logs</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">    <span class="attr">hostPath:</span> </span><br><span class="line">      <span class="attr">path:</span> <span class="string">/root/logs</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">DirectoryOrCreate</span>  <span class="comment"># 目录存在就使用，不存在就先创建后使用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">关于type的值的一点说明：</span><br><span class="line">    DirectoryOrCreate 目录存在就使用，不存在就先创建后使用</span><br><span class="line">    Directory   目录必须存在</span><br><span class="line">    FileOrCreate  文件存在就使用，不存在就先创建后使用</span><br><span class="line">    File 文件必须存在 </span><br><span class="line">    Socket  unix套接字必须存在</span><br><span class="line">    CharDevice  字符设备必须存在</span><br><span class="line">    BlockDevice 块设备必须存在</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建Pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f volume-hostpath.yaml</span><br><span class="line">pod/volume-hostpath created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods volume-hostpath -n dev -o wide</span><br><span class="line">NAME                  READY   STATUS    RESTARTS   AGE   IP             NODE   ......</span><br><span class="line">pod-volume-hostpath   2/2     Running   0          16s   10.42.2.10     node1  ......</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">访问nginx</span></span><br><span class="line">[root@k8s-master01 ~]# curl 10.42.2.10</span><br><span class="line"></span><br><span class="line">[root@k8s-master01 ~]# kubectl logs -f volume-emptydir -n dev -c busybox</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">接下来就可以去host的/root/logs目录下查看存储的文件了</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##  注意: 下面的操作需要到Pod所在的节点运行（案例中是node1）</span></span></span><br><span class="line">[root@node1 ~]# ls /root/logs/</span><br><span class="line">access.log  error.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同样的道理，如果在此目录下创建一个文件，到容器中也是可以看到的</span></span><br></pre></td></tr></table></figure>

<h5 id="8-1-3-NFS"><a href="#8-1-3-NFS" class="headerlink" title="8.1.3 NFS"></a>8.1.3 NFS</h5><p>HostPath可以解决数据持久化的问题，但是一旦Node节点故障了，Pod如果转移到了别的节点，又会出现问题了，此时需要准备单独的网络存储系统，比较常用的用NFS、CIFS。</p>
<p>NFS是一个网络文件存储系统，可以搭建一台NFS服务器，然后将Pod中的存储直接连接到NFS系统上，这样的话，无论Pod在节点上怎么转移，只要Node跟NFS的对接没问题，数据就可以成功访问。</p>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200413215133559-1653564310709103.png" alt="img"></p>
<p>1）首先要准备nfs的服务器，这里为了简单，直接是master节点做nfs服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在nfs上安装nfs服务</span></span><br><span class="line">[root@nfs ~]# yum install nfs-utils -y</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">准备一个共享目录</span></span><br><span class="line">[root@nfs ~]# mkdir /root/data/nfs -pv</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将共享目录以读写权限暴露给192.168.5.0/24网段中的所有主机</span></span><br><span class="line">[root@nfs ~]# vim /etc/exports</span><br><span class="line">[root@nfs ~]# more /etc/exports</span><br><span class="line">/root/data/nfs     192.168.5.0/24(rw,no_root_squash)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动nfs服务</span></span><br><span class="line">[root@nfs ~]# systemctl restart nfs</span><br></pre></td></tr></table></figure>

<p>2）接下来，要在的每个node节点上都安装下nfs，这样的目的是为了node节点可以驱动nfs设备</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在node上安装nfs服务，注意不需要启动</span></span><br><span class="line">[root@k8s-master01 ~]# yum install nfs-utils -y</span><br></pre></td></tr></table></figure>

<p>3）接下来，就可以编写pod的配置文件了，创建volume-nfs.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">volume-nfs</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/var/log/nginx</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;tail -f /logs/access.log&quot;</span>] </span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/logs</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">    <span class="attr">nfs:</span></span><br><span class="line">      <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.5</span><span class="number">.6</span>  <span class="comment">#nfs服务器地址</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/root/data/nfs</span> <span class="comment">#共享文件路径</span></span><br></pre></td></tr></table></figure>

<p>4）最后，运行下pod，观察结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f volume-nfs.yaml</span><br><span class="line">pod/volume-nfs created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods volume-nfs -n dev</span><br><span class="line">NAME                  READY   STATUS    RESTARTS   AGE</span><br><span class="line">volume-nfs        2/2     Running   0          2m9s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看nfs服务器上的共享目录，发现已经有文件了</span></span><br><span class="line">[root@k8s-master01 ~]# ls /root/data/</span><br><span class="line">access.log  error.log</span><br></pre></td></tr></table></figure>

<h4 id="8-2-高级存储"><a href="#8-2-高级存储" class="headerlink" title="8.2 高级存储"></a>8.2 高级存储</h4><p>前面已经学习了使用NFS提供存储，此时就要求用户会搭建NFS系统，并且会在yaml配置nfs。由于kubernetes支持的存储系统有很多，要求客户全都掌握，显然不现实。为了能够屏蔽底层存储实现的细节，方便用户使用， kubernetes引入PV和PVC两种资源对象。</p>
<ul>
<li><p>PV（Persistent Volume）是持久化卷的意思，是对底层的共享存储的一种抽象。一般情况下PV由kubernetes管理员进行创建和配置，它与底层具体的共享存储技术有关，并通过插件完成与共享存储的对接。</p>
</li>
<li><p>PVC（Persistent Volume Claim）是持久卷声明的意思，是用户对于存储需求的一种声明。换句话说，PVC其实就是用户向kubernetes系统发出的一种资源需求申请。</p>
</li>
</ul>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200514194111567-1653564310709104.png" alt="img"></p>
<p>使用了PV和PVC之后，工作可以得到进一步的细分：</p>
<ul>
<li>存储：存储工程师维护</li>
<li>PV： kubernetes管理员维护</li>
<li>PVC：kubernetes用户维护</li>
</ul>
<h5 id="8-2-1-PV"><a href="#8-2-1-PV" class="headerlink" title="8.2.1 PV"></a>8.2.1 PV</h5><p>PV是存储资源的抽象，下面是资源清单文件:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv2</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">nfs:</span> <span class="comment"># 存储类型，与底层真正存储对应</span></span><br><span class="line">  <span class="attr">capacity:</span>  <span class="comment"># 存储能力，目前只支持存储空间的设置</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">2Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span>  <span class="comment"># 访问模式</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="comment"># 存储类别</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="comment"># 回收策略</span></span><br></pre></td></tr></table></figure>

<p>PV 的关键配置参数说明：</p>
<ul>
<li><p><strong>存储类型</strong></p>
<p>底层实际存储的类型，kubernetes支持多种存储类型，每种存储类型的配置都有所差异</p>
</li>
<li><p><strong>存储能力（capacity）</strong></p>
</li>
</ul>
<p>目前只支持存储空间的设置( storage&#x3D;1Gi )，不过未来可能会加入IOPS、吞吐量等指标的配置</p>
<ul>
<li><p><strong>访问模式（accessModes）</strong></p>
<p>用于描述用户应用对存储资源的访问权限，访问权限包括下面几种方式：</p>
<ul>
<li>ReadWriteOnce（RWO）：读写权限，但是只能被单个节点挂载</li>
<li>ReadOnlyMany（ROX）： 只读权限，可以被多个节点挂载</li>
<li>ReadWriteMany（RWX）：读写权限，可以被多个节点挂载</li>
</ul>
<p><code>需要注意的是，底层不同的存储类型可能支持的访问模式不同</code></p>
</li>
<li><p><strong>回收策略（persistentVolumeReclaimPolicy）</strong></p>
<p>当PV不再被使用了之后，对其的处理方式。目前支持三种策略：</p>
<ul>
<li>Retain （保留） 保留数据，需要管理员手工清理数据</li>
<li>Recycle（回收） 清除 PV 中的数据，效果相当于执行 rm -rf &#x2F;thevolume&#x2F;*</li>
<li>Delete （删除） 与 PV 相连的后端存储完成 volume 的删除操作，当然这常见于云服务商的存储服务</li>
</ul>
<p><code>需要注意的是，底层不同的存储类型可能支持的回收策略不同</code></p>
</li>
<li><p><strong>存储类别</strong></p>
<p>PV可以通过storageClassName参数指定一个存储类别</p>
<ul>
<li>具有特定类别的PV只能与请求了该类别的PVC进行绑定</li>
<li>未设定类别的PV则只能与不请求任何类别的PVC进行绑定</li>
</ul>
</li>
<li><p><strong>状态（status）</strong></p>
<p>一个 PV 的生命周期中，可能会处于4中不同的阶段：</p>
<ul>
<li>Available（可用）： 表示可用状态，还未被任何 PVC 绑定</li>
<li>Bound（已绑定）： 表示 PV 已经被 PVC 绑定</li>
<li>Released（已释放）： 表示 PVC 被删除，但是资源还未被集群重新声明</li>
<li>Failed（失败）： 表示该 PV 的自动回收失败</li>
</ul>
</li>
</ul>
<p><strong>实验</strong></p>
<p>使用NFS作为存储，来演示PV的使用，创建3个PV，对应NFS中的3个暴露的路径。</p>
<ol>
<li>准备NFS环境</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建目录</span></span><br><span class="line">[root@nfs ~]# mkdir /root/data/&#123;pv1,pv2,pv3&#125; -pv</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">暴露服务</span></span><br><span class="line">[root@nfs ~]# more /etc/exports</span><br><span class="line">/root/data/pv1     192.168.5.0/24(rw,no_root_squash)</span><br><span class="line">/root/data/pv2     192.168.5.0/24(rw,no_root_squash)</span><br><span class="line">/root/data/pv3     192.168.5.0/24(rw,no_root_squash)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启服务</span></span><br><span class="line">[root@nfs ~]#  systemctl restart nfs</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建pv.yaml</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span>  <span class="string">pv1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span> </span><br><span class="line">    <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/root/data/pv1</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.5</span><span class="number">.6</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span>  <span class="string">pv2</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span> </span><br><span class="line">    <span class="attr">storage:</span> <span class="string">2Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/root/data/pv2</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.5</span><span class="number">.6</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span>  <span class="string">pv3</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span> </span><br><span class="line">    <span class="attr">storage:</span> <span class="string">3Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/root/data/pv3</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.5</span><span class="number">.6</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建 pv</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pv.yaml</span><br><span class="line">persistentvolume/pv1 created</span><br><span class="line">persistentvolume/pv2 created</span><br><span class="line">persistentvolume/pv3 created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看pv</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pv -o wide</span><br><span class="line">NAME   CAPACITY   ACCESS MODES  RECLAIM POLICY  STATUS      AGE   VOLUMEMODE</span><br><span class="line">pv1    1Gi        RWX            Retain        Available    10s   Filesystem</span><br><span class="line">pv2    2Gi        RWX            Retain        Available    10s   Filesystem</span><br><span class="line">pv3    3Gi        RWX            Retain        Available    9s    Filesystem</span><br></pre></td></tr></table></figure>

<h5 id="8-2-2-PVC"><a href="#8-2-2-PVC" class="headerlink" title="8.2.2 PVC"></a>8.2.2 PVC</h5><p>PVC是资源的申请，用来声明对存储空间、访问模式、存储类别需求信息。下面是资源清单文件:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pvc</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span> <span class="comment"># 访问模式</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 采用标签对PV选择</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="comment"># 存储类别</span></span><br><span class="line">  <span class="attr">resources:</span> <span class="comment"># 请求空间</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">5Gi</span></span><br></pre></td></tr></table></figure>

<p>PVC 的关键配置参数说明：</p>
<ul>
<li><strong>访问模式（accessModes）</strong></li>
</ul>
<p>用于描述用户应用对存储资源的访问权限</p>
<ul>
<li><p><strong>选择条件（selector）</strong></p>
<p>通过Label Selector的设置，可使PVC对于系统中己存在的PV进行筛选</p>
</li>
<li><p><strong>存储类别（storageClassName）</strong></p>
<p>PVC在定义时可以设定需要的后端存储的类别，只有设置了该class的pv才能被系统选出</p>
</li>
<li><p><strong>资源请求（Resources ）</strong></p>
<p>描述对存储资源的请求</p>
</li>
</ul>
<p><strong>实验</strong></p>
<ol>
<li>创建pvc.yaml，申请pv</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pvc1</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pvc2</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pvc3</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建pvc</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pvc.yaml</span><br><span class="line">persistentvolumeclaim/pvc1 created</span><br><span class="line">persistentvolumeclaim/pvc2 created</span><br><span class="line">persistentvolumeclaim/pvc3 created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看pvc</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pvc  -n dev -o wide</span><br><span class="line">NAME   STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE   VOLUMEMODE</span><br><span class="line">pvc1   Bound    pv1      1Gi        RWX                           15s   Filesystem</span><br><span class="line">pvc2   Bound    pv2      2Gi        RWX                           15s   Filesystem</span><br><span class="line">pvc3   Bound    pv3      3Gi        RWX                           15s   Filesystem</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看pv</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pv -o wide</span><br><span class="line">NAME  CAPACITY ACCESS MODES  RECLAIM POLICY  STATUS    CLAIM       AGE     VOLUMEMODE</span><br><span class="line">pv1    1Gi        RWx        Retain          Bound    dev/pvc1    3h37m    Filesystem</span><br><span class="line">pv2    2Gi        RWX        Retain          Bound    dev/pvc2    3h37m    Filesystem</span><br><span class="line">pv3    3Gi        RWX        Retain          Bound    dev/pvc3    3h37m    Filesystem   </span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建pods.yaml, 使用pv</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod1</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;while true;do echo pod1 &gt;&gt; /root/out.txt; sleep 10; done;&quot;</span>]</span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/root/</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">volume</span></span><br><span class="line">      <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">        <span class="attr">claimName:</span> <span class="string">pvc1</span></span><br><span class="line">        <span class="attr">readOnly:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod2</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;while true;do echo pod2 &gt;&gt; /root/out.txt; sleep 10; done;&quot;</span>]</span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/root/</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">volume</span></span><br><span class="line">      <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">        <span class="attr">claimName:</span> <span class="string">pvc2</span></span><br><span class="line">        <span class="attr">readOnly:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pods.yaml</span><br><span class="line">pod/pod1 created</span><br><span class="line">pod/pod2 created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev -o wide</span><br><span class="line">NAME   READY   STATUS    RESTARTS   AGE   IP            NODE   </span><br><span class="line">pod1   1/1     Running   0          14s   10.244.1.69   node1   </span><br><span class="line">pod2   1/1     Running   0          14s   10.244.1.70   node1  </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看pvc</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pvc -n dev -o wide</span><br><span class="line">NAME   STATUS   VOLUME   CAPACITY   ACCESS MODES      AGE   VOLUMEMODE</span><br><span class="line">pvc1   Bound    pv1      1Gi        RWX               94m   Filesystem</span><br><span class="line">pvc2   Bound    pv2      2Gi        RWX               94m   Filesystem</span><br><span class="line">pvc3   Bound    pv3      3Gi        RWX               94m   Filesystem</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看pv</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pv -n dev -o wide</span><br><span class="line">NAME   CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM       AGE     VOLUMEMODE</span><br><span class="line">pv1    1Gi        RWX            Retain           Bound    dev/pvc1    5h11m   Filesystem</span><br><span class="line">pv2    2Gi        RWX            Retain           Bound    dev/pvc2    5h11m   Filesystem</span><br><span class="line">pv3    3Gi        RWX            Retain           Bound    dev/pvc3    5h11m   Filesystem</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看nfs中的文件存储</span></span><br><span class="line">[root@nfs ~]# more /root/data/pv1/out.txt</span><br><span class="line">node1</span><br><span class="line">node1</span><br><span class="line">[root@nfs ~]# more /root/data/pv2/out.txt</span><br><span class="line">node2</span><br><span class="line">node2</span><br></pre></td></tr></table></figure>

<h5 id="8-2-3-生命周期"><a href="#8-2-3-生命周期" class="headerlink" title="8.2.3 生命周期"></a>8.2.3 生命周期</h5><p>PVC和PV是一一对应的，PV和PVC之间的相互作用遵循以下生命周期：</p>
<ul>
<li><p><strong>资源供应</strong>：管理员手动创建底层存储和PV</p>
</li>
<li><p><strong>资源绑定</strong>：用户创建PVC，kubernetes负责根据PVC的声明去寻找PV，并绑定</p>
<p>在用户定义好PVC之后，系统将根据PVC对存储资源的请求在已存在的PV中选择一个满足条件的</p>
<ul>
<li>一旦找到，就将该PV与用户定义的PVC进行绑定，用户的应用就可以使用这个PVC了</li>
<li>如果找不到，PVC则会无限期处于Pending状态，直到等到系统管理员创建了一个符合其要求的PV</li>
</ul>
<p>PV一旦绑定到某个PVC上，就会被这个PVC独占，不能再与其他PVC进行绑定了</p>
</li>
<li><p><strong>资源使用</strong>：用户可在pod中像volume一样使用pvc</p>
<p>Pod使用Volume的定义，将PVC挂载到容器内的某个路径进行使用。</p>
</li>
<li><p><strong>资源释放</strong>：用户删除pvc来释放pv</p>
<p>当存储资源使用完毕后，用户可以删除PVC，与该PVC绑定的PV将会被标记为“已释放”，但还不能立刻与其他PVC进行绑定。通过之前PVC写入的数据可能还被留在存储设备上，只有在清除之后该PV才能再次使用。</p>
</li>
<li><p><strong>资源回收</strong>：kubernetes根据pv设置的回收策略进行资源的回收</p>
<p>对于PV，管理员可以设定回收策略，用于设置与之绑定的PVC释放资源之后如何处理遗留数据的问题。只有PV的存储空间完成回收，才能供新的PVC绑定和使用</p>
</li>
</ul>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200515002806726-1653564310709105.png" alt="img"></p>
<h4 id="8-3-配置存储"><a href="#8-3-配置存储" class="headerlink" title="8.3 配置存储"></a>8.3 配置存储</h4><h5 id="8-3-1-ConfigMap"><a href="#8-3-1-ConfigMap" class="headerlink" title="8.3.1 ConfigMap"></a>8.3.1 ConfigMap</h5><p>ConfigMap是一种比较特殊的存储卷，它的主要作用是用来存储配置信息的。</p>
<p>创建configmap.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">configmap</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">info:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    username:admin</span></span><br><span class="line"><span class="string">    password:123456</span></span><br></pre></td></tr></table></figure>

<p>接下来，使用此配置文件创建configmap</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建configmap</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f configmap.yaml</span><br><span class="line">configmap/configmap created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看configmap详情</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl describe cm configmap -n dev</span><br><span class="line">Name:         configmap</span><br><span class="line">Namespace:    dev</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">info:</span><br><span class="line">----</span><br><span class="line">username:admin</span><br><span class="line">password:123456</span><br><span class="line"></span><br><span class="line">Events:  &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>接下来创建一个pod-configmap.yaml，将上面创建的configmap挂载进去</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-configmap</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">volumeMounts:</span> <span class="comment"># 将configmap挂载到目录</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/configmap/config</span></span><br><span class="line">  <span class="attr">volumes:</span> <span class="comment"># 引用configmap</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">    <span class="attr">configMap:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">configmap</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-configmap.yaml</span><br><span class="line">pod/pod-configmap created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pod pod-configmap -n dev</span><br><span class="line">NAME            READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod-configmap   1/1     Running   0          6s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入容器</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl exec -it pod-configmap -n dev /bin/sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cd</span> /configmap/config/</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">info</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">more info</span></span><br><span class="line">username:admin</span><br><span class="line">password:123456</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以看到映射已经成功，每个configmap都映射成了一个目录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">key---&gt;文件     value----&gt;文件中的内容</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此时如果更新configmap的内容, 容器中的值也会动态更新</span></span><br></pre></td></tr></table></figure>

<h5 id="8-3-2-Secret"><a href="#8-3-2-Secret" class="headerlink" title="8.3.2 Secret"></a>8.3.2 Secret</h5><p>在kubernetes中，还存在一种和ConfigMap非常类似的对象，称为Secret对象。它主要用于存储敏感信息，例如密码、秘钥、证书等等。</p>
<ol>
<li>首先使用base64对数据进行编码</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-master01 ~]# echo -n &#x27;admin&#x27; | base64 #准备username</span><br><span class="line">YWRtaW4=</span><br><span class="line">[root@k8s-master01 ~]# echo -n &#x27;123456&#x27; | base64 #准备password</span><br><span class="line">MTIzNDU2</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>接下来编写secret.yaml，并创建Secret</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">YWRtaW4=</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">MTIzNDU2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建secret</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f secret.yaml</span><br><span class="line">secret/secret created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看secret详情</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl describe secret secret -n dev</span><br><span class="line">Name:         secret</span><br><span class="line">Namespace:    dev</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Type:  Opaque</span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">password:  6 bytes</span><br><span class="line">username:  5 bytes</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建pod-secret.yaml，将上面创建的secret挂载进去：</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-secret</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">volumeMounts:</span> <span class="comment"># 将secret挂载到目录</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/secret/config</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">    <span class="attr">secret:</span></span><br><span class="line">      <span class="attr">secretName:</span> <span class="string">secret</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-secret.yaml</span><br><span class="line">pod/pod-secret created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pod pod-secret -n dev</span><br><span class="line">NAME            READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod-secret      1/1     Running   0          2m28s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入容器，查看secret信息，发现已经自动解码了</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl exec -it pod-secret /bin/sh -n dev</span><br><span class="line">/ # ls /secret/config/</span><br><span class="line">password  username</span><br><span class="line">/ # more /secret/config/username</span><br><span class="line">admin</span><br><span class="line">/ # more /secret/config/password</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>

<p>至此，已经实现了利用secret实现了信息的编码。</p>
<h3 id="9-安全认证"><a href="#9-安全认证" class="headerlink" title="9. 安全认证"></a>9. 安全认证</h3><h4 id="9-1-访问控制概述"><a href="#9-1-访问控制概述" class="headerlink" title="9.1 访问控制概述"></a>9.1 访问控制概述</h4><p>Kubernetes作为一个分布式集群的管理工具，保证集群的安全性是其一个重要的任务。所谓的安全性其实就是保证对Kubernetes的各种<strong>客户端</strong>进行<strong>认证和鉴权</strong>操作。</p>
<p><strong>客户端</strong></p>
<p>在Kubernetes集群中，客户端通常有两类：</p>
<ul>
<li><strong>User Account</strong>：一般是独立于kubernetes之外的其他服务管理的用户账号。</li>
<li><strong>Service Account</strong>：kubernetes管理的账号，用于为Pod中的服务进程在访问Kubernetes时提供身份标识。</li>
</ul>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200520102949189-1653564310709106.png" alt="img"></p>
<p><strong>认证、授权与准入控制</strong></p>
<p>ApiServer是访问及管理资源对象的唯一入口。任何一个请求访问ApiServer，都要经过下面三个流程：</p>
<ul>
<li>Authentication（认证）：身份鉴别，只有正确的账号才能够通过认证</li>
<li>Authorization（授权）： 判断用户是否有权限对访问的资源执行特定的动作</li>
<li>Admission Control（准入控制）：用于补充授权机制以实现更加精细的访问控制功能。</li>
</ul>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200520103942580-1653564310709107.png" alt="img"></p>
<h4 id="9-2-认证管理"><a href="#9-2-认证管理" class="headerlink" title="9.2 认证管理"></a>9.2 认证管理</h4><p>Kubernetes集群安全的最关键点在于如何识别并认证客户端身份，它提供了3种客户端身份认证方式：</p>
<ul>
<li><p>HTTP Base认证：通过用户名+密码的方式认证</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这种认证方式是把“用户名:密码”用BASE64算法进行编码后的字符串放在HTTP请求中的Header Authorization域里发送给服务端。服务端收到后进行解码，获取用户名及密码，然后进行用户身份认证的过程。</span><br></pre></td></tr></table></figure>
</li>
<li><p>HTTP Token认证：通过一个Token来识别合法用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这种认证方式是用一个很长的难以被模仿的字符串--Token来表明客户身份的一种方式。每个Token对应一个用户名，当客户端发起API调用请求时，需要在HTTP Header里放入Token，API Server接到Token后会跟服务器中保存的token进行比对，然后进行用户身份认证的过程。</span><br></pre></td></tr></table></figure>
</li>
<li><p>HTTPS证书认证：基于CA根证书签名的双向数字证书认证方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这种认证方式是安全性最高的一种方式，但是同时也是操作起来最麻烦的一种方式。</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200518211037434-1653564310709108.png" alt="img"></p>
<p><strong>HTTPS认证大体分为3个过程：</strong></p>
<ol>
<li><p>证书申请和下发</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTPS通信双方的服务器向CA机构申请证书，CA机构下发根证书、服务端证书及私钥给申请者</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端和服务端的双向认证</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&gt; 客户端向服务器端发起请求，服务端下发自己的证书给客户端，</span><br><span class="line">   客户端接收到证书后，通过私钥解密证书，在证书中获得服务端的公钥，</span><br><span class="line">   客户端利用服务器端的公钥认证证书中的信息，如果一致，则认可这个服务器</span><br><span class="line">2&gt; 客户端发送自己的证书给服务器端，服务端接收到证书后，通过私钥解密证书，</span><br><span class="line">   在证书中获得客户端的公钥，并用该公钥认证证书信息，确认客户端是否合法</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务器端和客户端进行通信</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">服务器端和客户端协商好加密方案后，客户端会产生一个随机的秘钥并加密，然后发送到服务器端。</span><br><span class="line">服务器端接收这个秘钥后，双方接下来通信的所有内容都通过该随机秘钥加密</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>注意: Kubernetes允许同时配置多种认证方式，只要其中任意一个方式认证通过即可</p>
</blockquote>
<h4 id="9-3-授权管理"><a href="#9-3-授权管理" class="headerlink" title="9.3 授权管理"></a>9.3 授权管理</h4><p>授权发生在认证成功之后，通过认证就可以知道请求用户是谁， 然后Kubernetes会根据事先定义的授权策略来决定用户是否有权限访问，这个过程就称为授权。</p>
<p>每个发送到ApiServer的请求都带上了用户和资源的信息：比如发送请求的用户、请求的路径、请求的动作等，授权就是根据这些信息和授权策略进行比较，如果符合策略，则认为授权通过，否则会返回错误。</p>
<p>API Server目前支持以下几种授权策略：</p>
<ul>
<li>AlwaysDeny：表示拒绝所有请求，一般用于测试</li>
<li>AlwaysAllow：允许接收所有请求，相当于集群不需要授权流程（Kubernetes默认的策略）</li>
<li>ABAC：基于属性的访问控制，表示使用用户配置的授权规则对用户请求进行匹配和控制</li>
<li>Webhook：通过调用外部REST服务对用户进行授权</li>
<li>Node：是一种专用模式，用于对kubelet发出的请求进行访问控制</li>
<li>RBAC：基于角色的访问控制（kubeadm安装方式下的默认选项）</li>
</ul>
<p>RBAC(Role-Based Access Control) 基于角色的访问控制，主要是在描述一件事情：<strong>给哪些对象授予了哪些权限</strong></p>
<p>其中涉及到了下面几个概念：</p>
<ul>
<li>对象：User、Groups、ServiceAccount</li>
<li>角色：代表着一组定义在资源上的可操作动作(权限)的集合</li>
<li>绑定：将定义好的角色跟用户绑定在一起</li>
</ul>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200519181209566-1653564310709109.png" alt="img"></p>
<p>RBAC引入了4个顶级资源对象：</p>
<ul>
<li>Role、ClusterRole：角色，用于指定一组权限</li>
<li>RoleBinding、ClusterRoleBinding：角色绑定，用于将角色（权限）赋予给对象</li>
</ul>
<p><strong>Role、ClusterRole</strong></p>
<p>一个角色就是一组权限的集合，这里的权限都是许可形式的（白名单）。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Role只能对命名空间内的资源进行授权，需要指定nameapce</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">authorization-role</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]  <span class="comment"># 支持的API组列表,&quot;&quot; 空字符串，表示核心API群</span></span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;pods&quot;</span>] <span class="comment"># 支持的资源对象列表</span></span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;list&quot;</span>] <span class="comment"># 允许的对资源对象的操作方法列表</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ClusterRole可以对集群范围内资源、跨namespaces的范围资源、非资源类型进行授权</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">authorization-clusterrole</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;pods&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;list&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>需要详细说明的是，rules中的参数：</p>
<ul>
<li><p>apiGroups: 支持的API组列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span>,<span class="string">&quot;apps&quot;</span>, <span class="string">&quot;autoscaling&quot;</span>, <span class="string">&quot;batch&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>resources：支持的资源对象列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;services&quot;</span>, <span class="string">&quot;endpoints&quot;</span>, <span class="string">&quot;pods&quot;</span>,<span class="string">&quot;secrets&quot;</span>,<span class="string">&quot;configmaps&quot;</span>,<span class="string">&quot;crontabs&quot;</span>,<span class="string">&quot;deployments&quot;</span>,<span class="string">&quot;jobs&quot;</span>,</span><br><span class="line"><span class="string">&quot;nodes&quot;</span>,<span class="string">&quot;rolebindings&quot;</span>,<span class="string">&quot;clusterroles&quot;</span>,<span class="string">&quot;daemonsets&quot;</span>,<span class="string">&quot;replicasets&quot;</span>,<span class="string">&quot;statefulsets&quot;</span>,</span><br><span class="line"><span class="string">&quot;horizontalpodautoscalers&quot;</span>,<span class="string">&quot;replicationcontrollers&quot;</span>,<span class="string">&quot;cronjobs&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>verbs：对资源对象的操作方法列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;create&quot;</span>, <span class="string">&quot;update&quot;</span>, <span class="string">&quot;patch&quot;</span>, <span class="string">&quot;delete&quot;</span>, <span class="string">&quot;exec&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>RoleBinding、ClusterRoleBinding</strong></p>
<p>角色绑定用来把一个角色绑定到一个目标对象上，绑定目标可以是User、Group或者ServiceAccount。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># RoleBinding可以将同一namespace中的subject绑定到某个Role下，则此subject即具有该Role定义的权限</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">authorization-role-binding</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">heima</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">authorization-role</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ClusterRoleBinding在整个集群级别和所有namespaces将特定的subject与ClusterRole绑定，授予权限</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">authorization-clusterrole-binding</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">heima</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">authorization-clusterrole</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>

<p><strong>RoleBinding引用ClusterRole进行授权</strong></p>
<p>RoleBinding可以引用ClusterRole，对属于同一命名空间内ClusterRole定义的资源主体进行授权。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一种很常用的做法就是，集群管理员为集群范围预定义好一组角色（ClusterRole），然后在多个命名空间中重复使用这些ClusterRole。这样可以大幅提高授权管理工作效率，也使得各个命名空间下的基础性授权规则与使用体验保持一致。</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 虽然authorization-clusterrole是一个集群角色，但是因为使用了RoleBinding</span></span><br><span class="line"><span class="comment"># 所以heima只能读取dev命名空间中的资源</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">authorization-role-binding-ns</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">heima</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">authorization-clusterrole</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>

<p><strong>实战：创建一个只能管理dev空间下Pods资源的账号</strong></p>
<ol>
<li>创建账号</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1) 创建证书</span></span><br><span class="line">[root@k8s-master01 pki]# cd /etc/kubernetes/pki/</span><br><span class="line">[root@k8s-master01 pki]# (umask 077;openssl genrsa -out devman.key 2048)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2) 用apiserver的证书去签署</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2-1) 签名申请，申请的用户是devman,组是devgroup</span></span><br><span class="line">[root@k8s-master01 pki]# openssl req -new -key devman.key -out devman.csr -subj &quot;/CN=devman/O=devgroup&quot;     </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2-2) 签署证书</span></span><br><span class="line">[root@k8s-master01 pki]# openssl x509 -req -in devman.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out devman.crt -days 3650</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3) 设置集群、用户、上下文信息</span></span><br><span class="line">[root@k8s-master01 pki]# kubectl config set-cluster kubernetes --embed-certs=true --certificate-authority=/etc/kubernetes/pki/ca.crt --server=https://192.168.109.100:6443</span><br><span class="line"></span><br><span class="line">[root@k8s-master01 pki]# kubectl config set-credentials devman --embed-certs=true --client-certificate=/etc/kubernetes/pki/devman.crt --client-key=/etc/kubernetes/pki/devman.key</span><br><span class="line"></span><br><span class="line">[root@k8s-master01 pki]# kubectl config set-context devman@kubernetes --cluster=kubernetes --user=devman</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换账户到devman</span></span><br><span class="line">[root@k8s-master01 pki]# kubectl config use-context devman@kubernetes</span><br><span class="line">Switched to context &quot;devman@kubernetes&quot;.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看dev下pod，发现没有权限</span></span><br><span class="line">[root@k8s-master01 pki]# kubectl get pods -n dev</span><br><span class="line">Error from server (Forbidden): pods is forbidden: User &quot;devman&quot; cannot list resource &quot;pods&quot; in API group &quot;&quot; in the namespace &quot;dev&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到admin账户</span></span><br><span class="line">[root@k8s-master01 pki]# kubectl config use-context kubernetes-admin@kubernetes</span><br><span class="line">Switched to context &quot;kubernetes-admin@kubernetes&quot;.</span><br></pre></td></tr></table></figure>

<p>2） 创建Role和RoleBinding，为devman用户授权</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dev-role</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;pods&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;list&quot;</span>]</span><br><span class="line">  </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">authorization-role-binding</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">devman</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dev-role</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-master01 pki]# kubectl create -f dev-role.yaml</span><br><span class="line">role.rbac.authorization.k8s.io/dev-role created</span><br><span class="line">rolebinding.rbac.authorization.k8s.io/authorization-role-binding created</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>切换账户，再次验证</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换账户到devman</span></span><br><span class="line">[root@k8s-master01 pki]# kubectl config use-context devman@kubernetes</span><br><span class="line">Switched to context &quot;devman@kubernetes&quot;.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再次查看</span></span><br><span class="line">[root@k8s-master01 pki]# kubectl get pods -n dev</span><br><span class="line">NAME                                 READY   STATUS             RESTARTS   AGE</span><br><span class="line">nginx-deployment-66cb59b984-8wp2k    1/1     Running            0          4d1h</span><br><span class="line">nginx-deployment-66cb59b984-dc46j    1/1     Running            0          4d1h</span><br><span class="line">nginx-deployment-66cb59b984-thfck    1/1     Running            0          4d1h</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为了不影响后面的学习,切回admin账户</span></span><br><span class="line">[root@k8s-master01 pki]# kubectl config use-context kubernetes-admin@kubernetes</span><br><span class="line">Switched to context &quot;kubernetes-admin@kubernetes&quot;.</span><br></pre></td></tr></table></figure>

<h4 id="9-4-准入控制"><a href="#9-4-准入控制" class="headerlink" title="9.4 准入控制"></a>9.4 准入控制</h4><p>通过了前面的认证和授权之后，还需要经过准入控制处理通过之后，apiserver才会处理这个请求。</p>
<p>准入控制是一个可配置的控制器列表，可以通过在Api-Server上通过命令行设置选择执行哪些准入控制器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--admission-control=NamespaceLifecycle,LimitRanger,ServiceAccount,PersistentVolumeLabel,</span><br><span class="line">                      DefaultStorageClass,ResourceQuota,DefaultTolerationSeconds</span><br></pre></td></tr></table></figure>

<p>只有当所有的准入控制器都检查通过之后，apiserver才执行该请求，否则返回拒绝。</p>
<p>当前可配置的Admission Control准入控制如下：</p>
<ul>
<li>AlwaysAdmit：允许所有请求</li>
<li>AlwaysDeny：禁止所有请求，一般用于测试</li>
<li>AlwaysPullImages：在启动容器之前总去下载镜像</li>
<li>DenyExecOnPrivileged：它会拦截所有想在Privileged Container上执行命令的请求</li>
<li>ImagePolicyWebhook：这个插件将允许后端的一个Webhook程序来完成admission controller的功能。</li>
<li>Service Account：实现ServiceAccount实现了自动化</li>
<li>SecurityContextDeny：这个插件将使用SecurityContext的Pod中的定义全部失效</li>
<li>ResourceQuota：用于资源配额管理目的，观察所有请求，确保在namespace上的配额不会超标</li>
<li>LimitRanger：用于资源限制管理，作用于namespace上，确保对Pod进行资源限制</li>
<li>InitialResources：为未设置资源请求与限制的Pod，根据其镜像的历史资源的使用情况进行设置</li>
<li>NamespaceLifecycle：如果尝试在一个不存在的namespace中创建资源对象，则该创建请求将被拒绝。当删除一个namespace时，系统将会删除该namespace中所有对象。</li>
<li>DefaultStorageClass：为了实现共享存储的动态供应，为未指定StorageClass或PV的PVC尝试匹配默认的StorageClass，尽可能减少用户在申请PVC时所需了解的后端存储细节</li>
<li>DefaultTolerationSeconds：这个插件为那些没有设置forgiveness tolerations并具有notready:NoExecute和unreachable:NoExecute两种taints的Pod设置默认的“容忍”时间，为5min</li>
<li>PodSecurityPolicy：这个插件用于在创建或修改Pod时决定是否根据Pod的security context和可用的PodSecurityPolicy对Pod的安全策略进行控制</li>
</ul>
<h3 id="10-DashBoard"><a href="#10-DashBoard" class="headerlink" title="10. DashBoard"></a>10. DashBoard</h3><p>之前在kubernetes中完成的所有操作都是通过命令行工具kubectl完成的。其实，为了提供更丰富的用户体验，kubernetes还开发了一个基于web的用户界面（Dashboard）。用户可以使用Dashboard部署容器化的应用，还可以监控应用的状态，执行故障排查以及管理kubernetes中各种资源。</p>
<h4 id="10-1-部署Dashboard"><a href="#10-1-部署Dashboard" class="headerlink" title="10.1 部署Dashboard"></a>10.1 部署Dashboard</h4><ol>
<li>下载yaml，并运行Dashboard</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载yaml</span></span><br><span class="line">[root@k8s-master01 ~]# wget  https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/deploy/recommended.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改kubernetes-dashboard的Service类型</span></span><br><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  name: kubernetes-dashboard</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort  # 新增</span><br><span class="line">  ports:</span><br><span class="line">    - port: 443</span><br><span class="line">      targetPort: 8443</span><br><span class="line">      nodePort: 30009  # 新增</span><br><span class="line">  selector:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">部署</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f recommended.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看namespace下的kubernetes-dashboard下的资源</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pod,svc -n kubernetes-dashboard</span><br><span class="line">NAME                                            READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/dashboard-metrics-scraper-c79c65bb7-zwfvw   1/1     Running   0          111s</span><br><span class="line">pod/kubernetes-dashboard-56484d4c5-z95z5        1/1     Running   0          111s</span><br><span class="line"></span><br><span class="line">NAME                               TYPE       CLUSTER-IP      EXTERNAL-IP  PORT(S)         AGE</span><br><span class="line">service/dashboard-metrics-scraper  ClusterIP  10.96.89.218    &lt;none&gt;       8000/TCP        111s</span><br><span class="line">service/kubernetes-dashboard       NodePort   10.104.178.171  &lt;none&gt;       443:30009/TCP   111s</span><br></pre></td></tr></table></figure>

<p>2）创建访问账户，获取token</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建账号</span></span><br><span class="line">[root@k8s-master01-1 ~]# kubectl create serviceaccount dashboard-admin -n kubernetes-dashboard</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">授权</span></span><br><span class="line">[root@k8s-master01-1 ~]# kubectl create clusterrolebinding dashboard-admin-rb --clusterrole=cluster-admin --serviceaccount=kubernetes-dashboard:dashboard-admin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取账号token</span></span><br><span class="line">[root@k8s-master01 ~]#  kubectl get secrets -n kubernetes-dashboard | grep dashboard-admin</span><br><span class="line">dashboard-admin-token-xbqhh        kubernetes.io/service-account-token   3      2m35s</span><br><span class="line"></span><br><span class="line">[root@k8s-master01 ~]# kubectl describe secrets dashboard-admin-token-xbqhh -n kubernetes-dashboard</span><br><span class="line">Name:         dashboard-admin-token-xbqhh</span><br><span class="line">Namespace:    kubernetes-dashboard</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  kubernetes.io/service-account.name: dashboard-admin</span><br><span class="line">              kubernetes.io/service-account.uid: 95d84d80-be7a-4d10-a2e0-68f90222d039</span><br><span class="line"></span><br><span class="line">Type:  kubernetes.io/service-account-token</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">namespace:  20 bytes</span><br><span class="line">token:      eyJhbGciOiJSUzI1NiIsImtpZCI6ImJrYkF4bW5XcDhWcmNGUGJtek5NODFuSXl1aWptMmU2M3o4LTY5a2FKS2cifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJkYXNoYm9hcmQtYWRtaW4tdG9rZW4teGJxaGgiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiZGFzaGJvYXJkLWFkbWluIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQudWlkIjoiOTVkODRkODAtYmU3YS00ZDEwLWEyZTAtNjhmOTAyMjJkMDM5Iiwic3ViIjoic3lzdGVtOnNlcnZpY2VhY2NvdW50Omt1YmVybmV0ZXMtZGFzaGJvYXJkOmRhc2hib2FyZC1hZG1pbiJ9.NAl7e8ZfWWdDoPxkqzJzTB46sK9E8iuJYnUI9vnBaY3Jts7T1g1msjsBnbxzQSYgAG--cV0WYxjndzJY_UWCwaGPrQrt_GunxmOK9AUnzURqm55GR2RXIZtjsWVP2EBatsDgHRmuUbQvTFOvdJB4x3nXcYLN2opAaMqg3rnU2rr-A8zCrIuX_eca12wIp_QiuP3SF-tzpdLpsyRfegTJZl6YnSGyaVkC9id-cxZRb307qdCfXPfCHR_2rt5FVfxARgg_C0e3eFHaaYQO7CitxsnIoIXpOFNAR8aUrmopJyODQIPqBWUehb7FhlU1DCduHnIIXVC_UICZ-MKYewBDLw</span><br><span class="line">ca.crt:     1025 bytes</span><br></pre></td></tr></table></figure>

<p>3）通过浏览器访问Dashboard的UI</p>
<p>在登录页面上输入上面的token</p>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200520144548997-1653564310709110.png" alt="image-20200520144548997"></p>
<p>出现下面的页面代表成功</p>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200520144959353-1653564310709111.png" alt="image-20200520144959353"></p>
<h4 id="10-2-使用DashBoard"><a href="#10-2-使用DashBoard" class="headerlink" title="10.2 使用DashBoard"></a>10.2 使用DashBoard</h4><p>本章节以Deployment为例演示DashBoard的使用</p>
<p><strong>查看</strong></p>
<p>选择指定的命名空间<code>dev</code>，然后点击<code>Deployments</code>，查看dev空间下的所有deployment</p>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200520154628679-1653564310709112.png" alt="img"></p>
<p><strong>扩缩容</strong></p>
<p>在<code>Deployment</code>上点击<code>规模</code>，然后指定<code>目标副本数量</code>，点击确定</p>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200520162605102-1653564310709113.png" alt="img"></p>
<p><strong>编辑</strong></p>
<p>在<code>Deployment</code>上点击<code>编辑</code>，然后修改<code>yaml文件</code>，点击确定</p>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200520163253644-1653564310709114.png" alt="image-20200520163253644"></p>
<p><strong>查看Pod</strong></p>
<p>点击<code>Pods</code>, 查看pods列表</p>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200520163552110-1653564310709115.png" alt="img"></p>
<p><strong>操作Pod</strong></p>
<p>选中某个Pod，可以对其执行日志（logs）、进入执行（exec）、编辑、删除操作</p>
<p><img data-src="/2022/05/26/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20200520163832827-1653564310709116.png" alt="img"></p>
<blockquote>
<p>Dashboard提供了kubectl的绝大部分功能，这里不再一一演示</p>
</blockquote>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>容器编排</tag>
        <tag>Kubernetes</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
</search>
